
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model TechnicalSpecification
 * 
 */
export type TechnicalSpecification = $Result.DefaultSelection<Prisma.$TechnicalSpecificationPayload>
/**
 * Model Cost
 * 
 */
export type Cost = $Result.DefaultSelection<Prisma.$CostPayload>
/**
 * Model AssetAccessory
 * 
 */
export type AssetAccessory = $Result.DefaultSelection<Prisma.$AssetAccessoryPayload>
/**
 * Model ErrorCategory
 * 
 */
export type ErrorCategory = $Result.DefaultSelection<Prisma.$ErrorCategoryPayload>
/**
 * Model Error
 * 
 */
export type Error = $Result.DefaultSelection<Prisma.$ErrorPayload>
/**
 * Model AssetError
 * 
 */
export type AssetError = $Result.DefaultSelection<Prisma.$AssetErrorPayload>
/**
 * Model Part
 * 
 */
export type Part = $Result.DefaultSelection<Prisma.$PartPayload>
/**
 * Model AssetPart
 * 
 */
export type AssetPart = $Result.DefaultSelection<Prisma.$AssetPartPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model AssetTransfer
 * 
 */
export type AssetTransfer = $Result.DefaultSelection<Prisma.$AssetTransferPayload>
/**
 * Model Arrival
 * 
 */
export type Arrival = $Result.DefaultSelection<Prisma.$ArrivalPayload>
/**
 * Model Departure
 * 
 */
export type Departure = $Result.DefaultSelection<Prisma.$DeparturePayload>
/**
 * Model Hold
 * 
 */
export type Hold = $Result.DefaultSelection<Prisma.$HoldPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model AssetHistory
 * 
 */
export type AssetHistory = $Result.DefaultSelection<Prisma.$AssetHistoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Accessory: {
  NIC: 'NIC',
  PS: 'PS',
  PCL: 'PCL',
  UFR: 'UFR',
  FAX: 'FAX',
  USEND: 'USEND',
  DF: 'DF',
  CASS: 'CASS',
  FIN: 'FIN',
  BF: 'BF'
};

export type Accessory = (typeof Accessory)[keyof typeof Accessory]


export const AssetType: {
  COPIER: 'COPIER',
  FINISHER: 'FINISHER',
  ACCESSORY: 'ACCESSORY',
  SCANNER: 'SCANNER',
  PLOTTER: 'PLOTTER',
  PRINTER: 'PRINTER',
  WAREHOUSE_SUPPLIES: 'WAREHOUSE_SUPPLIES',
  FAX: 'FAX'
};

export type AssetType = (typeof AssetType)[keyof typeof AssetType]


export const TrackingStatus: {
  UNKNOWN: 'UNKNOWN',
  MISSING: 'MISSING',
  IN_TRANSIT: 'IN_TRANSIT',
  IN_STOCK: 'IN_STOCK',
  DEPARTED: 'DEPARTED'
};

export type TrackingStatus = (typeof TrackingStatus)[keyof typeof TrackingStatus]


export const ExitStatus: {
  UNKNOWN: 'UNKNOWN',
  OWNED: 'OWNED',
  SOLD: 'SOLD',
  PARTS: 'PARTS',
  SCRAP: 'SCRAP',
  RETURNED: 'RETURNED',
  LEASED: 'LEASED'
};

export type ExitStatus = (typeof ExitStatus)[keyof typeof ExitStatus]


export const TechnicalStatus: {
  NOT_TESTED: 'NOT_TESTED',
  OK: 'OK',
  ERROR: 'ERROR',
  PREPARED: 'PREPARED',
  PENDING: 'PENDING'
};

export type TechnicalStatus = (typeof TechnicalStatus)[keyof typeof TechnicalStatus]


export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  FINANCE: 'FINANCE',
  SALES: 'SALES'
};

export type Role = (typeof Role)[keyof typeof Role]


export const FileType: {
  PDF: 'PDF',
  IMAGE: 'IMAGE'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const GeneralOperation: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type GeneralOperation = (typeof GeneralOperation)[keyof typeof GeneralOperation]


export const PartOperation: {
  ADDED: 'ADDED',
  REMOVED: 'REMOVED'
};

export type PartOperation = (typeof PartOperation)[keyof typeof PartOperation]


export const InvoiceType: {
  PURCHASE: 'PURCHASE',
  SALE: 'SALE',
  OTHER: 'OTHER'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const DataField: {
  location: 'location',
  tracking_status: 'tracking_status',
  technical_status: 'technical_status',
  exit_status: 'exit_status',
  purchase_invoice: 'purchase_invoice',
  sales_invoice: 'sales_invoice',
  arrival: 'arrival',
  departure: 'departure',
  transfer: 'transfer',
  hold: 'hold',
  cost: 'cost',
  technical_specification: 'technical_specification',
  error: 'error',
  accessory: 'accessory',
  part: 'part'
};

export type DataField = (typeof DataField)[keyof typeof DataField]

}

export type Accessory = $Enums.Accessory

export const Accessory: typeof $Enums.Accessory

export type AssetType = $Enums.AssetType

export const AssetType: typeof $Enums.AssetType

export type TrackingStatus = $Enums.TrackingStatus

export const TrackingStatus: typeof $Enums.TrackingStatus

export type ExitStatus = $Enums.ExitStatus

export const ExitStatus: typeof $Enums.ExitStatus

export type TechnicalStatus = $Enums.TechnicalStatus

export const TechnicalStatus: typeof $Enums.TechnicalStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type GeneralOperation = $Enums.GeneralOperation

export const GeneralOperation: typeof $Enums.GeneralOperation

export type PartOperation = $Enums.PartOperation

export const PartOperation: typeof $Enums.PartOperation

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type DataField = $Enums.DataField

export const DataField: typeof $Enums.DataField

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assets
 * const assets = await prisma.asset.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assets
   * const assets = await prisma.asset.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicalSpecification`: Exposes CRUD operations for the **TechnicalSpecification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicalSpecifications
    * const technicalSpecifications = await prisma.technicalSpecification.findMany()
    * ```
    */
  get technicalSpecification(): Prisma.TechnicalSpecificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cost`: Exposes CRUD operations for the **Cost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costs
    * const costs = await prisma.cost.findMany()
    * ```
    */
  get cost(): Prisma.CostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetAccessory`: Exposes CRUD operations for the **AssetAccessory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetAccessories
    * const assetAccessories = await prisma.assetAccessory.findMany()
    * ```
    */
  get assetAccessory(): Prisma.AssetAccessoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.errorCategory`: Exposes CRUD operations for the **ErrorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ErrorCategories
    * const errorCategories = await prisma.errorCategory.findMany()
    * ```
    */
  get errorCategory(): Prisma.ErrorCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.error`: Exposes CRUD operations for the **Error** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Errors
    * const errors = await prisma.error.findMany()
    * ```
    */
  get error(): Prisma.ErrorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetError`: Exposes CRUD operations for the **AssetError** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetErrors
    * const assetErrors = await prisma.assetError.findMany()
    * ```
    */
  get assetError(): Prisma.AssetErrorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.part`: Exposes CRUD operations for the **Part** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.part.findMany()
    * ```
    */
  get part(): Prisma.PartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetPart`: Exposes CRUD operations for the **AssetPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetParts
    * const assetParts = await prisma.assetPart.findMany()
    * ```
    */
  get assetPart(): Prisma.AssetPartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetTransfer`: Exposes CRUD operations for the **AssetTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetTransfers
    * const assetTransfers = await prisma.assetTransfer.findMany()
    * ```
    */
  get assetTransfer(): Prisma.AssetTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arrival`: Exposes CRUD operations for the **Arrival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Arrivals
    * const arrivals = await prisma.arrival.findMany()
    * ```
    */
  get arrival(): Prisma.ArrivalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departure`: Exposes CRUD operations for the **Departure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departures
    * const departures = await prisma.departure.findMany()
    * ```
    */
  get departure(): Prisma.DepartureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hold`: Exposes CRUD operations for the **Hold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holds
    * const holds = await prisma.hold.findMany()
    * ```
    */
  get hold(): Prisma.HoldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetHistory`: Exposes CRUD operations for the **AssetHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetHistories
    * const assetHistories = await prisma.assetHistory.findMany()
    * ```
    */
  get assetHistory(): Prisma.AssetHistoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Asset: 'Asset',
    TechnicalSpecification: 'TechnicalSpecification',
    Cost: 'Cost',
    AssetAccessory: 'AssetAccessory',
    ErrorCategory: 'ErrorCategory',
    Error: 'Error',
    AssetError: 'AssetError',
    Part: 'Part',
    AssetPart: 'AssetPart',
    Transfer: 'Transfer',
    AssetTransfer: 'AssetTransfer',
    Arrival: 'Arrival',
    Departure: 'Departure',
    Hold: 'Hold',
    Invoice: 'Invoice',
    Warehouse: 'Warehouse',
    Location: 'Location',
    Brand: 'Brand',
    Model: 'Model',
    File: 'File',
    Comment: 'Comment',
    User: 'User',
    Organization: 'Organization',
    AssetHistory: 'AssetHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "asset" | "technicalSpecification" | "cost" | "assetAccessory" | "errorCategory" | "error" | "assetError" | "part" | "assetPart" | "transfer" | "assetTransfer" | "arrival" | "departure" | "hold" | "invoice" | "warehouse" | "location" | "brand" | "model" | "file" | "comment" | "user" | "organization" | "assetHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      TechnicalSpecification: {
        payload: Prisma.$TechnicalSpecificationPayload<ExtArgs>
        fields: Prisma.TechnicalSpecificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicalSpecificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          findFirst: {
            args: Prisma.TechnicalSpecificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          findMany: {
            args: Prisma.TechnicalSpecificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          create: {
            args: Prisma.TechnicalSpecificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          createMany: {
            args: Prisma.TechnicalSpecificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          delete: {
            args: Prisma.TechnicalSpecificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          update: {
            args: Prisma.TechnicalSpecificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          deleteMany: {
            args: Prisma.TechnicalSpecificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicalSpecificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          upsert: {
            args: Prisma.TechnicalSpecificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          aggregate: {
            args: Prisma.TechnicalSpecificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicalSpecification>
          }
          groupBy: {
            args: Prisma.TechnicalSpecificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicalSpecificationCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationCountAggregateOutputType> | number
          }
        }
      }
      Cost: {
        payload: Prisma.$CostPayload<ExtArgs>
        fields: Prisma.CostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findFirst: {
            args: Prisma.CostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findMany: {
            args: Prisma.CostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          create: {
            args: Prisma.CostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          createMany: {
            args: Prisma.CostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          delete: {
            args: Prisma.CostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          update: {
            args: Prisma.CostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          deleteMany: {
            args: Prisma.CostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          upsert: {
            args: Prisma.CostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          aggregate: {
            args: Prisma.CostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCost>
          }
          groupBy: {
            args: Prisma.CostGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCountArgs<ExtArgs>
            result: $Utils.Optional<CostCountAggregateOutputType> | number
          }
        }
      }
      AssetAccessory: {
        payload: Prisma.$AssetAccessoryPayload<ExtArgs>
        fields: Prisma.AssetAccessoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetAccessoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetAccessoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          findFirst: {
            args: Prisma.AssetAccessoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetAccessoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          findMany: {
            args: Prisma.AssetAccessoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>[]
          }
          create: {
            args: Prisma.AssetAccessoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          createMany: {
            args: Prisma.AssetAccessoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetAccessoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>[]
          }
          delete: {
            args: Prisma.AssetAccessoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          update: {
            args: Prisma.AssetAccessoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          deleteMany: {
            args: Prisma.AssetAccessoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetAccessoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetAccessoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>[]
          }
          upsert: {
            args: Prisma.AssetAccessoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAccessoryPayload>
          }
          aggregate: {
            args: Prisma.AssetAccessoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetAccessory>
          }
          groupBy: {
            args: Prisma.AssetAccessoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetAccessoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetAccessoryCountArgs<ExtArgs>
            result: $Utils.Optional<AssetAccessoryCountAggregateOutputType> | number
          }
        }
      }
      ErrorCategory: {
        payload: Prisma.$ErrorCategoryPayload<ExtArgs>
        fields: Prisma.ErrorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          findFirst: {
            args: Prisma.ErrorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          findMany: {
            args: Prisma.ErrorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>[]
          }
          create: {
            args: Prisma.ErrorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          createMany: {
            args: Prisma.ErrorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ErrorCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>[]
          }
          delete: {
            args: Prisma.ErrorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          update: {
            args: Prisma.ErrorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ErrorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ErrorCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ErrorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorCategoryPayload>
          }
          aggregate: {
            args: Prisma.ErrorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErrorCategory>
          }
          groupBy: {
            args: Prisma.ErrorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorCategoryCountAggregateOutputType> | number
          }
        }
      }
      Error: {
        payload: Prisma.$ErrorPayload<ExtArgs>
        fields: Prisma.ErrorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          findFirst: {
            args: Prisma.ErrorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          findMany: {
            args: Prisma.ErrorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>[]
          }
          create: {
            args: Prisma.ErrorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          createMany: {
            args: Prisma.ErrorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ErrorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>[]
          }
          delete: {
            args: Prisma.ErrorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          update: {
            args: Prisma.ErrorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          deleteMany: {
            args: Prisma.ErrorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ErrorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>[]
          }
          upsert: {
            args: Prisma.ErrorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorPayload>
          }
          aggregate: {
            args: Prisma.ErrorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateError>
          }
          groupBy: {
            args: Prisma.ErrorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorCountAggregateOutputType> | number
          }
        }
      }
      AssetError: {
        payload: Prisma.$AssetErrorPayload<ExtArgs>
        fields: Prisma.AssetErrorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetErrorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetErrorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          findFirst: {
            args: Prisma.AssetErrorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetErrorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          findMany: {
            args: Prisma.AssetErrorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>[]
          }
          create: {
            args: Prisma.AssetErrorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          createMany: {
            args: Prisma.AssetErrorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetErrorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>[]
          }
          delete: {
            args: Prisma.AssetErrorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          update: {
            args: Prisma.AssetErrorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          deleteMany: {
            args: Prisma.AssetErrorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetErrorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetErrorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>[]
          }
          upsert: {
            args: Prisma.AssetErrorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetErrorPayload>
          }
          aggregate: {
            args: Prisma.AssetErrorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetError>
          }
          groupBy: {
            args: Prisma.AssetErrorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetErrorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetErrorCountArgs<ExtArgs>
            result: $Utils.Optional<AssetErrorCountAggregateOutputType> | number
          }
        }
      }
      Part: {
        payload: Prisma.$PartPayload<ExtArgs>
        fields: Prisma.PartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findFirst: {
            args: Prisma.PartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findMany: {
            args: Prisma.PartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          create: {
            args: Prisma.PartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          createMany: {
            args: Prisma.PartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          delete: {
            args: Prisma.PartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          update: {
            args: Prisma.PartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          deleteMany: {
            args: Prisma.PartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          upsert: {
            args: Prisma.PartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          aggregate: {
            args: Prisma.PartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePart>
          }
          groupBy: {
            args: Prisma.PartGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartCountArgs<ExtArgs>
            result: $Utils.Optional<PartCountAggregateOutputType> | number
          }
        }
      }
      AssetPart: {
        payload: Prisma.$AssetPartPayload<ExtArgs>
        fields: Prisma.AssetPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          findFirst: {
            args: Prisma.AssetPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          findMany: {
            args: Prisma.AssetPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>[]
          }
          create: {
            args: Prisma.AssetPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          createMany: {
            args: Prisma.AssetPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetPartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>[]
          }
          delete: {
            args: Prisma.AssetPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          update: {
            args: Prisma.AssetPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          deleteMany: {
            args: Prisma.AssetPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetPartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>[]
          }
          upsert: {
            args: Prisma.AssetPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPartPayload>
          }
          aggregate: {
            args: Prisma.AssetPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetPart>
          }
          groupBy: {
            args: Prisma.AssetPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetPartCountArgs<ExtArgs>
            result: $Utils.Optional<AssetPartCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      AssetTransfer: {
        payload: Prisma.$AssetTransferPayload<ExtArgs>
        fields: Prisma.AssetTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          findFirst: {
            args: Prisma.AssetTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          findMany: {
            args: Prisma.AssetTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
          }
          create: {
            args: Prisma.AssetTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          createMany: {
            args: Prisma.AssetTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
          }
          delete: {
            args: Prisma.AssetTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          update: {
            args: Prisma.AssetTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          deleteMany: {
            args: Prisma.AssetTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
          }
          upsert: {
            args: Prisma.AssetTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTransferPayload>
          }
          aggregate: {
            args: Prisma.AssetTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetTransfer>
          }
          groupBy: {
            args: Prisma.AssetTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetTransferCountArgs<ExtArgs>
            result: $Utils.Optional<AssetTransferCountAggregateOutputType> | number
          }
        }
      }
      Arrival: {
        payload: Prisma.$ArrivalPayload<ExtArgs>
        fields: Prisma.ArrivalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArrivalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArrivalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          findFirst: {
            args: Prisma.ArrivalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArrivalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          findMany: {
            args: Prisma.ArrivalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>[]
          }
          create: {
            args: Prisma.ArrivalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          createMany: {
            args: Prisma.ArrivalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArrivalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>[]
          }
          delete: {
            args: Prisma.ArrivalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          update: {
            args: Prisma.ArrivalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          deleteMany: {
            args: Prisma.ArrivalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArrivalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArrivalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>[]
          }
          upsert: {
            args: Prisma.ArrivalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalPayload>
          }
          aggregate: {
            args: Prisma.ArrivalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArrival>
          }
          groupBy: {
            args: Prisma.ArrivalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArrivalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArrivalCountArgs<ExtArgs>
            result: $Utils.Optional<ArrivalCountAggregateOutputType> | number
          }
        }
      }
      Departure: {
        payload: Prisma.$DeparturePayload<ExtArgs>
        fields: Prisma.DepartureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          findFirst: {
            args: Prisma.DepartureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          findMany: {
            args: Prisma.DepartureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>[]
          }
          create: {
            args: Prisma.DepartureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          createMany: {
            args: Prisma.DepartureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>[]
          }
          delete: {
            args: Prisma.DepartureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          update: {
            args: Prisma.DepartureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          deleteMany: {
            args: Prisma.DepartureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>[]
          }
          upsert: {
            args: Prisma.DepartureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeparturePayload>
          }
          aggregate: {
            args: Prisma.DepartureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeparture>
          }
          groupBy: {
            args: Prisma.DepartureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartureCountArgs<ExtArgs>
            result: $Utils.Optional<DepartureCountAggregateOutputType> | number
          }
        }
      }
      Hold: {
        payload: Prisma.$HoldPayload<ExtArgs>
        fields: Prisma.HoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          findFirst: {
            args: Prisma.HoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          findMany: {
            args: Prisma.HoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>[]
          }
          create: {
            args: Prisma.HoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          createMany: {
            args: Prisma.HoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>[]
          }
          delete: {
            args: Prisma.HoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          update: {
            args: Prisma.HoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          deleteMany: {
            args: Prisma.HoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HoldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>[]
          }
          upsert: {
            args: Prisma.HoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldPayload>
          }
          aggregate: {
            args: Prisma.HoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHold>
          }
          groupBy: {
            args: Prisma.HoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoldCountArgs<ExtArgs>
            result: $Utils.Optional<HoldCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      AssetHistory: {
        payload: Prisma.$AssetHistoryPayload<ExtArgs>
        fields: Prisma.AssetHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          findFirst: {
            args: Prisma.AssetHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          findMany: {
            args: Prisma.AssetHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>[]
          }
          create: {
            args: Prisma.AssetHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          createMany: {
            args: Prisma.AssetHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>[]
          }
          delete: {
            args: Prisma.AssetHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          update: {
            args: Prisma.AssetHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AssetHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AssetHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          aggregate: {
            args: Prisma.AssetHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetHistory>
          }
          groupBy: {
            args: Prisma.AssetHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AssetHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    asset?: AssetOmit
    technicalSpecification?: TechnicalSpecificationOmit
    cost?: CostOmit
    assetAccessory?: AssetAccessoryOmit
    errorCategory?: ErrorCategoryOmit
    error?: ErrorOmit
    assetError?: AssetErrorOmit
    part?: PartOmit
    assetPart?: AssetPartOmit
    transfer?: TransferOmit
    assetTransfer?: AssetTransferOmit
    arrival?: ArrivalOmit
    departure?: DepartureOmit
    hold?: HoldOmit
    invoice?: InvoiceOmit
    warehouse?: WarehouseOmit
    location?: LocationOmit
    brand?: BrandOmit
    model?: ModelOmit
    file?: FileOmit
    comment?: CommentOmit
    user?: UserOmit
    organization?: OrganizationOmit
    assetHistory?: AssetHistoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    asset_accessories: number
    asset_errors: number
    asset_parts: number
    asset_transfers: number
    files: number
    comments: number
    asset_history: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_accessories?: boolean | AssetCountOutputTypeCountAsset_accessoriesArgs
    asset_errors?: boolean | AssetCountOutputTypeCountAsset_errorsArgs
    asset_parts?: boolean | AssetCountOutputTypeCountAsset_partsArgs
    asset_transfers?: boolean | AssetCountOutputTypeCountAsset_transfersArgs
    files?: boolean | AssetCountOutputTypeCountFilesArgs
    comments?: boolean | AssetCountOutputTypeCountCommentsArgs
    asset_history?: boolean | AssetCountOutputTypeCountAsset_historyArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAsset_accessoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAccessoryWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAsset_errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetErrorWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAsset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetPartWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAsset_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTransferWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAsset_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
  }


  /**
   * Count Type ErrorCategoryCountOutputType
   */

  export type ErrorCategoryCountOutputType = {
    errors: number
  }

  export type ErrorCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    errors?: boolean | ErrorCategoryCountOutputTypeCountErrorsArgs
  }

  // Custom InputTypes
  /**
   * ErrorCategoryCountOutputType without action
   */
  export type ErrorCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategoryCountOutputType
     */
    select?: ErrorCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ErrorCategoryCountOutputType without action
   */
  export type ErrorCategoryCountOutputTypeCountErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorWhereInput
  }


  /**
   * Count Type ErrorCountOutputType
   */

  export type ErrorCountOutputType = {
    asset_errors: number
  }

  export type ErrorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_errors?: boolean | ErrorCountOutputTypeCountAsset_errorsArgs
  }

  // Custom InputTypes
  /**
   * ErrorCountOutputType without action
   */
  export type ErrorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCountOutputType
     */
    select?: ErrorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ErrorCountOutputType without action
   */
  export type ErrorCountOutputTypeCountAsset_errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetErrorWhereInput
  }


  /**
   * Count Type PartCountOutputType
   */

  export type PartCountOutputType = {
    asset_parts: number
  }

  export type PartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_parts?: boolean | PartCountOutputTypeCountAsset_partsArgs
  }

  // Custom InputTypes
  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartCountOutputType
     */
    select?: PartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountAsset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetPartWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    asset_transfers: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_transfers?: boolean | TransferCountOutputTypeCountAsset_transfersArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountAsset_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTransferWhereInput
  }


  /**
   * Count Type ArrivalCountOutputType
   */

  export type ArrivalCountOutputType = {
    assets: number
  }

  export type ArrivalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | ArrivalCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * ArrivalCountOutputType without action
   */
  export type ArrivalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalCountOutputType
     */
    select?: ArrivalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArrivalCountOutputType without action
   */
  export type ArrivalCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type DepartureCountOutputType
   */

  export type DepartureCountOutputType = {
    assets: number
  }

  export type DepartureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | DepartureCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * DepartureCountOutputType without action
   */
  export type DepartureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartureCountOutputType
     */
    select?: DepartureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartureCountOutputType without action
   */
  export type DepartureCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type HoldCountOutputType
   */

  export type HoldCountOutputType = {
    assets: number
  }

  export type HoldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | HoldCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * HoldCountOutputType without action
   */
  export type HoldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoldCountOutputType
     */
    select?: HoldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HoldCountOutputType without action
   */
  export type HoldCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    purchase_assets: number
    sales_assets: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_assets?: boolean | InvoiceCountOutputTypeCountPurchase_assetsArgs
    sales_assets?: boolean | InvoiceCountOutputTypeCountSales_assetsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPurchase_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountSales_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    assets: number
    origin_transfers: number
    destination_transfers: number
    departures: number
    arrivals: number
    locations: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | WarehouseCountOutputTypeCountAssetsArgs
    origin_transfers?: boolean | WarehouseCountOutputTypeCountOrigin_transfersArgs
    destination_transfers?: boolean | WarehouseCountOutputTypeCountDestination_transfersArgs
    departures?: boolean | WarehouseCountOutputTypeCountDeparturesArgs
    arrivals?: boolean | WarehouseCountOutputTypeCountArrivalsArgs
    locations?: boolean | WarehouseCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountOrigin_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountDestination_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountDeparturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountArrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    assets: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | LocationCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    models: number
    errorCategories: number
    assets: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | BrandCountOutputTypeCountModelsArgs
    errorCategories?: boolean | BrandCountOutputTypeCountErrorCategoriesArgs
    assets?: boolean | BrandCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountErrorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorCategoryWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    assets: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | ModelCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    asset_errors_added: number
    asset_errors_fixed: number
    transfers: number
    departures: number
    departure_sales_reps: number
    arrivals: number
    holds_created: number
    holds_for: number
    invoices_updated: number
    files: number
    comments: number
    asset_history: number
    asset_parts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_errors_added?: boolean | UserCountOutputTypeCountAsset_errors_addedArgs
    asset_errors_fixed?: boolean | UserCountOutputTypeCountAsset_errors_fixedArgs
    transfers?: boolean | UserCountOutputTypeCountTransfersArgs
    departures?: boolean | UserCountOutputTypeCountDeparturesArgs
    departure_sales_reps?: boolean | UserCountOutputTypeCountDeparture_sales_repsArgs
    arrivals?: boolean | UserCountOutputTypeCountArrivalsArgs
    holds_created?: boolean | UserCountOutputTypeCountHolds_createdArgs
    holds_for?: boolean | UserCountOutputTypeCountHolds_forArgs
    invoices_updated?: boolean | UserCountOutputTypeCountInvoices_updatedArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    asset_history?: boolean | UserCountOutputTypeCountAsset_historyArgs
    asset_parts?: boolean | UserCountOutputTypeCountAsset_partsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAsset_errors_addedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetErrorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAsset_errors_fixedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetErrorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeparturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeparture_sales_repsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHolds_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHolds_forArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoices_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAsset_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAsset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetPartWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    invoices: number
    arrivals_origin: number
    arrivals_transporter: number
    departures_destination: number
    departures_transporter: number
    holds: number
    transfers: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | OrganizationCountOutputTypeCountInvoicesArgs
    arrivals_origin?: boolean | OrganizationCountOutputTypeCountArrivals_originArgs
    arrivals_transporter?: boolean | OrganizationCountOutputTypeCountArrivals_transporterArgs
    departures_destination?: boolean | OrganizationCountOutputTypeCountDepartures_destinationArgs
    departures_transporter?: boolean | OrganizationCountOutputTypeCountDepartures_transporterArgs
    holds?: boolean | OrganizationCountOutputTypeCountHoldsArgs
    transfers?: boolean | OrganizationCountOutputTypeCountTransfersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountArrivals_originArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountArrivals_transporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDepartures_destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDepartures_transporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    model_id: number | null
    warehouse_id: number | null
    purchase_invoice_id: number | null
    sales_invoice_id: number | null
    arrival_id: number | null
    departure_id: number | null
    hold_id: number | null
  }

  export type AssetSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    model_id: number | null
    warehouse_id: number | null
    purchase_invoice_id: number | null
    sales_invoice_id: number | null
    arrival_id: number | null
    departure_id: number | null
    hold_id: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: number | null
    barcode: string | null
    serial_number: string | null
    brand_id: number | null
    model_id: number | null
    warehouse_id: number | null
    asset_location: string | null
    asset_type: $Enums.AssetType | null
    tracking_status: $Enums.TrackingStatus | null
    exit_status: $Enums.ExitStatus | null
    technical_status: $Enums.TechnicalStatus | null
    purchase_invoice_id: number | null
    sales_invoice_id: number | null
    arrival_id: number | null
    departure_id: number | null
    hold_id: number | null
    is_held: boolean | null
    created_at: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: number | null
    barcode: string | null
    serial_number: string | null
    brand_id: number | null
    model_id: number | null
    warehouse_id: number | null
    asset_location: string | null
    asset_type: $Enums.AssetType | null
    tracking_status: $Enums.TrackingStatus | null
    exit_status: $Enums.ExitStatus | null
    technical_status: $Enums.TechnicalStatus | null
    purchase_invoice_id: number | null
    sales_invoice_id: number | null
    arrival_id: number | null
    departure_id: number | null
    hold_id: number | null
    is_held: boolean | null
    created_at: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    barcode: number
    serial_number: number
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location: number
    asset_type: number
    tracking_status: number
    exit_status: number
    technical_status: number
    purchase_invoice_id: number
    sales_invoice_id: number
    arrival_id: number
    departure_id: number
    hold_id: number
    is_held: number
    created_at: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    id?: true
    brand_id?: true
    model_id?: true
    warehouse_id?: true
    purchase_invoice_id?: true
    sales_invoice_id?: true
    arrival_id?: true
    departure_id?: true
    hold_id?: true
  }

  export type AssetSumAggregateInputType = {
    id?: true
    brand_id?: true
    model_id?: true
    warehouse_id?: true
    purchase_invoice_id?: true
    sales_invoice_id?: true
    arrival_id?: true
    departure_id?: true
    hold_id?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    barcode?: true
    serial_number?: true
    brand_id?: true
    model_id?: true
    warehouse_id?: true
    asset_location?: true
    asset_type?: true
    tracking_status?: true
    exit_status?: true
    technical_status?: true
    purchase_invoice_id?: true
    sales_invoice_id?: true
    arrival_id?: true
    departure_id?: true
    hold_id?: true
    is_held?: true
    created_at?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    barcode?: true
    serial_number?: true
    brand_id?: true
    model_id?: true
    warehouse_id?: true
    asset_location?: true
    asset_type?: true
    tracking_status?: true
    exit_status?: true
    technical_status?: true
    purchase_invoice_id?: true
    sales_invoice_id?: true
    arrival_id?: true
    departure_id?: true
    hold_id?: true
    is_held?: true
    created_at?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    barcode?: true
    serial_number?: true
    brand_id?: true
    model_id?: true
    warehouse_id?: true
    asset_location?: true
    asset_type?: true
    tracking_status?: true
    exit_status?: true
    technical_status?: true
    purchase_invoice_id?: true
    sales_invoice_id?: true
    arrival_id?: true
    departure_id?: true
    hold_id?: true
    is_held?: true
    created_at?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id: number | null
    sales_invoice_id: number | null
    arrival_id: number | null
    departure_id: number | null
    hold_id: number | null
    is_held: boolean
    created_at: Date
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    serial_number?: boolean
    brand_id?: boolean
    model_id?: boolean
    warehouse_id?: boolean
    asset_location?: boolean
    asset_type?: boolean
    tracking_status?: boolean
    exit_status?: boolean
    technical_status?: boolean
    purchase_invoice_id?: boolean
    sales_invoice_id?: boolean
    arrival_id?: boolean
    departure_id?: boolean
    hold_id?: boolean
    is_held?: boolean
    created_at?: boolean
    cost?: boolean | Asset$costArgs<ExtArgs>
    technical_specification?: boolean | Asset$technical_specificationArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
    asset_accessories?: boolean | Asset$asset_accessoriesArgs<ExtArgs>
    asset_errors?: boolean | Asset$asset_errorsArgs<ExtArgs>
    asset_parts?: boolean | Asset$asset_partsArgs<ExtArgs>
    asset_transfers?: boolean | Asset$asset_transfersArgs<ExtArgs>
    files?: boolean | Asset$filesArgs<ExtArgs>
    comments?: boolean | Asset$commentsArgs<ExtArgs>
    asset_history?: boolean | Asset$asset_historyArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    serial_number?: boolean
    brand_id?: boolean
    model_id?: boolean
    warehouse_id?: boolean
    asset_location?: boolean
    asset_type?: boolean
    tracking_status?: boolean
    exit_status?: boolean
    technical_status?: boolean
    purchase_invoice_id?: boolean
    sales_invoice_id?: boolean
    arrival_id?: boolean
    departure_id?: boolean
    hold_id?: boolean
    is_held?: boolean
    created_at?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    serial_number?: boolean
    brand_id?: boolean
    model_id?: boolean
    warehouse_id?: boolean
    asset_location?: boolean
    asset_type?: boolean
    tracking_status?: boolean
    exit_status?: boolean
    technical_status?: boolean
    purchase_invoice_id?: boolean
    sales_invoice_id?: boolean
    arrival_id?: boolean
    departure_id?: boolean
    hold_id?: boolean
    is_held?: boolean
    created_at?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    barcode?: boolean
    serial_number?: boolean
    brand_id?: boolean
    model_id?: boolean
    warehouse_id?: boolean
    asset_location?: boolean
    asset_type?: boolean
    tracking_status?: boolean
    exit_status?: boolean
    technical_status?: boolean
    purchase_invoice_id?: boolean
    sales_invoice_id?: boolean
    arrival_id?: boolean
    departure_id?: boolean
    hold_id?: boolean
    is_held?: boolean
    created_at?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barcode" | "serial_number" | "brand_id" | "model_id" | "warehouse_id" | "asset_location" | "asset_type" | "tracking_status" | "exit_status" | "technical_status" | "purchase_invoice_id" | "sales_invoice_id" | "arrival_id" | "departure_id" | "hold_id" | "is_held" | "created_at", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cost?: boolean | Asset$costArgs<ExtArgs>
    technical_specification?: boolean | Asset$technical_specificationArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
    asset_accessories?: boolean | Asset$asset_accessoriesArgs<ExtArgs>
    asset_errors?: boolean | Asset$asset_errorsArgs<ExtArgs>
    asset_parts?: boolean | Asset$asset_partsArgs<ExtArgs>
    asset_transfers?: boolean | Asset$asset_transfersArgs<ExtArgs>
    files?: boolean | Asset$filesArgs<ExtArgs>
    comments?: boolean | Asset$commentsArgs<ExtArgs>
    asset_history?: boolean | Asset$asset_historyArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
  }
  export type AssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchase_invoice?: boolean | Asset$purchase_invoiceArgs<ExtArgs>
    sales_invoice?: boolean | Asset$sales_invoiceArgs<ExtArgs>
    arrival?: boolean | Asset$arrivalArgs<ExtArgs>
    departure?: boolean | Asset$departureArgs<ExtArgs>
    hold?: boolean | Asset$holdArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      cost: Prisma.$CostPayload<ExtArgs> | null
      technical_specification: Prisma.$TechnicalSpecificationPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs>
      model: Prisma.$ModelPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
      purchase_invoice: Prisma.$InvoicePayload<ExtArgs> | null
      sales_invoice: Prisma.$InvoicePayload<ExtArgs> | null
      arrival: Prisma.$ArrivalPayload<ExtArgs> | null
      departure: Prisma.$DeparturePayload<ExtArgs> | null
      hold: Prisma.$HoldPayload<ExtArgs> | null
      asset_accessories: Prisma.$AssetAccessoryPayload<ExtArgs>[]
      asset_errors: Prisma.$AssetErrorPayload<ExtArgs>[]
      asset_parts: Prisma.$AssetPartPayload<ExtArgs>[]
      asset_transfers: Prisma.$AssetTransferPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      asset_history: Prisma.$AssetHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      barcode: string
      serial_number: string
      brand_id: number
      model_id: number
      warehouse_id: number
      asset_location: string | null
      asset_type: $Enums.AssetType
      tracking_status: $Enums.TrackingStatus
      exit_status: $Enums.ExitStatus
      technical_status: $Enums.TechnicalStatus
      purchase_invoice_id: number | null
      sales_invoice_id: number | null
      arrival_id: number | null
      departure_id: number | null
      hold_id: number | null
      is_held: boolean
      created_at: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cost<T extends Asset$costArgs<ExtArgs> = {}>(args?: Subset<T, Asset$costArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    technical_specification<T extends Asset$technical_specificationArgs<ExtArgs> = {}>(args?: Subset<T, Asset$technical_specificationArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends Asset$locationArgs<ExtArgs> = {}>(args?: Subset<T, Asset$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase_invoice<T extends Asset$purchase_invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Asset$purchase_invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales_invoice<T extends Asset$sales_invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Asset$sales_invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    arrival<T extends Asset$arrivalArgs<ExtArgs> = {}>(args?: Subset<T, Asset$arrivalArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    departure<T extends Asset$departureArgs<ExtArgs> = {}>(args?: Subset<T, Asset$departureArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hold<T extends Asset$holdArgs<ExtArgs> = {}>(args?: Subset<T, Asset$holdArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    asset_accessories<T extends Asset$asset_accessoriesArgs<ExtArgs> = {}>(args?: Subset<T, Asset$asset_accessoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_errors<T extends Asset$asset_errorsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$asset_errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_parts<T extends Asset$asset_partsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$asset_partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_transfers<T extends Asset$asset_transfersArgs<ExtArgs> = {}>(args?: Subset<T, Asset$asset_transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Asset$filesArgs<ExtArgs> = {}>(args?: Subset<T, Asset$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Asset$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_history<T extends Asset$asset_historyArgs<ExtArgs> = {}>(args?: Subset<T, Asset$asset_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'Int'>
    readonly barcode: FieldRef<"Asset", 'String'>
    readonly serial_number: FieldRef<"Asset", 'String'>
    readonly brand_id: FieldRef<"Asset", 'Int'>
    readonly model_id: FieldRef<"Asset", 'Int'>
    readonly warehouse_id: FieldRef<"Asset", 'Int'>
    readonly asset_location: FieldRef<"Asset", 'String'>
    readonly asset_type: FieldRef<"Asset", 'AssetType'>
    readonly tracking_status: FieldRef<"Asset", 'TrackingStatus'>
    readonly exit_status: FieldRef<"Asset", 'ExitStatus'>
    readonly technical_status: FieldRef<"Asset", 'TechnicalStatus'>
    readonly purchase_invoice_id: FieldRef<"Asset", 'Int'>
    readonly sales_invoice_id: FieldRef<"Asset", 'Int'>
    readonly arrival_id: FieldRef<"Asset", 'Int'>
    readonly departure_id: FieldRef<"Asset", 'Int'>
    readonly hold_id: FieldRef<"Asset", 'Int'>
    readonly is_held: FieldRef<"Asset", 'Boolean'>
    readonly created_at: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset.cost
   */
  export type Asset$costArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    where?: CostWhereInput
  }

  /**
   * Asset.technical_specification
   */
  export type Asset$technical_specificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    where?: TechnicalSpecificationWhereInput
  }

  /**
   * Asset.location
   */
  export type Asset$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Asset.purchase_invoice
   */
  export type Asset$purchase_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Asset.sales_invoice
   */
  export type Asset$sales_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Asset.arrival
   */
  export type Asset$arrivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    where?: ArrivalWhereInput
  }

  /**
   * Asset.departure
   */
  export type Asset$departureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
  }

  /**
   * Asset.hold
   */
  export type Asset$holdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    where?: HoldWhereInput
  }

  /**
   * Asset.asset_accessories
   */
  export type Asset$asset_accessoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    where?: AssetAccessoryWhereInput
    orderBy?: AssetAccessoryOrderByWithRelationInput | AssetAccessoryOrderByWithRelationInput[]
    cursor?: AssetAccessoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetAccessoryScalarFieldEnum | AssetAccessoryScalarFieldEnum[]
  }

  /**
   * Asset.asset_errors
   */
  export type Asset$asset_errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    where?: AssetErrorWhereInput
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    cursor?: AssetErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * Asset.asset_parts
   */
  export type Asset$asset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    where?: AssetPartWhereInput
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    cursor?: AssetPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * Asset.asset_transfers
   */
  export type Asset$asset_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    where?: AssetTransferWhereInput
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    cursor?: AssetTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetTransferScalarFieldEnum | AssetTransferScalarFieldEnum[]
  }

  /**
   * Asset.files
   */
  export type Asset$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Asset.comments
   */
  export type Asset$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Asset.asset_history
   */
  export type Asset$asset_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    cursor?: AssetHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model TechnicalSpecification
   */

  export type AggregateTechnicalSpecification = {
    _count: TechnicalSpecificationCountAggregateOutputType | null
    _avg: TechnicalSpecificationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationSumAggregateOutputType | null
    _min: TechnicalSpecificationMinAggregateOutputType | null
    _max: TechnicalSpecificationMaxAggregateOutputType | null
  }

  export type TechnicalSpecificationAvgAggregateOutputType = {
    id: number | null
    asset_id: number | null
    cassettes: number | null
    meter_black: number | null
    meter_colour: number | null
    meter_total: number | null
    drum_life_c: number | null
    drum_life_m: number | null
    drum_life_y: number | null
    drum_life_k: number | null
  }

  export type TechnicalSpecificationSumAggregateOutputType = {
    id: number | null
    asset_id: number | null
    cassettes: number | null
    meter_black: number | null
    meter_colour: number | null
    meter_total: number | null
    drum_life_c: number | null
    drum_life_m: number | null
    drum_life_y: number | null
    drum_life_k: number | null
  }

  export type TechnicalSpecificationMinAggregateOutputType = {
    id: number | null
    asset_id: number | null
    cassettes: number | null
    internal_finisher: string | null
    meter_black: number | null
    meter_colour: number | null
    meter_total: number | null
    drum_life_c: number | null
    drum_life_m: number | null
    drum_life_y: number | null
    drum_life_k: number | null
  }

  export type TechnicalSpecificationMaxAggregateOutputType = {
    id: number | null
    asset_id: number | null
    cassettes: number | null
    internal_finisher: string | null
    meter_black: number | null
    meter_colour: number | null
    meter_total: number | null
    drum_life_c: number | null
    drum_life_m: number | null
    drum_life_y: number | null
    drum_life_k: number | null
  }

  export type TechnicalSpecificationCountAggregateOutputType = {
    id: number
    asset_id: number
    cassettes: number
    internal_finisher: number
    meter_black: number
    meter_colour: number
    meter_total: number
    drum_life_c: number
    drum_life_m: number
    drum_life_y: number
    drum_life_k: number
    _all: number
  }


  export type TechnicalSpecificationAvgAggregateInputType = {
    id?: true
    asset_id?: true
    cassettes?: true
    meter_black?: true
    meter_colour?: true
    meter_total?: true
    drum_life_c?: true
    drum_life_m?: true
    drum_life_y?: true
    drum_life_k?: true
  }

  export type TechnicalSpecificationSumAggregateInputType = {
    id?: true
    asset_id?: true
    cassettes?: true
    meter_black?: true
    meter_colour?: true
    meter_total?: true
    drum_life_c?: true
    drum_life_m?: true
    drum_life_y?: true
    drum_life_k?: true
  }

  export type TechnicalSpecificationMinAggregateInputType = {
    id?: true
    asset_id?: true
    cassettes?: true
    internal_finisher?: true
    meter_black?: true
    meter_colour?: true
    meter_total?: true
    drum_life_c?: true
    drum_life_m?: true
    drum_life_y?: true
    drum_life_k?: true
  }

  export type TechnicalSpecificationMaxAggregateInputType = {
    id?: true
    asset_id?: true
    cassettes?: true
    internal_finisher?: true
    meter_black?: true
    meter_colour?: true
    meter_total?: true
    drum_life_c?: true
    drum_life_m?: true
    drum_life_y?: true
    drum_life_k?: true
  }

  export type TechnicalSpecificationCountAggregateInputType = {
    id?: true
    asset_id?: true
    cassettes?: true
    internal_finisher?: true
    meter_black?: true
    meter_colour?: true
    meter_total?: true
    drum_life_c?: true
    drum_life_m?: true
    drum_life_y?: true
    drum_life_k?: true
    _all?: true
  }

  export type TechnicalSpecificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecification to aggregate.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicalSpecifications
    **/
    _count?: true | TechnicalSpecificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicalSpecificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicalSpecificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicalSpecificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicalSpecificationMaxAggregateInputType
  }

  export type GetTechnicalSpecificationAggregateType<T extends TechnicalSpecificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicalSpecification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicalSpecification[P]>
      : GetScalarType<T[P], AggregateTechnicalSpecification[P]>
  }




  export type TechnicalSpecificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationWhereInput
    orderBy?: TechnicalSpecificationOrderByWithAggregationInput | TechnicalSpecificationOrderByWithAggregationInput[]
    by: TechnicalSpecificationScalarFieldEnum[] | TechnicalSpecificationScalarFieldEnum
    having?: TechnicalSpecificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicalSpecificationCountAggregateInputType | true
    _avg?: TechnicalSpecificationAvgAggregateInputType
    _sum?: TechnicalSpecificationSumAggregateInputType
    _min?: TechnicalSpecificationMinAggregateInputType
    _max?: TechnicalSpecificationMaxAggregateInputType
  }

  export type TechnicalSpecificationGroupByOutputType = {
    id: number
    asset_id: number
    cassettes: number | null
    internal_finisher: string | null
    meter_black: number | null
    meter_colour: number | null
    meter_total: number | null
    drum_life_c: number | null
    drum_life_m: number | null
    drum_life_y: number | null
    drum_life_k: number | null
    _count: TechnicalSpecificationCountAggregateOutputType | null
    _avg: TechnicalSpecificationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationSumAggregateOutputType | null
    _min: TechnicalSpecificationMinAggregateOutputType | null
    _max: TechnicalSpecificationMaxAggregateOutputType | null
  }

  type GetTechnicalSpecificationGroupByPayload<T extends TechnicalSpecificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicalSpecificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicalSpecificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicalSpecificationGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicalSpecificationGroupByOutputType[P]>
        }
      >
    >


  export type TechnicalSpecificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    cassettes?: boolean
    internal_finisher?: boolean
    meter_black?: boolean
    meter_colour?: boolean
    meter_total?: boolean
    drum_life_c?: boolean
    drum_life_m?: boolean
    drum_life_y?: boolean
    drum_life_k?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    cassettes?: boolean
    internal_finisher?: boolean
    meter_black?: boolean
    meter_colour?: boolean
    meter_total?: boolean
    drum_life_c?: boolean
    drum_life_m?: boolean
    drum_life_y?: boolean
    drum_life_k?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    cassettes?: boolean
    internal_finisher?: boolean
    meter_black?: boolean
    meter_colour?: boolean
    meter_total?: boolean
    drum_life_c?: boolean
    drum_life_m?: boolean
    drum_life_y?: boolean
    drum_life_k?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectScalar = {
    id?: boolean
    asset_id?: boolean
    cassettes?: boolean
    internal_finisher?: boolean
    meter_black?: boolean
    meter_colour?: boolean
    meter_total?: boolean
    drum_life_c?: boolean
    drum_life_m?: boolean
    drum_life_y?: boolean
    drum_life_k?: boolean
  }

  export type TechnicalSpecificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset_id" | "cassettes" | "internal_finisher" | "meter_black" | "meter_colour" | "meter_total" | "drum_life_c" | "drum_life_m" | "drum_life_y" | "drum_life_k", ExtArgs["result"]["technicalSpecification"]>
  export type TechnicalSpecificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $TechnicalSpecificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicalSpecification"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset_id: number
      cassettes: number | null
      internal_finisher: string | null
      meter_black: number | null
      meter_colour: number | null
      meter_total: number | null
      drum_life_c: number | null
      drum_life_m: number | null
      drum_life_y: number | null
      drum_life_k: number | null
    }, ExtArgs["result"]["technicalSpecification"]>
    composites: {}
  }

  type TechnicalSpecificationGetPayload<S extends boolean | null | undefined | TechnicalSpecificationDefaultArgs> = $Result.GetResult<Prisma.$TechnicalSpecificationPayload, S>

  type TechnicalSpecificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicalSpecificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicalSpecificationCountAggregateInputType | true
    }

  export interface TechnicalSpecificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicalSpecification'], meta: { name: 'TechnicalSpecification' } }
    /**
     * Find zero or one TechnicalSpecification that matches the filter.
     * @param {TechnicalSpecificationFindUniqueArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicalSpecificationFindUniqueArgs>(args: SelectSubset<T, TechnicalSpecificationFindUniqueArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicalSpecification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicalSpecificationFindUniqueOrThrowArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicalSpecificationFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindFirstArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicalSpecificationFindFirstArgs>(args?: SelectSubset<T, TechnicalSpecificationFindFirstArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindFirstOrThrowArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicalSpecificationFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicalSpecifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicalSpecifications
     * const technicalSpecifications = await prisma.technicalSpecification.findMany()
     * 
     * // Get first 10 TechnicalSpecifications
     * const technicalSpecifications = await prisma.technicalSpecification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicalSpecificationFindManyArgs>(args?: SelectSubset<T, TechnicalSpecificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicalSpecification.
     * @param {TechnicalSpecificationCreateArgs} args - Arguments to create a TechnicalSpecification.
     * @example
     * // Create one TechnicalSpecification
     * const TechnicalSpecification = await prisma.technicalSpecification.create({
     *   data: {
     *     // ... data to create a TechnicalSpecification
     *   }
     * })
     * 
     */
    create<T extends TechnicalSpecificationCreateArgs>(args: SelectSubset<T, TechnicalSpecificationCreateArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicalSpecifications.
     * @param {TechnicalSpecificationCreateManyArgs} args - Arguments to create many TechnicalSpecifications.
     * @example
     * // Create many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicalSpecificationCreateManyArgs>(args?: SelectSubset<T, TechnicalSpecificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicalSpecifications and returns the data saved in the database.
     * @param {TechnicalSpecificationCreateManyAndReturnArgs} args - Arguments to create many TechnicalSpecifications.
     * @example
     * // Create many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicalSpecifications and only return the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicalSpecificationCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicalSpecification.
     * @param {TechnicalSpecificationDeleteArgs} args - Arguments to delete one TechnicalSpecification.
     * @example
     * // Delete one TechnicalSpecification
     * const TechnicalSpecification = await prisma.technicalSpecification.delete({
     *   where: {
     *     // ... filter to delete one TechnicalSpecification
     *   }
     * })
     * 
     */
    delete<T extends TechnicalSpecificationDeleteArgs>(args: SelectSubset<T, TechnicalSpecificationDeleteArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicalSpecification.
     * @param {TechnicalSpecificationUpdateArgs} args - Arguments to update one TechnicalSpecification.
     * @example
     * // Update one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicalSpecificationUpdateArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicalSpecifications.
     * @param {TechnicalSpecificationDeleteManyArgs} args - Arguments to filter TechnicalSpecifications to delete.
     * @example
     * // Delete a few TechnicalSpecifications
     * const { count } = await prisma.technicalSpecification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicalSpecificationDeleteManyArgs>(args?: SelectSubset<T, TechnicalSpecificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicalSpecificationUpdateManyArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecifications and returns the data updated in the database.
     * @param {TechnicalSpecificationUpdateManyAndReturnArgs} args - Arguments to update many TechnicalSpecifications.
     * @example
     * // Update many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicalSpecifications and only return the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicalSpecificationUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicalSpecification.
     * @param {TechnicalSpecificationUpsertArgs} args - Arguments to update or create a TechnicalSpecification.
     * @example
     * // Update or create a TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.upsert({
     *   create: {
     *     // ... data to create a TechnicalSpecification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicalSpecification we want to update
     *   }
     * })
     */
    upsert<T extends TechnicalSpecificationUpsertArgs>(args: SelectSubset<T, TechnicalSpecificationUpsertArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicalSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationCountArgs} args - Arguments to filter TechnicalSpecifications to count.
     * @example
     * // Count the number of TechnicalSpecifications
     * const count = await prisma.technicalSpecification.count({
     *   where: {
     *     // ... the filter for the TechnicalSpecifications we want to count
     *   }
     * })
    **/
    count<T extends TechnicalSpecificationCountArgs>(
      args?: Subset<T, TechnicalSpecificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicalSpecificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicalSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicalSpecificationAggregateArgs>(args: Subset<T, TechnicalSpecificationAggregateArgs>): Prisma.PrismaPromise<GetTechnicalSpecificationAggregateType<T>>

    /**
     * Group by TechnicalSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicalSpecificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicalSpecificationGroupByArgs['orderBy'] }
        : { orderBy?: TechnicalSpecificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicalSpecificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicalSpecificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicalSpecification model
   */
  readonly fields: TechnicalSpecificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicalSpecification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicalSpecificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicalSpecification model
   */
  interface TechnicalSpecificationFieldRefs {
    readonly id: FieldRef<"TechnicalSpecification", 'Int'>
    readonly asset_id: FieldRef<"TechnicalSpecification", 'Int'>
    readonly cassettes: FieldRef<"TechnicalSpecification", 'Int'>
    readonly internal_finisher: FieldRef<"TechnicalSpecification", 'String'>
    readonly meter_black: FieldRef<"TechnicalSpecification", 'Int'>
    readonly meter_colour: FieldRef<"TechnicalSpecification", 'Int'>
    readonly meter_total: FieldRef<"TechnicalSpecification", 'Int'>
    readonly drum_life_c: FieldRef<"TechnicalSpecification", 'Int'>
    readonly drum_life_m: FieldRef<"TechnicalSpecification", 'Int'>
    readonly drum_life_y: FieldRef<"TechnicalSpecification", 'Int'>
    readonly drum_life_k: FieldRef<"TechnicalSpecification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TechnicalSpecification findUnique
   */
  export type TechnicalSpecificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification findUniqueOrThrow
   */
  export type TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification findFirst
   */
  export type TechnicalSpecificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecifications.
     */
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification findFirstOrThrow
   */
  export type TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecifications.
     */
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification findMany
   */
  export type TechnicalSpecificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecifications to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification create
   */
  export type TechnicalSpecificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicalSpecification.
     */
    data: XOR<TechnicalSpecificationCreateInput, TechnicalSpecificationUncheckedCreateInput>
  }

  /**
   * TechnicalSpecification createMany
   */
  export type TechnicalSpecificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicalSpecifications.
     */
    data: TechnicalSpecificationCreateManyInput | TechnicalSpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicalSpecification createManyAndReturn
   */
  export type TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicalSpecifications.
     */
    data: TechnicalSpecificationCreateManyInput | TechnicalSpecificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecification update
   */
  export type TechnicalSpecificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicalSpecification.
     */
    data: XOR<TechnicalSpecificationUpdateInput, TechnicalSpecificationUncheckedUpdateInput>
    /**
     * Choose, which TechnicalSpecification to update.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification updateMany
   */
  export type TechnicalSpecificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicalSpecifications.
     */
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecifications to update
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to update.
     */
    limit?: number
  }

  /**
   * TechnicalSpecification updateManyAndReturn
   */
  export type TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * The data used to update TechnicalSpecifications.
     */
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecifications to update
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecification upsert
   */
  export type TechnicalSpecificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicalSpecification to update in case it exists.
     */
    where: TechnicalSpecificationWhereUniqueInput
    /**
     * In case the TechnicalSpecification found by the `where` argument doesn't exist, create a new TechnicalSpecification with this data.
     */
    create: XOR<TechnicalSpecificationCreateInput, TechnicalSpecificationUncheckedCreateInput>
    /**
     * In case the TechnicalSpecification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicalSpecificationUpdateInput, TechnicalSpecificationUncheckedUpdateInput>
  }

  /**
   * TechnicalSpecification delete
   */
  export type TechnicalSpecificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter which TechnicalSpecification to delete.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification deleteMany
   */
  export type TechnicalSpecificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecifications to delete
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to delete.
     */
    limit?: number
  }

  /**
   * TechnicalSpecification without action
   */
  export type TechnicalSpecificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
  }


  /**
   * Model Cost
   */

  export type AggregateCost = {
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  export type CostAvgAggregateOutputType = {
    id: number | null
    asset_id: number | null
    purchase_cost: Decimal | null
    transport_cost: Decimal | null
    processing_cost: Decimal | null
    other_cost: Decimal | null
    parts_cost: Decimal | null
    total_cost: Decimal | null
    sale_price: Decimal | null
  }

  export type CostSumAggregateOutputType = {
    id: number | null
    asset_id: number | null
    purchase_cost: Decimal | null
    transport_cost: Decimal | null
    processing_cost: Decimal | null
    other_cost: Decimal | null
    parts_cost: Decimal | null
    total_cost: Decimal | null
    sale_price: Decimal | null
  }

  export type CostMinAggregateOutputType = {
    id: number | null
    asset_id: number | null
    purchase_cost: Decimal | null
    transport_cost: Decimal | null
    processing_cost: Decimal | null
    other_cost: Decimal | null
    parts_cost: Decimal | null
    total_cost: Decimal | null
    sale_price: Decimal | null
  }

  export type CostMaxAggregateOutputType = {
    id: number | null
    asset_id: number | null
    purchase_cost: Decimal | null
    transport_cost: Decimal | null
    processing_cost: Decimal | null
    other_cost: Decimal | null
    parts_cost: Decimal | null
    total_cost: Decimal | null
    sale_price: Decimal | null
  }

  export type CostCountAggregateOutputType = {
    id: number
    asset_id: number
    purchase_cost: number
    transport_cost: number
    processing_cost: number
    other_cost: number
    parts_cost: number
    total_cost: number
    sale_price: number
    _all: number
  }


  export type CostAvgAggregateInputType = {
    id?: true
    asset_id?: true
    purchase_cost?: true
    transport_cost?: true
    processing_cost?: true
    other_cost?: true
    parts_cost?: true
    total_cost?: true
    sale_price?: true
  }

  export type CostSumAggregateInputType = {
    id?: true
    asset_id?: true
    purchase_cost?: true
    transport_cost?: true
    processing_cost?: true
    other_cost?: true
    parts_cost?: true
    total_cost?: true
    sale_price?: true
  }

  export type CostMinAggregateInputType = {
    id?: true
    asset_id?: true
    purchase_cost?: true
    transport_cost?: true
    processing_cost?: true
    other_cost?: true
    parts_cost?: true
    total_cost?: true
    sale_price?: true
  }

  export type CostMaxAggregateInputType = {
    id?: true
    asset_id?: true
    purchase_cost?: true
    transport_cost?: true
    processing_cost?: true
    other_cost?: true
    parts_cost?: true
    total_cost?: true
    sale_price?: true
  }

  export type CostCountAggregateInputType = {
    id?: true
    asset_id?: true
    purchase_cost?: true
    transport_cost?: true
    processing_cost?: true
    other_cost?: true
    parts_cost?: true
    total_cost?: true
    sale_price?: true
    _all?: true
  }

  export type CostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cost to aggregate.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Costs
    **/
    _count?: true | CostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostMaxAggregateInputType
  }

  export type GetCostAggregateType<T extends CostAggregateArgs> = {
        [P in keyof T & keyof AggregateCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCost[P]>
      : GetScalarType<T[P], AggregateCost[P]>
  }




  export type CostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
    orderBy?: CostOrderByWithAggregationInput | CostOrderByWithAggregationInput[]
    by: CostScalarFieldEnum[] | CostScalarFieldEnum
    having?: CostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCountAggregateInputType | true
    _avg?: CostAvgAggregateInputType
    _sum?: CostSumAggregateInputType
    _min?: CostMinAggregateInputType
    _max?: CostMaxAggregateInputType
  }

  export type CostGroupByOutputType = {
    id: number
    asset_id: number
    purchase_cost: Decimal | null
    transport_cost: Decimal | null
    processing_cost: Decimal | null
    other_cost: Decimal | null
    parts_cost: Decimal | null
    total_cost: Decimal | null
    sale_price: Decimal | null
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  type GetCostGroupByPayload<T extends CostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostGroupByOutputType[P]>
            : GetScalarType<T[P], CostGroupByOutputType[P]>
        }
      >
    >


  export type CostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    purchase_cost?: boolean
    transport_cost?: boolean
    processing_cost?: boolean
    other_cost?: boolean
    parts_cost?: boolean
    total_cost?: boolean
    sale_price?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    purchase_cost?: boolean
    transport_cost?: boolean
    processing_cost?: boolean
    other_cost?: boolean
    parts_cost?: boolean
    total_cost?: boolean
    sale_price?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    purchase_cost?: boolean
    transport_cost?: boolean
    processing_cost?: boolean
    other_cost?: boolean
    parts_cost?: boolean
    total_cost?: boolean
    sale_price?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectScalar = {
    id?: boolean
    asset_id?: boolean
    purchase_cost?: boolean
    transport_cost?: boolean
    processing_cost?: boolean
    other_cost?: boolean
    parts_cost?: boolean
    total_cost?: boolean
    sale_price?: boolean
  }

  export type CostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset_id" | "purchase_cost" | "transport_cost" | "processing_cost" | "other_cost" | "parts_cost" | "total_cost" | "sale_price", ExtArgs["result"]["cost"]>
  export type CostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type CostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type CostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $CostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cost"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset_id: number
      purchase_cost: Prisma.Decimal | null
      transport_cost: Prisma.Decimal | null
      processing_cost: Prisma.Decimal | null
      other_cost: Prisma.Decimal | null
      parts_cost: Prisma.Decimal | null
      total_cost: Prisma.Decimal | null
      sale_price: Prisma.Decimal | null
    }, ExtArgs["result"]["cost"]>
    composites: {}
  }

  type CostGetPayload<S extends boolean | null | undefined | CostDefaultArgs> = $Result.GetResult<Prisma.$CostPayload, S>

  type CostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostCountAggregateInputType | true
    }

  export interface CostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cost'], meta: { name: 'Cost' } }
    /**
     * Find zero or one Cost that matches the filter.
     * @param {CostFindUniqueArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostFindUniqueArgs>(args: SelectSubset<T, CostFindUniqueArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostFindUniqueOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostFindUniqueOrThrowArgs>(args: SelectSubset<T, CostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostFindFirstArgs>(args?: SelectSubset<T, CostFindFirstArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostFindFirstOrThrowArgs>(args?: SelectSubset<T, CostFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Costs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costs
     * const costs = await prisma.cost.findMany()
     * 
     * // Get first 10 Costs
     * const costs = await prisma.cost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costWithIdOnly = await prisma.cost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostFindManyArgs>(args?: SelectSubset<T, CostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cost.
     * @param {CostCreateArgs} args - Arguments to create a Cost.
     * @example
     * // Create one Cost
     * const Cost = await prisma.cost.create({
     *   data: {
     *     // ... data to create a Cost
     *   }
     * })
     * 
     */
    create<T extends CostCreateArgs>(args: SelectSubset<T, CostCreateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Costs.
     * @param {CostCreateManyArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCreateManyArgs>(args?: SelectSubset<T, CostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Costs and returns the data saved in the database.
     * @param {CostCreateManyAndReturnArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cost.
     * @param {CostDeleteArgs} args - Arguments to delete one Cost.
     * @example
     * // Delete one Cost
     * const Cost = await prisma.cost.delete({
     *   where: {
     *     // ... filter to delete one Cost
     *   }
     * })
     * 
     */
    delete<T extends CostDeleteArgs>(args: SelectSubset<T, CostDeleteArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cost.
     * @param {CostUpdateArgs} args - Arguments to update one Cost.
     * @example
     * // Update one Cost
     * const cost = await prisma.cost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostUpdateArgs>(args: SelectSubset<T, CostUpdateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Costs.
     * @param {CostDeleteManyArgs} args - Arguments to filter Costs to delete.
     * @example
     * // Delete a few Costs
     * const { count } = await prisma.cost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostDeleteManyArgs>(args?: SelectSubset<T, CostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostUpdateManyArgs>(args: SelectSubset<T, CostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs and returns the data updated in the database.
     * @param {CostUpdateManyAndReturnArgs} args - Arguments to update many Costs.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostUpdateManyAndReturnArgs>(args: SelectSubset<T, CostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cost.
     * @param {CostUpsertArgs} args - Arguments to update or create a Cost.
     * @example
     * // Update or create a Cost
     * const cost = await prisma.cost.upsert({
     *   create: {
     *     // ... data to create a Cost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cost we want to update
     *   }
     * })
     */
    upsert<T extends CostUpsertArgs>(args: SelectSubset<T, CostUpsertArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCountArgs} args - Arguments to filter Costs to count.
     * @example
     * // Count the number of Costs
     * const count = await prisma.cost.count({
     *   where: {
     *     // ... the filter for the Costs we want to count
     *   }
     * })
    **/
    count<T extends CostCountArgs>(
      args?: Subset<T, CostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostAggregateArgs>(args: Subset<T, CostAggregateArgs>): Prisma.PrismaPromise<GetCostAggregateType<T>>

    /**
     * Group by Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostGroupByArgs['orderBy'] }
        : { orderBy?: CostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cost model
   */
  readonly fields: CostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cost model
   */
  interface CostFieldRefs {
    readonly id: FieldRef<"Cost", 'Int'>
    readonly asset_id: FieldRef<"Cost", 'Int'>
    readonly purchase_cost: FieldRef<"Cost", 'Decimal'>
    readonly transport_cost: FieldRef<"Cost", 'Decimal'>
    readonly processing_cost: FieldRef<"Cost", 'Decimal'>
    readonly other_cost: FieldRef<"Cost", 'Decimal'>
    readonly parts_cost: FieldRef<"Cost", 'Decimal'>
    readonly total_cost: FieldRef<"Cost", 'Decimal'>
    readonly sale_price: FieldRef<"Cost", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Cost findUnique
   */
  export type CostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findUniqueOrThrow
   */
  export type CostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findFirst
   */
  export type CostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findFirstOrThrow
   */
  export type CostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findMany
   */
  export type CostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Costs to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost create
   */
  export type CostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to create a Cost.
     */
    data: XOR<CostCreateInput, CostUncheckedCreateInput>
  }

  /**
   * Cost createMany
   */
  export type CostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cost createManyAndReturn
   */
  export type CostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost update
   */
  export type CostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to update a Cost.
     */
    data: XOR<CostUpdateInput, CostUncheckedUpdateInput>
    /**
     * Choose, which Cost to update.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost updateMany
   */
  export type CostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to update.
     */
    limit?: number
  }

  /**
   * Cost updateManyAndReturn
   */
  export type CostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost upsert
   */
  export type CostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The filter to search for the Cost to update in case it exists.
     */
    where: CostWhereUniqueInput
    /**
     * In case the Cost found by the `where` argument doesn't exist, create a new Cost with this data.
     */
    create: XOR<CostCreateInput, CostUncheckedCreateInput>
    /**
     * In case the Cost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostUpdateInput, CostUncheckedUpdateInput>
  }

  /**
   * Cost delete
   */
  export type CostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter which Cost to delete.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost deleteMany
   */
  export type CostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Costs to delete
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to delete.
     */
    limit?: number
  }

  /**
   * Cost without action
   */
  export type CostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
  }


  /**
   * Model AssetAccessory
   */

  export type AggregateAssetAccessory = {
    _count: AssetAccessoryCountAggregateOutputType | null
    _avg: AssetAccessoryAvgAggregateOutputType | null
    _sum: AssetAccessorySumAggregateOutputType | null
    _min: AssetAccessoryMinAggregateOutputType | null
    _max: AssetAccessoryMaxAggregateOutputType | null
  }

  export type AssetAccessoryAvgAggregateOutputType = {
    asset_id: number | null
  }

  export type AssetAccessorySumAggregateOutputType = {
    asset_id: number | null
  }

  export type AssetAccessoryMinAggregateOutputType = {
    asset_id: number | null
    accessory: $Enums.Accessory | null
  }

  export type AssetAccessoryMaxAggregateOutputType = {
    asset_id: number | null
    accessory: $Enums.Accessory | null
  }

  export type AssetAccessoryCountAggregateOutputType = {
    asset_id: number
    accessory: number
    _all: number
  }


  export type AssetAccessoryAvgAggregateInputType = {
    asset_id?: true
  }

  export type AssetAccessorySumAggregateInputType = {
    asset_id?: true
  }

  export type AssetAccessoryMinAggregateInputType = {
    asset_id?: true
    accessory?: true
  }

  export type AssetAccessoryMaxAggregateInputType = {
    asset_id?: true
    accessory?: true
  }

  export type AssetAccessoryCountAggregateInputType = {
    asset_id?: true
    accessory?: true
    _all?: true
  }

  export type AssetAccessoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAccessory to aggregate.
     */
    where?: AssetAccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAccessories to fetch.
     */
    orderBy?: AssetAccessoryOrderByWithRelationInput | AssetAccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetAccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAccessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAccessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetAccessories
    **/
    _count?: true | AssetAccessoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAccessoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetAccessorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetAccessoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetAccessoryMaxAggregateInputType
  }

  export type GetAssetAccessoryAggregateType<T extends AssetAccessoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetAccessory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetAccessory[P]>
      : GetScalarType<T[P], AggregateAssetAccessory[P]>
  }




  export type AssetAccessoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAccessoryWhereInput
    orderBy?: AssetAccessoryOrderByWithAggregationInput | AssetAccessoryOrderByWithAggregationInput[]
    by: AssetAccessoryScalarFieldEnum[] | AssetAccessoryScalarFieldEnum
    having?: AssetAccessoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetAccessoryCountAggregateInputType | true
    _avg?: AssetAccessoryAvgAggregateInputType
    _sum?: AssetAccessorySumAggregateInputType
    _min?: AssetAccessoryMinAggregateInputType
    _max?: AssetAccessoryMaxAggregateInputType
  }

  export type AssetAccessoryGroupByOutputType = {
    asset_id: number
    accessory: $Enums.Accessory
    _count: AssetAccessoryCountAggregateOutputType | null
    _avg: AssetAccessoryAvgAggregateOutputType | null
    _sum: AssetAccessorySumAggregateOutputType | null
    _min: AssetAccessoryMinAggregateOutputType | null
    _max: AssetAccessoryMaxAggregateOutputType | null
  }

  type GetAssetAccessoryGroupByPayload<T extends AssetAccessoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetAccessoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetAccessoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetAccessoryGroupByOutputType[P]>
            : GetScalarType<T[P], AssetAccessoryGroupByOutputType[P]>
        }
      >
    >


  export type AssetAccessorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    accessory?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAccessory"]>

  export type AssetAccessorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    accessory?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAccessory"]>

  export type AssetAccessorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    accessory?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAccessory"]>

  export type AssetAccessorySelectScalar = {
    asset_id?: boolean
    accessory?: boolean
  }

  export type AssetAccessoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"asset_id" | "accessory", ExtArgs["result"]["assetAccessory"]>
  export type AssetAccessoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type AssetAccessoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type AssetAccessoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $AssetAccessoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetAccessory"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      asset_id: number
      accessory: $Enums.Accessory
    }, ExtArgs["result"]["assetAccessory"]>
    composites: {}
  }

  type AssetAccessoryGetPayload<S extends boolean | null | undefined | AssetAccessoryDefaultArgs> = $Result.GetResult<Prisma.$AssetAccessoryPayload, S>

  type AssetAccessoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetAccessoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetAccessoryCountAggregateInputType | true
    }

  export interface AssetAccessoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetAccessory'], meta: { name: 'AssetAccessory' } }
    /**
     * Find zero or one AssetAccessory that matches the filter.
     * @param {AssetAccessoryFindUniqueArgs} args - Arguments to find a AssetAccessory
     * @example
     * // Get one AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetAccessoryFindUniqueArgs>(args: SelectSubset<T, AssetAccessoryFindUniqueArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetAccessory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetAccessoryFindUniqueOrThrowArgs} args - Arguments to find a AssetAccessory
     * @example
     * // Get one AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetAccessoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetAccessoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetAccessory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryFindFirstArgs} args - Arguments to find a AssetAccessory
     * @example
     * // Get one AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetAccessoryFindFirstArgs>(args?: SelectSubset<T, AssetAccessoryFindFirstArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetAccessory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryFindFirstOrThrowArgs} args - Arguments to find a AssetAccessory
     * @example
     * // Get one AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetAccessoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetAccessoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetAccessories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetAccessories
     * const assetAccessories = await prisma.assetAccessory.findMany()
     * 
     * // Get first 10 AssetAccessories
     * const assetAccessories = await prisma.assetAccessory.findMany({ take: 10 })
     * 
     * // Only select the `asset_id`
     * const assetAccessoryWithAsset_idOnly = await prisma.assetAccessory.findMany({ select: { asset_id: true } })
     * 
     */
    findMany<T extends AssetAccessoryFindManyArgs>(args?: SelectSubset<T, AssetAccessoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetAccessory.
     * @param {AssetAccessoryCreateArgs} args - Arguments to create a AssetAccessory.
     * @example
     * // Create one AssetAccessory
     * const AssetAccessory = await prisma.assetAccessory.create({
     *   data: {
     *     // ... data to create a AssetAccessory
     *   }
     * })
     * 
     */
    create<T extends AssetAccessoryCreateArgs>(args: SelectSubset<T, AssetAccessoryCreateArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetAccessories.
     * @param {AssetAccessoryCreateManyArgs} args - Arguments to create many AssetAccessories.
     * @example
     * // Create many AssetAccessories
     * const assetAccessory = await prisma.assetAccessory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetAccessoryCreateManyArgs>(args?: SelectSubset<T, AssetAccessoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetAccessories and returns the data saved in the database.
     * @param {AssetAccessoryCreateManyAndReturnArgs} args - Arguments to create many AssetAccessories.
     * @example
     * // Create many AssetAccessories
     * const assetAccessory = await prisma.assetAccessory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetAccessories and only return the `asset_id`
     * const assetAccessoryWithAsset_idOnly = await prisma.assetAccessory.createManyAndReturn({
     *   select: { asset_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetAccessoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetAccessoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetAccessory.
     * @param {AssetAccessoryDeleteArgs} args - Arguments to delete one AssetAccessory.
     * @example
     * // Delete one AssetAccessory
     * const AssetAccessory = await prisma.assetAccessory.delete({
     *   where: {
     *     // ... filter to delete one AssetAccessory
     *   }
     * })
     * 
     */
    delete<T extends AssetAccessoryDeleteArgs>(args: SelectSubset<T, AssetAccessoryDeleteArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetAccessory.
     * @param {AssetAccessoryUpdateArgs} args - Arguments to update one AssetAccessory.
     * @example
     * // Update one AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetAccessoryUpdateArgs>(args: SelectSubset<T, AssetAccessoryUpdateArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetAccessories.
     * @param {AssetAccessoryDeleteManyArgs} args - Arguments to filter AssetAccessories to delete.
     * @example
     * // Delete a few AssetAccessories
     * const { count } = await prisma.assetAccessory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetAccessoryDeleteManyArgs>(args?: SelectSubset<T, AssetAccessoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAccessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetAccessories
     * const assetAccessory = await prisma.assetAccessory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetAccessoryUpdateManyArgs>(args: SelectSubset<T, AssetAccessoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAccessories and returns the data updated in the database.
     * @param {AssetAccessoryUpdateManyAndReturnArgs} args - Arguments to update many AssetAccessories.
     * @example
     * // Update many AssetAccessories
     * const assetAccessory = await prisma.assetAccessory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetAccessories and only return the `asset_id`
     * const assetAccessoryWithAsset_idOnly = await prisma.assetAccessory.updateManyAndReturn({
     *   select: { asset_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetAccessoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetAccessoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetAccessory.
     * @param {AssetAccessoryUpsertArgs} args - Arguments to update or create a AssetAccessory.
     * @example
     * // Update or create a AssetAccessory
     * const assetAccessory = await prisma.assetAccessory.upsert({
     *   create: {
     *     // ... data to create a AssetAccessory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetAccessory we want to update
     *   }
     * })
     */
    upsert<T extends AssetAccessoryUpsertArgs>(args: SelectSubset<T, AssetAccessoryUpsertArgs<ExtArgs>>): Prisma__AssetAccessoryClient<$Result.GetResult<Prisma.$AssetAccessoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetAccessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryCountArgs} args - Arguments to filter AssetAccessories to count.
     * @example
     * // Count the number of AssetAccessories
     * const count = await prisma.assetAccessory.count({
     *   where: {
     *     // ... the filter for the AssetAccessories we want to count
     *   }
     * })
    **/
    count<T extends AssetAccessoryCountArgs>(
      args?: Subset<T, AssetAccessoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetAccessoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetAccessory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAccessoryAggregateArgs>(args: Subset<T, AssetAccessoryAggregateArgs>): Prisma.PrismaPromise<GetAssetAccessoryAggregateType<T>>

    /**
     * Group by AssetAccessory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAccessoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetAccessoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetAccessoryGroupByArgs['orderBy'] }
        : { orderBy?: AssetAccessoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetAccessoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetAccessoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetAccessory model
   */
  readonly fields: AssetAccessoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetAccessory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetAccessoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetAccessory model
   */
  interface AssetAccessoryFieldRefs {
    readonly asset_id: FieldRef<"AssetAccessory", 'Int'>
    readonly accessory: FieldRef<"AssetAccessory", 'Accessory'>
  }
    

  // Custom InputTypes
  /**
   * AssetAccessory findUnique
   */
  export type AssetAccessoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetAccessory to fetch.
     */
    where: AssetAccessoryWhereUniqueInput
  }

  /**
   * AssetAccessory findUniqueOrThrow
   */
  export type AssetAccessoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetAccessory to fetch.
     */
    where: AssetAccessoryWhereUniqueInput
  }

  /**
   * AssetAccessory findFirst
   */
  export type AssetAccessoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetAccessory to fetch.
     */
    where?: AssetAccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAccessories to fetch.
     */
    orderBy?: AssetAccessoryOrderByWithRelationInput | AssetAccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAccessories.
     */
    cursor?: AssetAccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAccessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAccessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAccessories.
     */
    distinct?: AssetAccessoryScalarFieldEnum | AssetAccessoryScalarFieldEnum[]
  }

  /**
   * AssetAccessory findFirstOrThrow
   */
  export type AssetAccessoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetAccessory to fetch.
     */
    where?: AssetAccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAccessories to fetch.
     */
    orderBy?: AssetAccessoryOrderByWithRelationInput | AssetAccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAccessories.
     */
    cursor?: AssetAccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAccessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAccessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAccessories.
     */
    distinct?: AssetAccessoryScalarFieldEnum | AssetAccessoryScalarFieldEnum[]
  }

  /**
   * AssetAccessory findMany
   */
  export type AssetAccessoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetAccessories to fetch.
     */
    where?: AssetAccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAccessories to fetch.
     */
    orderBy?: AssetAccessoryOrderByWithRelationInput | AssetAccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetAccessories.
     */
    cursor?: AssetAccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAccessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAccessories.
     */
    skip?: number
    distinct?: AssetAccessoryScalarFieldEnum | AssetAccessoryScalarFieldEnum[]
  }

  /**
   * AssetAccessory create
   */
  export type AssetAccessoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetAccessory.
     */
    data: XOR<AssetAccessoryCreateInput, AssetAccessoryUncheckedCreateInput>
  }

  /**
   * AssetAccessory createMany
   */
  export type AssetAccessoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetAccessories.
     */
    data: AssetAccessoryCreateManyInput | AssetAccessoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAccessory createManyAndReturn
   */
  export type AssetAccessoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * The data used to create many AssetAccessories.
     */
    data: AssetAccessoryCreateManyInput | AssetAccessoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetAccessory update
   */
  export type AssetAccessoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetAccessory.
     */
    data: XOR<AssetAccessoryUpdateInput, AssetAccessoryUncheckedUpdateInput>
    /**
     * Choose, which AssetAccessory to update.
     */
    where: AssetAccessoryWhereUniqueInput
  }

  /**
   * AssetAccessory updateMany
   */
  export type AssetAccessoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetAccessories.
     */
    data: XOR<AssetAccessoryUpdateManyMutationInput, AssetAccessoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetAccessories to update
     */
    where?: AssetAccessoryWhereInput
    /**
     * Limit how many AssetAccessories to update.
     */
    limit?: number
  }

  /**
   * AssetAccessory updateManyAndReturn
   */
  export type AssetAccessoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * The data used to update AssetAccessories.
     */
    data: XOR<AssetAccessoryUpdateManyMutationInput, AssetAccessoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetAccessories to update
     */
    where?: AssetAccessoryWhereInput
    /**
     * Limit how many AssetAccessories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetAccessory upsert
   */
  export type AssetAccessoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetAccessory to update in case it exists.
     */
    where: AssetAccessoryWhereUniqueInput
    /**
     * In case the AssetAccessory found by the `where` argument doesn't exist, create a new AssetAccessory with this data.
     */
    create: XOR<AssetAccessoryCreateInput, AssetAccessoryUncheckedCreateInput>
    /**
     * In case the AssetAccessory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetAccessoryUpdateInput, AssetAccessoryUncheckedUpdateInput>
  }

  /**
   * AssetAccessory delete
   */
  export type AssetAccessoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
    /**
     * Filter which AssetAccessory to delete.
     */
    where: AssetAccessoryWhereUniqueInput
  }

  /**
   * AssetAccessory deleteMany
   */
  export type AssetAccessoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAccessories to delete
     */
    where?: AssetAccessoryWhereInput
    /**
     * Limit how many AssetAccessories to delete.
     */
    limit?: number
  }

  /**
   * AssetAccessory without action
   */
  export type AssetAccessoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAccessory
     */
    select?: AssetAccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAccessory
     */
    omit?: AssetAccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAccessoryInclude<ExtArgs> | null
  }


  /**
   * Model ErrorCategory
   */

  export type AggregateErrorCategory = {
    _count: ErrorCategoryCountAggregateOutputType | null
    _avg: ErrorCategoryAvgAggregateOutputType | null
    _sum: ErrorCategorySumAggregateOutputType | null
    _min: ErrorCategoryMinAggregateOutputType | null
    _max: ErrorCategoryMaxAggregateOutputType | null
  }

  export type ErrorCategoryAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ErrorCategorySumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ErrorCategoryMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    category: string | null
  }

  export type ErrorCategoryMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    category: string | null
  }

  export type ErrorCategoryCountAggregateOutputType = {
    id: number
    brand_id: number
    category: number
    _all: number
  }


  export type ErrorCategoryAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ErrorCategorySumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ErrorCategoryMinAggregateInputType = {
    id?: true
    brand_id?: true
    category?: true
  }

  export type ErrorCategoryMaxAggregateInputType = {
    id?: true
    brand_id?: true
    category?: true
  }

  export type ErrorCategoryCountAggregateInputType = {
    id?: true
    brand_id?: true
    category?: true
    _all?: true
  }

  export type ErrorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorCategory to aggregate.
     */
    where?: ErrorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorCategories to fetch.
     */
    orderBy?: ErrorCategoryOrderByWithRelationInput | ErrorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ErrorCategories
    **/
    _count?: true | ErrorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ErrorCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ErrorCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorCategoryMaxAggregateInputType
  }

  export type GetErrorCategoryAggregateType<T extends ErrorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateErrorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErrorCategory[P]>
      : GetScalarType<T[P], AggregateErrorCategory[P]>
  }




  export type ErrorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorCategoryWhereInput
    orderBy?: ErrorCategoryOrderByWithAggregationInput | ErrorCategoryOrderByWithAggregationInput[]
    by: ErrorCategoryScalarFieldEnum[] | ErrorCategoryScalarFieldEnum
    having?: ErrorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorCategoryCountAggregateInputType | true
    _avg?: ErrorCategoryAvgAggregateInputType
    _sum?: ErrorCategorySumAggregateInputType
    _min?: ErrorCategoryMinAggregateInputType
    _max?: ErrorCategoryMaxAggregateInputType
  }

  export type ErrorCategoryGroupByOutputType = {
    id: number
    brand_id: number
    category: string
    _count: ErrorCategoryCountAggregateOutputType | null
    _avg: ErrorCategoryAvgAggregateOutputType | null
    _sum: ErrorCategorySumAggregateOutputType | null
    _min: ErrorCategoryMinAggregateOutputType | null
    _max: ErrorCategoryMaxAggregateOutputType | null
  }

  type GetErrorCategoryGroupByPayload<T extends ErrorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ErrorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    category?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    errors?: boolean | ErrorCategory$errorsArgs<ExtArgs>
    _count?: boolean | ErrorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["errorCategory"]>

  export type ErrorCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    category?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["errorCategory"]>

  export type ErrorCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    category?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["errorCategory"]>

  export type ErrorCategorySelectScalar = {
    id?: boolean
    brand_id?: boolean
    category?: boolean
  }

  export type ErrorCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "category", ExtArgs["result"]["errorCategory"]>
  export type ErrorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    errors?: boolean | ErrorCategory$errorsArgs<ExtArgs>
    _count?: boolean | ErrorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ErrorCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type ErrorCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ErrorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ErrorCategory"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      errors: Prisma.$ErrorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      category: string
    }, ExtArgs["result"]["errorCategory"]>
    composites: {}
  }

  type ErrorCategoryGetPayload<S extends boolean | null | undefined | ErrorCategoryDefaultArgs> = $Result.GetResult<Prisma.$ErrorCategoryPayload, S>

  type ErrorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ErrorCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ErrorCategoryCountAggregateInputType | true
    }

  export interface ErrorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ErrorCategory'], meta: { name: 'ErrorCategory' } }
    /**
     * Find zero or one ErrorCategory that matches the filter.
     * @param {ErrorCategoryFindUniqueArgs} args - Arguments to find a ErrorCategory
     * @example
     * // Get one ErrorCategory
     * const errorCategory = await prisma.errorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorCategoryFindUniqueArgs>(args: SelectSubset<T, ErrorCategoryFindUniqueArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ErrorCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ErrorCategoryFindUniqueOrThrowArgs} args - Arguments to find a ErrorCategory
     * @example
     * // Get one ErrorCategory
     * const errorCategory = await prisma.errorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ErrorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryFindFirstArgs} args - Arguments to find a ErrorCategory
     * @example
     * // Get one ErrorCategory
     * const errorCategory = await prisma.errorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorCategoryFindFirstArgs>(args?: SelectSubset<T, ErrorCategoryFindFirstArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ErrorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryFindFirstOrThrowArgs} args - Arguments to find a ErrorCategory
     * @example
     * // Get one ErrorCategory
     * const errorCategory = await prisma.errorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ErrorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ErrorCategories
     * const errorCategories = await prisma.errorCategory.findMany()
     * 
     * // Get first 10 ErrorCategories
     * const errorCategories = await prisma.errorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const errorCategoryWithIdOnly = await prisma.errorCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ErrorCategoryFindManyArgs>(args?: SelectSubset<T, ErrorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ErrorCategory.
     * @param {ErrorCategoryCreateArgs} args - Arguments to create a ErrorCategory.
     * @example
     * // Create one ErrorCategory
     * const ErrorCategory = await prisma.errorCategory.create({
     *   data: {
     *     // ... data to create a ErrorCategory
     *   }
     * })
     * 
     */
    create<T extends ErrorCategoryCreateArgs>(args: SelectSubset<T, ErrorCategoryCreateArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ErrorCategories.
     * @param {ErrorCategoryCreateManyArgs} args - Arguments to create many ErrorCategories.
     * @example
     * // Create many ErrorCategories
     * const errorCategory = await prisma.errorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorCategoryCreateManyArgs>(args?: SelectSubset<T, ErrorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ErrorCategories and returns the data saved in the database.
     * @param {ErrorCategoryCreateManyAndReturnArgs} args - Arguments to create many ErrorCategories.
     * @example
     * // Create many ErrorCategories
     * const errorCategory = await prisma.errorCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ErrorCategories and only return the `id`
     * const errorCategoryWithIdOnly = await prisma.errorCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ErrorCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ErrorCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ErrorCategory.
     * @param {ErrorCategoryDeleteArgs} args - Arguments to delete one ErrorCategory.
     * @example
     * // Delete one ErrorCategory
     * const ErrorCategory = await prisma.errorCategory.delete({
     *   where: {
     *     // ... filter to delete one ErrorCategory
     *   }
     * })
     * 
     */
    delete<T extends ErrorCategoryDeleteArgs>(args: SelectSubset<T, ErrorCategoryDeleteArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ErrorCategory.
     * @param {ErrorCategoryUpdateArgs} args - Arguments to update one ErrorCategory.
     * @example
     * // Update one ErrorCategory
     * const errorCategory = await prisma.errorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorCategoryUpdateArgs>(args: SelectSubset<T, ErrorCategoryUpdateArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ErrorCategories.
     * @param {ErrorCategoryDeleteManyArgs} args - Arguments to filter ErrorCategories to delete.
     * @example
     * // Delete a few ErrorCategories
     * const { count } = await prisma.errorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorCategoryDeleteManyArgs>(args?: SelectSubset<T, ErrorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ErrorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ErrorCategories
     * const errorCategory = await prisma.errorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorCategoryUpdateManyArgs>(args: SelectSubset<T, ErrorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ErrorCategories and returns the data updated in the database.
     * @param {ErrorCategoryUpdateManyAndReturnArgs} args - Arguments to update many ErrorCategories.
     * @example
     * // Update many ErrorCategories
     * const errorCategory = await prisma.errorCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ErrorCategories and only return the `id`
     * const errorCategoryWithIdOnly = await prisma.errorCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ErrorCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ErrorCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ErrorCategory.
     * @param {ErrorCategoryUpsertArgs} args - Arguments to update or create a ErrorCategory.
     * @example
     * // Update or create a ErrorCategory
     * const errorCategory = await prisma.errorCategory.upsert({
     *   create: {
     *     // ... data to create a ErrorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ErrorCategory we want to update
     *   }
     * })
     */
    upsert<T extends ErrorCategoryUpsertArgs>(args: SelectSubset<T, ErrorCategoryUpsertArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ErrorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryCountArgs} args - Arguments to filter ErrorCategories to count.
     * @example
     * // Count the number of ErrorCategories
     * const count = await prisma.errorCategory.count({
     *   where: {
     *     // ... the filter for the ErrorCategories we want to count
     *   }
     * })
    **/
    count<T extends ErrorCategoryCountArgs>(
      args?: Subset<T, ErrorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ErrorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorCategoryAggregateArgs>(args: Subset<T, ErrorCategoryAggregateArgs>): Prisma.PrismaPromise<GetErrorCategoryAggregateType<T>>

    /**
     * Group by ErrorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ErrorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ErrorCategory model
   */
  readonly fields: ErrorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ErrorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    errors<T extends ErrorCategory$errorsArgs<ExtArgs> = {}>(args?: Subset<T, ErrorCategory$errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ErrorCategory model
   */
  interface ErrorCategoryFieldRefs {
    readonly id: FieldRef<"ErrorCategory", 'Int'>
    readonly brand_id: FieldRef<"ErrorCategory", 'Int'>
    readonly category: FieldRef<"ErrorCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ErrorCategory findUnique
   */
  export type ErrorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ErrorCategory to fetch.
     */
    where: ErrorCategoryWhereUniqueInput
  }

  /**
   * ErrorCategory findUniqueOrThrow
   */
  export type ErrorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ErrorCategory to fetch.
     */
    where: ErrorCategoryWhereUniqueInput
  }

  /**
   * ErrorCategory findFirst
   */
  export type ErrorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ErrorCategory to fetch.
     */
    where?: ErrorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorCategories to fetch.
     */
    orderBy?: ErrorCategoryOrderByWithRelationInput | ErrorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorCategories.
     */
    cursor?: ErrorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorCategories.
     */
    distinct?: ErrorCategoryScalarFieldEnum | ErrorCategoryScalarFieldEnum[]
  }

  /**
   * ErrorCategory findFirstOrThrow
   */
  export type ErrorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ErrorCategory to fetch.
     */
    where?: ErrorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorCategories to fetch.
     */
    orderBy?: ErrorCategoryOrderByWithRelationInput | ErrorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorCategories.
     */
    cursor?: ErrorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorCategories.
     */
    distinct?: ErrorCategoryScalarFieldEnum | ErrorCategoryScalarFieldEnum[]
  }

  /**
   * ErrorCategory findMany
   */
  export type ErrorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ErrorCategories to fetch.
     */
    where?: ErrorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorCategories to fetch.
     */
    orderBy?: ErrorCategoryOrderByWithRelationInput | ErrorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ErrorCategories.
     */
    cursor?: ErrorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorCategories.
     */
    skip?: number
    distinct?: ErrorCategoryScalarFieldEnum | ErrorCategoryScalarFieldEnum[]
  }

  /**
   * ErrorCategory create
   */
  export type ErrorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ErrorCategory.
     */
    data: XOR<ErrorCategoryCreateInput, ErrorCategoryUncheckedCreateInput>
  }

  /**
   * ErrorCategory createMany
   */
  export type ErrorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ErrorCategories.
     */
    data: ErrorCategoryCreateManyInput | ErrorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ErrorCategory createManyAndReturn
   */
  export type ErrorCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ErrorCategories.
     */
    data: ErrorCategoryCreateManyInput | ErrorCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ErrorCategory update
   */
  export type ErrorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ErrorCategory.
     */
    data: XOR<ErrorCategoryUpdateInput, ErrorCategoryUncheckedUpdateInput>
    /**
     * Choose, which ErrorCategory to update.
     */
    where: ErrorCategoryWhereUniqueInput
  }

  /**
   * ErrorCategory updateMany
   */
  export type ErrorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ErrorCategories.
     */
    data: XOR<ErrorCategoryUpdateManyMutationInput, ErrorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ErrorCategories to update
     */
    where?: ErrorCategoryWhereInput
    /**
     * Limit how many ErrorCategories to update.
     */
    limit?: number
  }

  /**
   * ErrorCategory updateManyAndReturn
   */
  export type ErrorCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ErrorCategories.
     */
    data: XOR<ErrorCategoryUpdateManyMutationInput, ErrorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ErrorCategories to update
     */
    where?: ErrorCategoryWhereInput
    /**
     * Limit how many ErrorCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ErrorCategory upsert
   */
  export type ErrorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ErrorCategory to update in case it exists.
     */
    where: ErrorCategoryWhereUniqueInput
    /**
     * In case the ErrorCategory found by the `where` argument doesn't exist, create a new ErrorCategory with this data.
     */
    create: XOR<ErrorCategoryCreateInput, ErrorCategoryUncheckedCreateInput>
    /**
     * In case the ErrorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorCategoryUpdateInput, ErrorCategoryUncheckedUpdateInput>
  }

  /**
   * ErrorCategory delete
   */
  export type ErrorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    /**
     * Filter which ErrorCategory to delete.
     */
    where: ErrorCategoryWhereUniqueInput
  }

  /**
   * ErrorCategory deleteMany
   */
  export type ErrorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorCategories to delete
     */
    where?: ErrorCategoryWhereInput
    /**
     * Limit how many ErrorCategories to delete.
     */
    limit?: number
  }

  /**
   * ErrorCategory.errors
   */
  export type ErrorCategory$errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    where?: ErrorWhereInput
    orderBy?: ErrorOrderByWithRelationInput | ErrorOrderByWithRelationInput[]
    cursor?: ErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorScalarFieldEnum | ErrorScalarFieldEnum[]
  }

  /**
   * ErrorCategory without action
   */
  export type ErrorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Error
   */

  export type AggregateError = {
    _count: ErrorCountAggregateOutputType | null
    _avg: ErrorAvgAggregateOutputType | null
    _sum: ErrorSumAggregateOutputType | null
    _min: ErrorMinAggregateOutputType | null
    _max: ErrorMaxAggregateOutputType | null
  }

  export type ErrorAvgAggregateOutputType = {
    id: number | null
    error_category_id: number | null
  }

  export type ErrorSumAggregateOutputType = {
    id: number | null
    error_category_id: number | null
  }

  export type ErrorMinAggregateOutputType = {
    id: number | null
    error_category_id: number | null
    code: string | null
    description: string | null
  }

  export type ErrorMaxAggregateOutputType = {
    id: number | null
    error_category_id: number | null
    code: string | null
    description: string | null
  }

  export type ErrorCountAggregateOutputType = {
    id: number
    error_category_id: number
    code: number
    description: number
    _all: number
  }


  export type ErrorAvgAggregateInputType = {
    id?: true
    error_category_id?: true
  }

  export type ErrorSumAggregateInputType = {
    id?: true
    error_category_id?: true
  }

  export type ErrorMinAggregateInputType = {
    id?: true
    error_category_id?: true
    code?: true
    description?: true
  }

  export type ErrorMaxAggregateInputType = {
    id?: true
    error_category_id?: true
    code?: true
    description?: true
  }

  export type ErrorCountAggregateInputType = {
    id?: true
    error_category_id?: true
    code?: true
    description?: true
    _all?: true
  }

  export type ErrorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Error to aggregate.
     */
    where?: ErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorOrderByWithRelationInput | ErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Errors
    **/
    _count?: true | ErrorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ErrorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ErrorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorMaxAggregateInputType
  }

  export type GetErrorAggregateType<T extends ErrorAggregateArgs> = {
        [P in keyof T & keyof AggregateError]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateError[P]>
      : GetScalarType<T[P], AggregateError[P]>
  }




  export type ErrorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorWhereInput
    orderBy?: ErrorOrderByWithAggregationInput | ErrorOrderByWithAggregationInput[]
    by: ErrorScalarFieldEnum[] | ErrorScalarFieldEnum
    having?: ErrorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorCountAggregateInputType | true
    _avg?: ErrorAvgAggregateInputType
    _sum?: ErrorSumAggregateInputType
    _min?: ErrorMinAggregateInputType
    _max?: ErrorMaxAggregateInputType
  }

  export type ErrorGroupByOutputType = {
    id: number
    error_category_id: number
    code: string
    description: string | null
    _count: ErrorCountAggregateOutputType | null
    _avg: ErrorAvgAggregateOutputType | null
    _sum: ErrorSumAggregateOutputType | null
    _min: ErrorMinAggregateOutputType | null
    _max: ErrorMaxAggregateOutputType | null
  }

  type GetErrorGroupByPayload<T extends ErrorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorGroupByOutputType[P]>
        }
      >
    >


  export type ErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    error_category_id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
    asset_errors?: boolean | Error$asset_errorsArgs<ExtArgs>
    _count?: boolean | ErrorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["error"]>

  export type ErrorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    error_category_id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["error"]>

  export type ErrorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    error_category_id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["error"]>

  export type ErrorSelectScalar = {
    id?: boolean
    error_category_id?: boolean
    code?: boolean
    description?: boolean
  }

  export type ErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "error_category_id" | "code" | "description", ExtArgs["result"]["error"]>
  export type ErrorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
    asset_errors?: boolean | Error$asset_errorsArgs<ExtArgs>
    _count?: boolean | ErrorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ErrorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
  }
  export type ErrorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ErrorCategoryDefaultArgs<ExtArgs>
  }

  export type $ErrorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Error"
    objects: {
      category: Prisma.$ErrorCategoryPayload<ExtArgs>
      asset_errors: Prisma.$AssetErrorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      error_category_id: number
      code: string
      description: string | null
    }, ExtArgs["result"]["error"]>
    composites: {}
  }

  type ErrorGetPayload<S extends boolean | null | undefined | ErrorDefaultArgs> = $Result.GetResult<Prisma.$ErrorPayload, S>

  type ErrorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ErrorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ErrorCountAggregateInputType | true
    }

  export interface ErrorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Error'], meta: { name: 'Error' } }
    /**
     * Find zero or one Error that matches the filter.
     * @param {ErrorFindUniqueArgs} args - Arguments to find a Error
     * @example
     * // Get one Error
     * const error = await prisma.error.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorFindUniqueArgs>(args: SelectSubset<T, ErrorFindUniqueArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Error that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ErrorFindUniqueOrThrowArgs} args - Arguments to find a Error
     * @example
     * // Get one Error
     * const error = await prisma.error.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Error that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorFindFirstArgs} args - Arguments to find a Error
     * @example
     * // Get one Error
     * const error = await prisma.error.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorFindFirstArgs>(args?: SelectSubset<T, ErrorFindFirstArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Error that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorFindFirstOrThrowArgs} args - Arguments to find a Error
     * @example
     * // Get one Error
     * const error = await prisma.error.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Errors
     * const errors = await prisma.error.findMany()
     * 
     * // Get first 10 Errors
     * const errors = await prisma.error.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const errorWithIdOnly = await prisma.error.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ErrorFindManyArgs>(args?: SelectSubset<T, ErrorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Error.
     * @param {ErrorCreateArgs} args - Arguments to create a Error.
     * @example
     * // Create one Error
     * const Error = await prisma.error.create({
     *   data: {
     *     // ... data to create a Error
     *   }
     * })
     * 
     */
    create<T extends ErrorCreateArgs>(args: SelectSubset<T, ErrorCreateArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Errors.
     * @param {ErrorCreateManyArgs} args - Arguments to create many Errors.
     * @example
     * // Create many Errors
     * const error = await prisma.error.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorCreateManyArgs>(args?: SelectSubset<T, ErrorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Errors and returns the data saved in the database.
     * @param {ErrorCreateManyAndReturnArgs} args - Arguments to create many Errors.
     * @example
     * // Create many Errors
     * const error = await prisma.error.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Errors and only return the `id`
     * const errorWithIdOnly = await prisma.error.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ErrorCreateManyAndReturnArgs>(args?: SelectSubset<T, ErrorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Error.
     * @param {ErrorDeleteArgs} args - Arguments to delete one Error.
     * @example
     * // Delete one Error
     * const Error = await prisma.error.delete({
     *   where: {
     *     // ... filter to delete one Error
     *   }
     * })
     * 
     */
    delete<T extends ErrorDeleteArgs>(args: SelectSubset<T, ErrorDeleteArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Error.
     * @param {ErrorUpdateArgs} args - Arguments to update one Error.
     * @example
     * // Update one Error
     * const error = await prisma.error.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorUpdateArgs>(args: SelectSubset<T, ErrorUpdateArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Errors.
     * @param {ErrorDeleteManyArgs} args - Arguments to filter Errors to delete.
     * @example
     * // Delete a few Errors
     * const { count } = await prisma.error.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorDeleteManyArgs>(args?: SelectSubset<T, ErrorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Errors
     * const error = await prisma.error.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorUpdateManyArgs>(args: SelectSubset<T, ErrorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Errors and returns the data updated in the database.
     * @param {ErrorUpdateManyAndReturnArgs} args - Arguments to update many Errors.
     * @example
     * // Update many Errors
     * const error = await prisma.error.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Errors and only return the `id`
     * const errorWithIdOnly = await prisma.error.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ErrorUpdateManyAndReturnArgs>(args: SelectSubset<T, ErrorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Error.
     * @param {ErrorUpsertArgs} args - Arguments to update or create a Error.
     * @example
     * // Update or create a Error
     * const error = await prisma.error.upsert({
     *   create: {
     *     // ... data to create a Error
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Error we want to update
     *   }
     * })
     */
    upsert<T extends ErrorUpsertArgs>(args: SelectSubset<T, ErrorUpsertArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorCountArgs} args - Arguments to filter Errors to count.
     * @example
     * // Count the number of Errors
     * const count = await prisma.error.count({
     *   where: {
     *     // ... the filter for the Errors we want to count
     *   }
     * })
    **/
    count<T extends ErrorCountArgs>(
      args?: Subset<T, ErrorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorAggregateArgs>(args: Subset<T, ErrorAggregateArgs>): Prisma.PrismaPromise<GetErrorAggregateType<T>>

    /**
     * Group by Error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorGroupByArgs['orderBy'] }
        : { orderBy?: ErrorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Error model
   */
  readonly fields: ErrorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Error.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ErrorCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ErrorCategoryDefaultArgs<ExtArgs>>): Prisma__ErrorCategoryClient<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset_errors<T extends Error$asset_errorsArgs<ExtArgs> = {}>(args?: Subset<T, Error$asset_errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Error model
   */
  interface ErrorFieldRefs {
    readonly id: FieldRef<"Error", 'Int'>
    readonly error_category_id: FieldRef<"Error", 'Int'>
    readonly code: FieldRef<"Error", 'String'>
    readonly description: FieldRef<"Error", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Error findUnique
   */
  export type ErrorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter, which Error to fetch.
     */
    where: ErrorWhereUniqueInput
  }

  /**
   * Error findUniqueOrThrow
   */
  export type ErrorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter, which Error to fetch.
     */
    where: ErrorWhereUniqueInput
  }

  /**
   * Error findFirst
   */
  export type ErrorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter, which Error to fetch.
     */
    where?: ErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorOrderByWithRelationInput | ErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Errors.
     */
    cursor?: ErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Errors.
     */
    distinct?: ErrorScalarFieldEnum | ErrorScalarFieldEnum[]
  }

  /**
   * Error findFirstOrThrow
   */
  export type ErrorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter, which Error to fetch.
     */
    where?: ErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorOrderByWithRelationInput | ErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Errors.
     */
    cursor?: ErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Errors.
     */
    distinct?: ErrorScalarFieldEnum | ErrorScalarFieldEnum[]
  }

  /**
   * Error findMany
   */
  export type ErrorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter, which Errors to fetch.
     */
    where?: ErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Errors to fetch.
     */
    orderBy?: ErrorOrderByWithRelationInput | ErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Errors.
     */
    cursor?: ErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Errors.
     */
    skip?: number
    distinct?: ErrorScalarFieldEnum | ErrorScalarFieldEnum[]
  }

  /**
   * Error create
   */
  export type ErrorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * The data needed to create a Error.
     */
    data: XOR<ErrorCreateInput, ErrorUncheckedCreateInput>
  }

  /**
   * Error createMany
   */
  export type ErrorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Errors.
     */
    data: ErrorCreateManyInput | ErrorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Error createManyAndReturn
   */
  export type ErrorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * The data used to create many Errors.
     */
    data: ErrorCreateManyInput | ErrorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Error update
   */
  export type ErrorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * The data needed to update a Error.
     */
    data: XOR<ErrorUpdateInput, ErrorUncheckedUpdateInput>
    /**
     * Choose, which Error to update.
     */
    where: ErrorWhereUniqueInput
  }

  /**
   * Error updateMany
   */
  export type ErrorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Errors.
     */
    data: XOR<ErrorUpdateManyMutationInput, ErrorUncheckedUpdateManyInput>
    /**
     * Filter which Errors to update
     */
    where?: ErrorWhereInput
    /**
     * Limit how many Errors to update.
     */
    limit?: number
  }

  /**
   * Error updateManyAndReturn
   */
  export type ErrorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * The data used to update Errors.
     */
    data: XOR<ErrorUpdateManyMutationInput, ErrorUncheckedUpdateManyInput>
    /**
     * Filter which Errors to update
     */
    where?: ErrorWhereInput
    /**
     * Limit how many Errors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Error upsert
   */
  export type ErrorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * The filter to search for the Error to update in case it exists.
     */
    where: ErrorWhereUniqueInput
    /**
     * In case the Error found by the `where` argument doesn't exist, create a new Error with this data.
     */
    create: XOR<ErrorCreateInput, ErrorUncheckedCreateInput>
    /**
     * In case the Error was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorUpdateInput, ErrorUncheckedUpdateInput>
  }

  /**
   * Error delete
   */
  export type ErrorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
    /**
     * Filter which Error to delete.
     */
    where: ErrorWhereUniqueInput
  }

  /**
   * Error deleteMany
   */
  export type ErrorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Errors to delete
     */
    where?: ErrorWhereInput
    /**
     * Limit how many Errors to delete.
     */
    limit?: number
  }

  /**
   * Error.asset_errors
   */
  export type Error$asset_errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    where?: AssetErrorWhereInput
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    cursor?: AssetErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * Error without action
   */
  export type ErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorInclude<ExtArgs> | null
  }


  /**
   * Model AssetError
   */

  export type AggregateAssetError = {
    _count: AssetErrorCountAggregateOutputType | null
    _avg: AssetErrorAvgAggregateOutputType | null
    _sum: AssetErrorSumAggregateOutputType | null
    _min: AssetErrorMinAggregateOutputType | null
    _max: AssetErrorMaxAggregateOutputType | null
  }

  export type AssetErrorAvgAggregateOutputType = {
    asset_id: number | null
    error_id: number | null
    added_by: number | null
    fixed_by: number | null
  }

  export type AssetErrorSumAggregateOutputType = {
    asset_id: number | null
    error_id: number | null
    added_by: number | null
    fixed_by: number | null
  }

  export type AssetErrorMinAggregateOutputType = {
    asset_id: number | null
    error_id: number | null
    is_fixed: boolean | null
    added_by: number | null
    added_at: Date | null
    fixed_by: number | null
    fixed_at: Date | null
  }

  export type AssetErrorMaxAggregateOutputType = {
    asset_id: number | null
    error_id: number | null
    is_fixed: boolean | null
    added_by: number | null
    added_at: Date | null
    fixed_by: number | null
    fixed_at: Date | null
  }

  export type AssetErrorCountAggregateOutputType = {
    asset_id: number
    error_id: number
    is_fixed: number
    added_by: number
    added_at: number
    fixed_by: number
    fixed_at: number
    _all: number
  }


  export type AssetErrorAvgAggregateInputType = {
    asset_id?: true
    error_id?: true
    added_by?: true
    fixed_by?: true
  }

  export type AssetErrorSumAggregateInputType = {
    asset_id?: true
    error_id?: true
    added_by?: true
    fixed_by?: true
  }

  export type AssetErrorMinAggregateInputType = {
    asset_id?: true
    error_id?: true
    is_fixed?: true
    added_by?: true
    added_at?: true
    fixed_by?: true
    fixed_at?: true
  }

  export type AssetErrorMaxAggregateInputType = {
    asset_id?: true
    error_id?: true
    is_fixed?: true
    added_by?: true
    added_at?: true
    fixed_by?: true
    fixed_at?: true
  }

  export type AssetErrorCountAggregateInputType = {
    asset_id?: true
    error_id?: true
    is_fixed?: true
    added_by?: true
    added_at?: true
    fixed_by?: true
    fixed_at?: true
    _all?: true
  }

  export type AssetErrorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetError to aggregate.
     */
    where?: AssetErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetErrors to fetch.
     */
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetErrors
    **/
    _count?: true | AssetErrorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetErrorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetErrorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetErrorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetErrorMaxAggregateInputType
  }

  export type GetAssetErrorAggregateType<T extends AssetErrorAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetError]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetError[P]>
      : GetScalarType<T[P], AggregateAssetError[P]>
  }




  export type AssetErrorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetErrorWhereInput
    orderBy?: AssetErrorOrderByWithAggregationInput | AssetErrorOrderByWithAggregationInput[]
    by: AssetErrorScalarFieldEnum[] | AssetErrorScalarFieldEnum
    having?: AssetErrorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetErrorCountAggregateInputType | true
    _avg?: AssetErrorAvgAggregateInputType
    _sum?: AssetErrorSumAggregateInputType
    _min?: AssetErrorMinAggregateInputType
    _max?: AssetErrorMaxAggregateInputType
  }

  export type AssetErrorGroupByOutputType = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date
    fixed_by: number | null
    fixed_at: Date | null
    _count: AssetErrorCountAggregateOutputType | null
    _avg: AssetErrorAvgAggregateOutputType | null
    _sum: AssetErrorSumAggregateOutputType | null
    _min: AssetErrorMinAggregateOutputType | null
    _max: AssetErrorMaxAggregateOutputType | null
  }

  type GetAssetErrorGroupByPayload<T extends AssetErrorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetErrorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetErrorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetErrorGroupByOutputType[P]>
            : GetScalarType<T[P], AssetErrorGroupByOutputType[P]>
        }
      >
    >


  export type AssetErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    error_id?: boolean
    is_fixed?: boolean
    added_by?: boolean
    added_at?: boolean
    fixed_by?: boolean
    fixed_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }, ExtArgs["result"]["assetError"]>

  export type AssetErrorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    error_id?: boolean
    is_fixed?: boolean
    added_by?: boolean
    added_at?: boolean
    fixed_by?: boolean
    fixed_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }, ExtArgs["result"]["assetError"]>

  export type AssetErrorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    error_id?: boolean
    is_fixed?: boolean
    added_by?: boolean
    added_at?: boolean
    fixed_by?: boolean
    fixed_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }, ExtArgs["result"]["assetError"]>

  export type AssetErrorSelectScalar = {
    asset_id?: boolean
    error_id?: boolean
    is_fixed?: boolean
    added_by?: boolean
    added_at?: boolean
    fixed_by?: boolean
    fixed_at?: boolean
  }

  export type AssetErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"asset_id" | "error_id" | "is_fixed" | "added_by" | "added_at" | "fixed_by" | "fixed_at", ExtArgs["result"]["assetError"]>
  export type AssetErrorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }
  export type AssetErrorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }
  export type AssetErrorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    error?: boolean | ErrorDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    fixedBy?: boolean | AssetError$fixedByArgs<ExtArgs>
  }

  export type $AssetErrorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetError"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      error: Prisma.$ErrorPayload<ExtArgs>
      addedBy: Prisma.$UserPayload<ExtArgs>
      fixedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      asset_id: number
      error_id: number
      is_fixed: boolean
      added_by: number
      added_at: Date
      fixed_by: number | null
      fixed_at: Date | null
    }, ExtArgs["result"]["assetError"]>
    composites: {}
  }

  type AssetErrorGetPayload<S extends boolean | null | undefined | AssetErrorDefaultArgs> = $Result.GetResult<Prisma.$AssetErrorPayload, S>

  type AssetErrorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetErrorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetErrorCountAggregateInputType | true
    }

  export interface AssetErrorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetError'], meta: { name: 'AssetError' } }
    /**
     * Find zero or one AssetError that matches the filter.
     * @param {AssetErrorFindUniqueArgs} args - Arguments to find a AssetError
     * @example
     * // Get one AssetError
     * const assetError = await prisma.assetError.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetErrorFindUniqueArgs>(args: SelectSubset<T, AssetErrorFindUniqueArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetError that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetErrorFindUniqueOrThrowArgs} args - Arguments to find a AssetError
     * @example
     * // Get one AssetError
     * const assetError = await prisma.assetError.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetErrorFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetErrorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetError that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorFindFirstArgs} args - Arguments to find a AssetError
     * @example
     * // Get one AssetError
     * const assetError = await prisma.assetError.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetErrorFindFirstArgs>(args?: SelectSubset<T, AssetErrorFindFirstArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetError that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorFindFirstOrThrowArgs} args - Arguments to find a AssetError
     * @example
     * // Get one AssetError
     * const assetError = await prisma.assetError.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetErrorFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetErrorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetErrors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetErrors
     * const assetErrors = await prisma.assetError.findMany()
     * 
     * // Get first 10 AssetErrors
     * const assetErrors = await prisma.assetError.findMany({ take: 10 })
     * 
     * // Only select the `asset_id`
     * const assetErrorWithAsset_idOnly = await prisma.assetError.findMany({ select: { asset_id: true } })
     * 
     */
    findMany<T extends AssetErrorFindManyArgs>(args?: SelectSubset<T, AssetErrorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetError.
     * @param {AssetErrorCreateArgs} args - Arguments to create a AssetError.
     * @example
     * // Create one AssetError
     * const AssetError = await prisma.assetError.create({
     *   data: {
     *     // ... data to create a AssetError
     *   }
     * })
     * 
     */
    create<T extends AssetErrorCreateArgs>(args: SelectSubset<T, AssetErrorCreateArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetErrors.
     * @param {AssetErrorCreateManyArgs} args - Arguments to create many AssetErrors.
     * @example
     * // Create many AssetErrors
     * const assetError = await prisma.assetError.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetErrorCreateManyArgs>(args?: SelectSubset<T, AssetErrorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetErrors and returns the data saved in the database.
     * @param {AssetErrorCreateManyAndReturnArgs} args - Arguments to create many AssetErrors.
     * @example
     * // Create many AssetErrors
     * const assetError = await prisma.assetError.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetErrors and only return the `asset_id`
     * const assetErrorWithAsset_idOnly = await prisma.assetError.createManyAndReturn({
     *   select: { asset_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetErrorCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetErrorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetError.
     * @param {AssetErrorDeleteArgs} args - Arguments to delete one AssetError.
     * @example
     * // Delete one AssetError
     * const AssetError = await prisma.assetError.delete({
     *   where: {
     *     // ... filter to delete one AssetError
     *   }
     * })
     * 
     */
    delete<T extends AssetErrorDeleteArgs>(args: SelectSubset<T, AssetErrorDeleteArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetError.
     * @param {AssetErrorUpdateArgs} args - Arguments to update one AssetError.
     * @example
     * // Update one AssetError
     * const assetError = await prisma.assetError.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetErrorUpdateArgs>(args: SelectSubset<T, AssetErrorUpdateArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetErrors.
     * @param {AssetErrorDeleteManyArgs} args - Arguments to filter AssetErrors to delete.
     * @example
     * // Delete a few AssetErrors
     * const { count } = await prisma.assetError.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetErrorDeleteManyArgs>(args?: SelectSubset<T, AssetErrorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetErrors
     * const assetError = await prisma.assetError.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetErrorUpdateManyArgs>(args: SelectSubset<T, AssetErrorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetErrors and returns the data updated in the database.
     * @param {AssetErrorUpdateManyAndReturnArgs} args - Arguments to update many AssetErrors.
     * @example
     * // Update many AssetErrors
     * const assetError = await prisma.assetError.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetErrors and only return the `asset_id`
     * const assetErrorWithAsset_idOnly = await prisma.assetError.updateManyAndReturn({
     *   select: { asset_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetErrorUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetErrorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetError.
     * @param {AssetErrorUpsertArgs} args - Arguments to update or create a AssetError.
     * @example
     * // Update or create a AssetError
     * const assetError = await prisma.assetError.upsert({
     *   create: {
     *     // ... data to create a AssetError
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetError we want to update
     *   }
     * })
     */
    upsert<T extends AssetErrorUpsertArgs>(args: SelectSubset<T, AssetErrorUpsertArgs<ExtArgs>>): Prisma__AssetErrorClient<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorCountArgs} args - Arguments to filter AssetErrors to count.
     * @example
     * // Count the number of AssetErrors
     * const count = await prisma.assetError.count({
     *   where: {
     *     // ... the filter for the AssetErrors we want to count
     *   }
     * })
    **/
    count<T extends AssetErrorCountArgs>(
      args?: Subset<T, AssetErrorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetErrorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetErrorAggregateArgs>(args: Subset<T, AssetErrorAggregateArgs>): Prisma.PrismaPromise<GetAssetErrorAggregateType<T>>

    /**
     * Group by AssetError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetErrorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetErrorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetErrorGroupByArgs['orderBy'] }
        : { orderBy?: AssetErrorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetErrorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetErrorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetError model
   */
  readonly fields: AssetErrorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetError.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetErrorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    error<T extends ErrorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ErrorDefaultArgs<ExtArgs>>): Prisma__ErrorClient<$Result.GetResult<Prisma.$ErrorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fixedBy<T extends AssetError$fixedByArgs<ExtArgs> = {}>(args?: Subset<T, AssetError$fixedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetError model
   */
  interface AssetErrorFieldRefs {
    readonly asset_id: FieldRef<"AssetError", 'Int'>
    readonly error_id: FieldRef<"AssetError", 'Int'>
    readonly is_fixed: FieldRef<"AssetError", 'Boolean'>
    readonly added_by: FieldRef<"AssetError", 'Int'>
    readonly added_at: FieldRef<"AssetError", 'DateTime'>
    readonly fixed_by: FieldRef<"AssetError", 'Int'>
    readonly fixed_at: FieldRef<"AssetError", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetError findUnique
   */
  export type AssetErrorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter, which AssetError to fetch.
     */
    where: AssetErrorWhereUniqueInput
  }

  /**
   * AssetError findUniqueOrThrow
   */
  export type AssetErrorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter, which AssetError to fetch.
     */
    where: AssetErrorWhereUniqueInput
  }

  /**
   * AssetError findFirst
   */
  export type AssetErrorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter, which AssetError to fetch.
     */
    where?: AssetErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetErrors to fetch.
     */
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetErrors.
     */
    cursor?: AssetErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetErrors.
     */
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * AssetError findFirstOrThrow
   */
  export type AssetErrorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter, which AssetError to fetch.
     */
    where?: AssetErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetErrors to fetch.
     */
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetErrors.
     */
    cursor?: AssetErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetErrors.
     */
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * AssetError findMany
   */
  export type AssetErrorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter, which AssetErrors to fetch.
     */
    where?: AssetErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetErrors to fetch.
     */
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetErrors.
     */
    cursor?: AssetErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetErrors.
     */
    skip?: number
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * AssetError create
   */
  export type AssetErrorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetError.
     */
    data: XOR<AssetErrorCreateInput, AssetErrorUncheckedCreateInput>
  }

  /**
   * AssetError createMany
   */
  export type AssetErrorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetErrors.
     */
    data: AssetErrorCreateManyInput | AssetErrorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetError createManyAndReturn
   */
  export type AssetErrorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * The data used to create many AssetErrors.
     */
    data: AssetErrorCreateManyInput | AssetErrorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetError update
   */
  export type AssetErrorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetError.
     */
    data: XOR<AssetErrorUpdateInput, AssetErrorUncheckedUpdateInput>
    /**
     * Choose, which AssetError to update.
     */
    where: AssetErrorWhereUniqueInput
  }

  /**
   * AssetError updateMany
   */
  export type AssetErrorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetErrors.
     */
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyInput>
    /**
     * Filter which AssetErrors to update
     */
    where?: AssetErrorWhereInput
    /**
     * Limit how many AssetErrors to update.
     */
    limit?: number
  }

  /**
   * AssetError updateManyAndReturn
   */
  export type AssetErrorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * The data used to update AssetErrors.
     */
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyInput>
    /**
     * Filter which AssetErrors to update
     */
    where?: AssetErrorWhereInput
    /**
     * Limit how many AssetErrors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetError upsert
   */
  export type AssetErrorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetError to update in case it exists.
     */
    where: AssetErrorWhereUniqueInput
    /**
     * In case the AssetError found by the `where` argument doesn't exist, create a new AssetError with this data.
     */
    create: XOR<AssetErrorCreateInput, AssetErrorUncheckedCreateInput>
    /**
     * In case the AssetError was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetErrorUpdateInput, AssetErrorUncheckedUpdateInput>
  }

  /**
   * AssetError delete
   */
  export type AssetErrorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    /**
     * Filter which AssetError to delete.
     */
    where: AssetErrorWhereUniqueInput
  }

  /**
   * AssetError deleteMany
   */
  export type AssetErrorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetErrors to delete
     */
    where?: AssetErrorWhereInput
    /**
     * Limit how many AssetErrors to delete.
     */
    limit?: number
  }

  /**
   * AssetError.fixedBy
   */
  export type AssetError$fixedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssetError without action
   */
  export type AssetErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
  }


  /**
   * Model Part
   */

  export type AggregatePart = {
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  export type PartAvgAggregateOutputType = {
    id: number | null
    dealer_price: Decimal | null
    sale_price: Decimal | null
    cost: Decimal | null
  }

  export type PartSumAggregateOutputType = {
    id: number | null
    dealer_price: Decimal | null
    sale_price: Decimal | null
    cost: Decimal | null
  }

  export type PartMinAggregateOutputType = {
    id: number | null
    description: string | null
    part_number: string | null
    dealer_price: Decimal | null
    sale_price: Decimal | null
    cost: Decimal | null
  }

  export type PartMaxAggregateOutputType = {
    id: number | null
    description: string | null
    part_number: string | null
    dealer_price: Decimal | null
    sale_price: Decimal | null
    cost: Decimal | null
  }

  export type PartCountAggregateOutputType = {
    id: number
    description: number
    part_number: number
    dealer_price: number
    sale_price: number
    cost: number
    _all: number
  }


  export type PartAvgAggregateInputType = {
    id?: true
    dealer_price?: true
    sale_price?: true
    cost?: true
  }

  export type PartSumAggregateInputType = {
    id?: true
    dealer_price?: true
    sale_price?: true
    cost?: true
  }

  export type PartMinAggregateInputType = {
    id?: true
    description?: true
    part_number?: true
    dealer_price?: true
    sale_price?: true
    cost?: true
  }

  export type PartMaxAggregateInputType = {
    id?: true
    description?: true
    part_number?: true
    dealer_price?: true
    sale_price?: true
    cost?: true
  }

  export type PartCountAggregateInputType = {
    id?: true
    description?: true
    part_number?: true
    dealer_price?: true
    sale_price?: true
    cost?: true
    _all?: true
  }

  export type PartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Part to aggregate.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parts
    **/
    _count?: true | PartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartMaxAggregateInputType
  }

  export type GetPartAggregateType<T extends PartAggregateArgs> = {
        [P in keyof T & keyof AggregatePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePart[P]>
      : GetScalarType<T[P], AggregatePart[P]>
  }




  export type PartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
    orderBy?: PartOrderByWithAggregationInput | PartOrderByWithAggregationInput[]
    by: PartScalarFieldEnum[] | PartScalarFieldEnum
    having?: PartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartCountAggregateInputType | true
    _avg?: PartAvgAggregateInputType
    _sum?: PartSumAggregateInputType
    _min?: PartMinAggregateInputType
    _max?: PartMaxAggregateInputType
  }

  export type PartGroupByOutputType = {
    id: number
    description: string
    part_number: string
    dealer_price: Decimal
    sale_price: Decimal
    cost: Decimal
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  type GetPartGroupByPayload<T extends PartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupByOutputType[P]>
        }
      >
    >


  export type PartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    part_number?: boolean
    dealer_price?: boolean
    sale_price?: boolean
    cost?: boolean
    asset_parts?: boolean | Part$asset_partsArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["part"]>

  export type PartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    part_number?: boolean
    dealer_price?: boolean
    sale_price?: boolean
    cost?: boolean
  }, ExtArgs["result"]["part"]>

  export type PartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    part_number?: boolean
    dealer_price?: boolean
    sale_price?: boolean
    cost?: boolean
  }, ExtArgs["result"]["part"]>

  export type PartSelectScalar = {
    id?: boolean
    description?: boolean
    part_number?: boolean
    dealer_price?: boolean
    sale_price?: boolean
    cost?: boolean
  }

  export type PartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "part_number" | "dealer_price" | "sale_price" | "cost", ExtArgs["result"]["part"]>
  export type PartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_parts?: boolean | Part$asset_partsArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Part"
    objects: {
      asset_parts: Prisma.$AssetPartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      part_number: string
      dealer_price: Prisma.Decimal
      sale_price: Prisma.Decimal
      cost: Prisma.Decimal
    }, ExtArgs["result"]["part"]>
    composites: {}
  }

  type PartGetPayload<S extends boolean | null | undefined | PartDefaultArgs> = $Result.GetResult<Prisma.$PartPayload, S>

  type PartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartCountAggregateInputType | true
    }

  export interface PartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Part'], meta: { name: 'Part' } }
    /**
     * Find zero or one Part that matches the filter.
     * @param {PartFindUniqueArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartFindUniqueArgs>(args: SelectSubset<T, PartFindUniqueArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Part that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartFindUniqueOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartFindUniqueOrThrowArgs>(args: SelectSubset<T, PartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Part that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartFindFirstArgs>(args?: SelectSubset<T, PartFindFirstArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Part that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartFindFirstOrThrowArgs>(args?: SelectSubset<T, PartFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.part.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.part.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partWithIdOnly = await prisma.part.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartFindManyArgs>(args?: SelectSubset<T, PartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Part.
     * @param {PartCreateArgs} args - Arguments to create a Part.
     * @example
     * // Create one Part
     * const Part = await prisma.part.create({
     *   data: {
     *     // ... data to create a Part
     *   }
     * })
     * 
     */
    create<T extends PartCreateArgs>(args: SelectSubset<T, PartCreateArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parts.
     * @param {PartCreateManyArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const part = await prisma.part.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartCreateManyArgs>(args?: SelectSubset<T, PartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parts and returns the data saved in the database.
     * @param {PartCreateManyAndReturnArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const part = await prisma.part.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parts and only return the `id`
     * const partWithIdOnly = await prisma.part.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartCreateManyAndReturnArgs>(args?: SelectSubset<T, PartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Part.
     * @param {PartDeleteArgs} args - Arguments to delete one Part.
     * @example
     * // Delete one Part
     * const Part = await prisma.part.delete({
     *   where: {
     *     // ... filter to delete one Part
     *   }
     * })
     * 
     */
    delete<T extends PartDeleteArgs>(args: SelectSubset<T, PartDeleteArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Part.
     * @param {PartUpdateArgs} args - Arguments to update one Part.
     * @example
     * // Update one Part
     * const part = await prisma.part.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartUpdateArgs>(args: SelectSubset<T, PartUpdateArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parts.
     * @param {PartDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.part.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartDeleteManyArgs>(args?: SelectSubset<T, PartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartUpdateManyArgs>(args: SelectSubset<T, PartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts and returns the data updated in the database.
     * @param {PartUpdateManyAndReturnArgs} args - Arguments to update many Parts.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parts and only return the `id`
     * const partWithIdOnly = await prisma.part.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartUpdateManyAndReturnArgs>(args: SelectSubset<T, PartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Part.
     * @param {PartUpsertArgs} args - Arguments to update or create a Part.
     * @example
     * // Update or create a Part
     * const part = await prisma.part.upsert({
     *   create: {
     *     // ... data to create a Part
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Part we want to update
     *   }
     * })
     */
    upsert<T extends PartUpsertArgs>(args: SelectSubset<T, PartUpsertArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.part.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends PartCountArgs>(
      args?: Subset<T, PartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartAggregateArgs>(args: Subset<T, PartAggregateArgs>): Prisma.PrismaPromise<GetPartAggregateType<T>>

    /**
     * Group by Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Part model
   */
  readonly fields: PartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Part.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset_parts<T extends Part$asset_partsArgs<ExtArgs> = {}>(args?: Subset<T, Part$asset_partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Part model
   */
  interface PartFieldRefs {
    readonly id: FieldRef<"Part", 'Int'>
    readonly description: FieldRef<"Part", 'String'>
    readonly part_number: FieldRef<"Part", 'String'>
    readonly dealer_price: FieldRef<"Part", 'Decimal'>
    readonly sale_price: FieldRef<"Part", 'Decimal'>
    readonly cost: FieldRef<"Part", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Part findUnique
   */
  export type PartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part findUniqueOrThrow
   */
  export type PartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part findFirst
   */
  export type PartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part findFirstOrThrow
   */
  export type PartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part findMany
   */
  export type PartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part create
   */
  export type PartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to create a Part.
     */
    data: XOR<PartCreateInput, PartUncheckedCreateInput>
  }

  /**
   * Part createMany
   */
  export type PartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parts.
     */
    data: PartCreateManyInput | PartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Part createManyAndReturn
   */
  export type PartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * The data used to create many Parts.
     */
    data: PartCreateManyInput | PartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Part update
   */
  export type PartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to update a Part.
     */
    data: XOR<PartUpdateInput, PartUncheckedUpdateInput>
    /**
     * Choose, which Part to update.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part updateMany
   */
  export type PartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to update.
     */
    limit?: number
  }

  /**
   * Part updateManyAndReturn
   */
  export type PartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to update.
     */
    limit?: number
  }

  /**
   * Part upsert
   */
  export type PartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The filter to search for the Part to update in case it exists.
     */
    where: PartWhereUniqueInput
    /**
     * In case the Part found by the `where` argument doesn't exist, create a new Part with this data.
     */
    create: XOR<PartCreateInput, PartUncheckedCreateInput>
    /**
     * In case the Part was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartUpdateInput, PartUncheckedUpdateInput>
  }

  /**
   * Part delete
   */
  export type PartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter which Part to delete.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part deleteMany
   */
  export type PartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parts to delete
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to delete.
     */
    limit?: number
  }

  /**
   * Part.asset_parts
   */
  export type Part$asset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    where?: AssetPartWhereInput
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    cursor?: AssetPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * Part without action
   */
  export type PartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
  }


  /**
   * Model AssetPart
   */

  export type AggregateAssetPart = {
    _count: AssetPartCountAggregateOutputType | null
    _avg: AssetPartAvgAggregateOutputType | null
    _sum: AssetPartSumAggregateOutputType | null
    _min: AssetPartMinAggregateOutputType | null
    _max: AssetPartMaxAggregateOutputType | null
  }

  export type AssetPartAvgAggregateOutputType = {
    asset_id: number | null
    part_id: number | null
    updated_by: number | null
  }

  export type AssetPartSumAggregateOutputType = {
    asset_id: number | null
    part_id: number | null
    updated_by: number | null
  }

  export type AssetPartMinAggregateOutputType = {
    asset_id: number | null
    part_id: number | null
    updated_at: Date | null
    updated_by: number | null
    part_operation: $Enums.PartOperation | null
  }

  export type AssetPartMaxAggregateOutputType = {
    asset_id: number | null
    part_id: number | null
    updated_at: Date | null
    updated_by: number | null
    part_operation: $Enums.PartOperation | null
  }

  export type AssetPartCountAggregateOutputType = {
    asset_id: number
    part_id: number
    updated_at: number
    updated_by: number
    part_operation: number
    _all: number
  }


  export type AssetPartAvgAggregateInputType = {
    asset_id?: true
    part_id?: true
    updated_by?: true
  }

  export type AssetPartSumAggregateInputType = {
    asset_id?: true
    part_id?: true
    updated_by?: true
  }

  export type AssetPartMinAggregateInputType = {
    asset_id?: true
    part_id?: true
    updated_at?: true
    updated_by?: true
    part_operation?: true
  }

  export type AssetPartMaxAggregateInputType = {
    asset_id?: true
    part_id?: true
    updated_at?: true
    updated_by?: true
    part_operation?: true
  }

  export type AssetPartCountAggregateInputType = {
    asset_id?: true
    part_id?: true
    updated_at?: true
    updated_by?: true
    part_operation?: true
    _all?: true
  }

  export type AssetPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetPart to aggregate.
     */
    where?: AssetPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetParts to fetch.
     */
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetParts
    **/
    _count?: true | AssetPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetPartMaxAggregateInputType
  }

  export type GetAssetPartAggregateType<T extends AssetPartAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetPart[P]>
      : GetScalarType<T[P], AggregateAssetPart[P]>
  }




  export type AssetPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetPartWhereInput
    orderBy?: AssetPartOrderByWithAggregationInput | AssetPartOrderByWithAggregationInput[]
    by: AssetPartScalarFieldEnum[] | AssetPartScalarFieldEnum
    having?: AssetPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetPartCountAggregateInputType | true
    _avg?: AssetPartAvgAggregateInputType
    _sum?: AssetPartSumAggregateInputType
    _min?: AssetPartMinAggregateInputType
    _max?: AssetPartMaxAggregateInputType
  }

  export type AssetPartGroupByOutputType = {
    asset_id: number
    part_id: number
    updated_at: Date
    updated_by: number
    part_operation: $Enums.PartOperation
    _count: AssetPartCountAggregateOutputType | null
    _avg: AssetPartAvgAggregateOutputType | null
    _sum: AssetPartSumAggregateOutputType | null
    _min: AssetPartMinAggregateOutputType | null
    _max: AssetPartMaxAggregateOutputType | null
  }

  type GetAssetPartGroupByPayload<T extends AssetPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetPartGroupByOutputType[P]>
            : GetScalarType<T[P], AssetPartGroupByOutputType[P]>
        }
      >
    >


  export type AssetPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    part_id?: boolean
    updated_at?: boolean
    updated_by?: boolean
    part_operation?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetPart"]>

  export type AssetPartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    part_id?: boolean
    updated_at?: boolean
    updated_by?: boolean
    part_operation?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetPart"]>

  export type AssetPartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    part_id?: boolean
    updated_at?: boolean
    updated_by?: boolean
    part_operation?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetPart"]>

  export type AssetPartSelectScalar = {
    asset_id?: boolean
    part_id?: boolean
    updated_at?: boolean
    updated_by?: boolean
    part_operation?: boolean
  }

  export type AssetPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"asset_id" | "part_id" | "updated_at" | "updated_by" | "part_operation", ExtArgs["result"]["assetPart"]>
  export type AssetPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetPartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetPartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssetPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetPart"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      part: Prisma.$PartPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      asset_id: number
      part_id: number
      updated_at: Date
      updated_by: number
      part_operation: $Enums.PartOperation
    }, ExtArgs["result"]["assetPart"]>
    composites: {}
  }

  type AssetPartGetPayload<S extends boolean | null | undefined | AssetPartDefaultArgs> = $Result.GetResult<Prisma.$AssetPartPayload, S>

  type AssetPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetPartCountAggregateInputType | true
    }

  export interface AssetPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetPart'], meta: { name: 'AssetPart' } }
    /**
     * Find zero or one AssetPart that matches the filter.
     * @param {AssetPartFindUniqueArgs} args - Arguments to find a AssetPart
     * @example
     * // Get one AssetPart
     * const assetPart = await prisma.assetPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetPartFindUniqueArgs>(args: SelectSubset<T, AssetPartFindUniqueArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetPartFindUniqueOrThrowArgs} args - Arguments to find a AssetPart
     * @example
     * // Get one AssetPart
     * const assetPart = await prisma.assetPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetPartFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartFindFirstArgs} args - Arguments to find a AssetPart
     * @example
     * // Get one AssetPart
     * const assetPart = await prisma.assetPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetPartFindFirstArgs>(args?: SelectSubset<T, AssetPartFindFirstArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartFindFirstOrThrowArgs} args - Arguments to find a AssetPart
     * @example
     * // Get one AssetPart
     * const assetPart = await prisma.assetPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetPartFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetParts
     * const assetParts = await prisma.assetPart.findMany()
     * 
     * // Get first 10 AssetParts
     * const assetParts = await prisma.assetPart.findMany({ take: 10 })
     * 
     * // Only select the `asset_id`
     * const assetPartWithAsset_idOnly = await prisma.assetPart.findMany({ select: { asset_id: true } })
     * 
     */
    findMany<T extends AssetPartFindManyArgs>(args?: SelectSubset<T, AssetPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetPart.
     * @param {AssetPartCreateArgs} args - Arguments to create a AssetPart.
     * @example
     * // Create one AssetPart
     * const AssetPart = await prisma.assetPart.create({
     *   data: {
     *     // ... data to create a AssetPart
     *   }
     * })
     * 
     */
    create<T extends AssetPartCreateArgs>(args: SelectSubset<T, AssetPartCreateArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetParts.
     * @param {AssetPartCreateManyArgs} args - Arguments to create many AssetParts.
     * @example
     * // Create many AssetParts
     * const assetPart = await prisma.assetPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetPartCreateManyArgs>(args?: SelectSubset<T, AssetPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetParts and returns the data saved in the database.
     * @param {AssetPartCreateManyAndReturnArgs} args - Arguments to create many AssetParts.
     * @example
     * // Create many AssetParts
     * const assetPart = await prisma.assetPart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetParts and only return the `asset_id`
     * const assetPartWithAsset_idOnly = await prisma.assetPart.createManyAndReturn({
     *   select: { asset_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetPartCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetPartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetPart.
     * @param {AssetPartDeleteArgs} args - Arguments to delete one AssetPart.
     * @example
     * // Delete one AssetPart
     * const AssetPart = await prisma.assetPart.delete({
     *   where: {
     *     // ... filter to delete one AssetPart
     *   }
     * })
     * 
     */
    delete<T extends AssetPartDeleteArgs>(args: SelectSubset<T, AssetPartDeleteArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetPart.
     * @param {AssetPartUpdateArgs} args - Arguments to update one AssetPart.
     * @example
     * // Update one AssetPart
     * const assetPart = await prisma.assetPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetPartUpdateArgs>(args: SelectSubset<T, AssetPartUpdateArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetParts.
     * @param {AssetPartDeleteManyArgs} args - Arguments to filter AssetParts to delete.
     * @example
     * // Delete a few AssetParts
     * const { count } = await prisma.assetPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetPartDeleteManyArgs>(args?: SelectSubset<T, AssetPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetParts
     * const assetPart = await prisma.assetPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetPartUpdateManyArgs>(args: SelectSubset<T, AssetPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetParts and returns the data updated in the database.
     * @param {AssetPartUpdateManyAndReturnArgs} args - Arguments to update many AssetParts.
     * @example
     * // Update many AssetParts
     * const assetPart = await prisma.assetPart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetParts and only return the `asset_id`
     * const assetPartWithAsset_idOnly = await prisma.assetPart.updateManyAndReturn({
     *   select: { asset_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetPartUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetPartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetPart.
     * @param {AssetPartUpsertArgs} args - Arguments to update or create a AssetPart.
     * @example
     * // Update or create a AssetPart
     * const assetPart = await prisma.assetPart.upsert({
     *   create: {
     *     // ... data to create a AssetPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetPart we want to update
     *   }
     * })
     */
    upsert<T extends AssetPartUpsertArgs>(args: SelectSubset<T, AssetPartUpsertArgs<ExtArgs>>): Prisma__AssetPartClient<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartCountArgs} args - Arguments to filter AssetParts to count.
     * @example
     * // Count the number of AssetParts
     * const count = await prisma.assetPart.count({
     *   where: {
     *     // ... the filter for the AssetParts we want to count
     *   }
     * })
    **/
    count<T extends AssetPartCountArgs>(
      args?: Subset<T, AssetPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetPartAggregateArgs>(args: Subset<T, AssetPartAggregateArgs>): Prisma.PrismaPromise<GetAssetPartAggregateType<T>>

    /**
     * Group by AssetPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetPartGroupByArgs['orderBy'] }
        : { orderBy?: AssetPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetPart model
   */
  readonly fields: AssetPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetPart model
   */
  interface AssetPartFieldRefs {
    readonly asset_id: FieldRef<"AssetPart", 'Int'>
    readonly part_id: FieldRef<"AssetPart", 'Int'>
    readonly updated_at: FieldRef<"AssetPart", 'DateTime'>
    readonly updated_by: FieldRef<"AssetPart", 'Int'>
    readonly part_operation: FieldRef<"AssetPart", 'PartOperation'>
  }
    

  // Custom InputTypes
  /**
   * AssetPart findUnique
   */
  export type AssetPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter, which AssetPart to fetch.
     */
    where: AssetPartWhereUniqueInput
  }

  /**
   * AssetPart findUniqueOrThrow
   */
  export type AssetPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter, which AssetPart to fetch.
     */
    where: AssetPartWhereUniqueInput
  }

  /**
   * AssetPart findFirst
   */
  export type AssetPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter, which AssetPart to fetch.
     */
    where?: AssetPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetParts to fetch.
     */
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetParts.
     */
    cursor?: AssetPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetParts.
     */
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * AssetPart findFirstOrThrow
   */
  export type AssetPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter, which AssetPart to fetch.
     */
    where?: AssetPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetParts to fetch.
     */
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetParts.
     */
    cursor?: AssetPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetParts.
     */
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * AssetPart findMany
   */
  export type AssetPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter, which AssetParts to fetch.
     */
    where?: AssetPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetParts to fetch.
     */
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetParts.
     */
    cursor?: AssetPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetParts.
     */
    skip?: number
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * AssetPart create
   */
  export type AssetPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetPart.
     */
    data: XOR<AssetPartCreateInput, AssetPartUncheckedCreateInput>
  }

  /**
   * AssetPart createMany
   */
  export type AssetPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetParts.
     */
    data: AssetPartCreateManyInput | AssetPartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetPart createManyAndReturn
   */
  export type AssetPartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * The data used to create many AssetParts.
     */
    data: AssetPartCreateManyInput | AssetPartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetPart update
   */
  export type AssetPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetPart.
     */
    data: XOR<AssetPartUpdateInput, AssetPartUncheckedUpdateInput>
    /**
     * Choose, which AssetPart to update.
     */
    where: AssetPartWhereUniqueInput
  }

  /**
   * AssetPart updateMany
   */
  export type AssetPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetParts.
     */
    data: XOR<AssetPartUpdateManyMutationInput, AssetPartUncheckedUpdateManyInput>
    /**
     * Filter which AssetParts to update
     */
    where?: AssetPartWhereInput
    /**
     * Limit how many AssetParts to update.
     */
    limit?: number
  }

  /**
   * AssetPart updateManyAndReturn
   */
  export type AssetPartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * The data used to update AssetParts.
     */
    data: XOR<AssetPartUpdateManyMutationInput, AssetPartUncheckedUpdateManyInput>
    /**
     * Filter which AssetParts to update
     */
    where?: AssetPartWhereInput
    /**
     * Limit how many AssetParts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetPart upsert
   */
  export type AssetPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetPart to update in case it exists.
     */
    where: AssetPartWhereUniqueInput
    /**
     * In case the AssetPart found by the `where` argument doesn't exist, create a new AssetPart with this data.
     */
    create: XOR<AssetPartCreateInput, AssetPartUncheckedCreateInput>
    /**
     * In case the AssetPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetPartUpdateInput, AssetPartUncheckedUpdateInput>
  }

  /**
   * AssetPart delete
   */
  export type AssetPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    /**
     * Filter which AssetPart to delete.
     */
    where: AssetPartWhereUniqueInput
  }

  /**
   * AssetPart deleteMany
   */
  export type AssetPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetParts to delete
     */
    where?: AssetPartWhereInput
    /**
     * Limit how many AssetParts to delete.
     */
    limit?: number
  }

  /**
   * AssetPart without action
   */
  export type AssetPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
  }

  export type TransferSumAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: number | null
    transfer_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: number | null
    transfer_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    transfer_number: number
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes: number
    created_at: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
  }

  export type TransferSumAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    transfer_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    transfer_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    transfer_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes: string | null
    created_at: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transfer_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    asset_transfers?: boolean | Transfer$asset_transfersArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transfer_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transfer_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    transfer_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transfer_number" | "origin_id" | "destination_id" | "transporter_id" | "created_by_id" | "notes" | "created_at", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    asset_transfers?: boolean | Transfer$asset_transfersArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      origin: Prisma.$WarehousePayload<ExtArgs>
      destination: Prisma.$WarehousePayload<ExtArgs>
      transporter: Prisma.$OrganizationPayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs>
      asset_transfers: Prisma.$AssetTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transfer_number: string
      origin_id: number
      destination_id: number
      transporter_id: number
      created_by_id: number
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destination<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transporter<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset_transfers<T extends Transfer$asset_transfersArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$asset_transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'Int'>
    readonly transfer_number: FieldRef<"Transfer", 'String'>
    readonly origin_id: FieldRef<"Transfer", 'Int'>
    readonly destination_id: FieldRef<"Transfer", 'Int'>
    readonly transporter_id: FieldRef<"Transfer", 'Int'>
    readonly created_by_id: FieldRef<"Transfer", 'Int'>
    readonly notes: FieldRef<"Transfer", 'String'>
    readonly created_at: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.asset_transfers
   */
  export type Transfer$asset_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    where?: AssetTransferWhereInput
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    cursor?: AssetTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetTransferScalarFieldEnum | AssetTransferScalarFieldEnum[]
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model AssetTransfer
   */

  export type AggregateAssetTransfer = {
    _count: AssetTransferCountAggregateOutputType | null
    _avg: AssetTransferAvgAggregateOutputType | null
    _sum: AssetTransferSumAggregateOutputType | null
    _min: AssetTransferMinAggregateOutputType | null
    _max: AssetTransferMaxAggregateOutputType | null
  }

  export type AssetTransferAvgAggregateOutputType = {
    asset_id: number | null
    transfer_id: number | null
  }

  export type AssetTransferSumAggregateOutputType = {
    asset_id: number | null
    transfer_id: number | null
  }

  export type AssetTransferMinAggregateOutputType = {
    asset_id: number | null
    transfer_id: number | null
  }

  export type AssetTransferMaxAggregateOutputType = {
    asset_id: number | null
    transfer_id: number | null
  }

  export type AssetTransferCountAggregateOutputType = {
    asset_id: number
    transfer_id: number
    _all: number
  }


  export type AssetTransferAvgAggregateInputType = {
    asset_id?: true
    transfer_id?: true
  }

  export type AssetTransferSumAggregateInputType = {
    asset_id?: true
    transfer_id?: true
  }

  export type AssetTransferMinAggregateInputType = {
    asset_id?: true
    transfer_id?: true
  }

  export type AssetTransferMaxAggregateInputType = {
    asset_id?: true
    transfer_id?: true
  }

  export type AssetTransferCountAggregateInputType = {
    asset_id?: true
    transfer_id?: true
    _all?: true
  }

  export type AssetTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetTransfer to aggregate.
     */
    where?: AssetTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTransfers to fetch.
     */
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetTransfers
    **/
    _count?: true | AssetTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetTransferMaxAggregateInputType
  }

  export type GetAssetTransferAggregateType<T extends AssetTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetTransfer[P]>
      : GetScalarType<T[P], AggregateAssetTransfer[P]>
  }




  export type AssetTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTransferWhereInput
    orderBy?: AssetTransferOrderByWithAggregationInput | AssetTransferOrderByWithAggregationInput[]
    by: AssetTransferScalarFieldEnum[] | AssetTransferScalarFieldEnum
    having?: AssetTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetTransferCountAggregateInputType | true
    _avg?: AssetTransferAvgAggregateInputType
    _sum?: AssetTransferSumAggregateInputType
    _min?: AssetTransferMinAggregateInputType
    _max?: AssetTransferMaxAggregateInputType
  }

  export type AssetTransferGroupByOutputType = {
    asset_id: number
    transfer_id: number
    _count: AssetTransferCountAggregateOutputType | null
    _avg: AssetTransferAvgAggregateOutputType | null
    _sum: AssetTransferSumAggregateOutputType | null
    _min: AssetTransferMinAggregateOutputType | null
    _max: AssetTransferMaxAggregateOutputType | null
  }

  type GetAssetTransferGroupByPayload<T extends AssetTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetTransferGroupByOutputType[P]>
            : GetScalarType<T[P], AssetTransferGroupByOutputType[P]>
        }
      >
    >


  export type AssetTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    transfer_id?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTransfer"]>

  export type AssetTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    transfer_id?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTransfer"]>

  export type AssetTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    asset_id?: boolean
    transfer_id?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTransfer"]>

  export type AssetTransferSelectScalar = {
    asset_id?: boolean
    transfer_id?: boolean
  }

  export type AssetTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"asset_id" | "transfer_id", ExtArgs["result"]["assetTransfer"]>
  export type AssetTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type AssetTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type AssetTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }

  export type $AssetTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetTransfer"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      transfer: Prisma.$TransferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      asset_id: number
      transfer_id: number
    }, ExtArgs["result"]["assetTransfer"]>
    composites: {}
  }

  type AssetTransferGetPayload<S extends boolean | null | undefined | AssetTransferDefaultArgs> = $Result.GetResult<Prisma.$AssetTransferPayload, S>

  type AssetTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetTransferCountAggregateInputType | true
    }

  export interface AssetTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetTransfer'], meta: { name: 'AssetTransfer' } }
    /**
     * Find zero or one AssetTransfer that matches the filter.
     * @param {AssetTransferFindUniqueArgs} args - Arguments to find a AssetTransfer
     * @example
     * // Get one AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetTransferFindUniqueArgs>(args: SelectSubset<T, AssetTransferFindUniqueArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetTransferFindUniqueOrThrowArgs} args - Arguments to find a AssetTransfer
     * @example
     * // Get one AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferFindFirstArgs} args - Arguments to find a AssetTransfer
     * @example
     * // Get one AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetTransferFindFirstArgs>(args?: SelectSubset<T, AssetTransferFindFirstArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferFindFirstOrThrowArgs} args - Arguments to find a AssetTransfer
     * @example
     * // Get one AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetTransfers
     * const assetTransfers = await prisma.assetTransfer.findMany()
     * 
     * // Get first 10 AssetTransfers
     * const assetTransfers = await prisma.assetTransfer.findMany({ take: 10 })
     * 
     * // Only select the `asset_id`
     * const assetTransferWithAsset_idOnly = await prisma.assetTransfer.findMany({ select: { asset_id: true } })
     * 
     */
    findMany<T extends AssetTransferFindManyArgs>(args?: SelectSubset<T, AssetTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetTransfer.
     * @param {AssetTransferCreateArgs} args - Arguments to create a AssetTransfer.
     * @example
     * // Create one AssetTransfer
     * const AssetTransfer = await prisma.assetTransfer.create({
     *   data: {
     *     // ... data to create a AssetTransfer
     *   }
     * })
     * 
     */
    create<T extends AssetTransferCreateArgs>(args: SelectSubset<T, AssetTransferCreateArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetTransfers.
     * @param {AssetTransferCreateManyArgs} args - Arguments to create many AssetTransfers.
     * @example
     * // Create many AssetTransfers
     * const assetTransfer = await prisma.assetTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetTransferCreateManyArgs>(args?: SelectSubset<T, AssetTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetTransfers and returns the data saved in the database.
     * @param {AssetTransferCreateManyAndReturnArgs} args - Arguments to create many AssetTransfers.
     * @example
     * // Create many AssetTransfers
     * const assetTransfer = await prisma.assetTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetTransfers and only return the `asset_id`
     * const assetTransferWithAsset_idOnly = await prisma.assetTransfer.createManyAndReturn({
     *   select: { asset_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetTransfer.
     * @param {AssetTransferDeleteArgs} args - Arguments to delete one AssetTransfer.
     * @example
     * // Delete one AssetTransfer
     * const AssetTransfer = await prisma.assetTransfer.delete({
     *   where: {
     *     // ... filter to delete one AssetTransfer
     *   }
     * })
     * 
     */
    delete<T extends AssetTransferDeleteArgs>(args: SelectSubset<T, AssetTransferDeleteArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetTransfer.
     * @param {AssetTransferUpdateArgs} args - Arguments to update one AssetTransfer.
     * @example
     * // Update one AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetTransferUpdateArgs>(args: SelectSubset<T, AssetTransferUpdateArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetTransfers.
     * @param {AssetTransferDeleteManyArgs} args - Arguments to filter AssetTransfers to delete.
     * @example
     * // Delete a few AssetTransfers
     * const { count } = await prisma.assetTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetTransferDeleteManyArgs>(args?: SelectSubset<T, AssetTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetTransfers
     * const assetTransfer = await prisma.assetTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetTransferUpdateManyArgs>(args: SelectSubset<T, AssetTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetTransfers and returns the data updated in the database.
     * @param {AssetTransferUpdateManyAndReturnArgs} args - Arguments to update many AssetTransfers.
     * @example
     * // Update many AssetTransfers
     * const assetTransfer = await prisma.assetTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetTransfers and only return the `asset_id`
     * const assetTransferWithAsset_idOnly = await prisma.assetTransfer.updateManyAndReturn({
     *   select: { asset_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetTransfer.
     * @param {AssetTransferUpsertArgs} args - Arguments to update or create a AssetTransfer.
     * @example
     * // Update or create a AssetTransfer
     * const assetTransfer = await prisma.assetTransfer.upsert({
     *   create: {
     *     // ... data to create a AssetTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetTransfer we want to update
     *   }
     * })
     */
    upsert<T extends AssetTransferUpsertArgs>(args: SelectSubset<T, AssetTransferUpsertArgs<ExtArgs>>): Prisma__AssetTransferClient<$Result.GetResult<Prisma.$AssetTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferCountArgs} args - Arguments to filter AssetTransfers to count.
     * @example
     * // Count the number of AssetTransfers
     * const count = await prisma.assetTransfer.count({
     *   where: {
     *     // ... the filter for the AssetTransfers we want to count
     *   }
     * })
    **/
    count<T extends AssetTransferCountArgs>(
      args?: Subset<T, AssetTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetTransferAggregateArgs>(args: Subset<T, AssetTransferAggregateArgs>): Prisma.PrismaPromise<GetAssetTransferAggregateType<T>>

    /**
     * Group by AssetTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetTransferGroupByArgs['orderBy'] }
        : { orderBy?: AssetTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetTransfer model
   */
  readonly fields: AssetTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetTransfer model
   */
  interface AssetTransferFieldRefs {
    readonly asset_id: FieldRef<"AssetTransfer", 'Int'>
    readonly transfer_id: FieldRef<"AssetTransfer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AssetTransfer findUnique
   */
  export type AssetTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter, which AssetTransfer to fetch.
     */
    where: AssetTransferWhereUniqueInput
  }

  /**
   * AssetTransfer findUniqueOrThrow
   */
  export type AssetTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter, which AssetTransfer to fetch.
     */
    where: AssetTransferWhereUniqueInput
  }

  /**
   * AssetTransfer findFirst
   */
  export type AssetTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter, which AssetTransfer to fetch.
     */
    where?: AssetTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTransfers to fetch.
     */
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetTransfers.
     */
    cursor?: AssetTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetTransfers.
     */
    distinct?: AssetTransferScalarFieldEnum | AssetTransferScalarFieldEnum[]
  }

  /**
   * AssetTransfer findFirstOrThrow
   */
  export type AssetTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter, which AssetTransfer to fetch.
     */
    where?: AssetTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTransfers to fetch.
     */
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetTransfers.
     */
    cursor?: AssetTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetTransfers.
     */
    distinct?: AssetTransferScalarFieldEnum | AssetTransferScalarFieldEnum[]
  }

  /**
   * AssetTransfer findMany
   */
  export type AssetTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter, which AssetTransfers to fetch.
     */
    where?: AssetTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTransfers to fetch.
     */
    orderBy?: AssetTransferOrderByWithRelationInput | AssetTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetTransfers.
     */
    cursor?: AssetTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTransfers.
     */
    skip?: number
    distinct?: AssetTransferScalarFieldEnum | AssetTransferScalarFieldEnum[]
  }

  /**
   * AssetTransfer create
   */
  export type AssetTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetTransfer.
     */
    data: XOR<AssetTransferCreateInput, AssetTransferUncheckedCreateInput>
  }

  /**
   * AssetTransfer createMany
   */
  export type AssetTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetTransfers.
     */
    data: AssetTransferCreateManyInput | AssetTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetTransfer createManyAndReturn
   */
  export type AssetTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * The data used to create many AssetTransfers.
     */
    data: AssetTransferCreateManyInput | AssetTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetTransfer update
   */
  export type AssetTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetTransfer.
     */
    data: XOR<AssetTransferUpdateInput, AssetTransferUncheckedUpdateInput>
    /**
     * Choose, which AssetTransfer to update.
     */
    where: AssetTransferWhereUniqueInput
  }

  /**
   * AssetTransfer updateMany
   */
  export type AssetTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetTransfers.
     */
    data: XOR<AssetTransferUpdateManyMutationInput, AssetTransferUncheckedUpdateManyInput>
    /**
     * Filter which AssetTransfers to update
     */
    where?: AssetTransferWhereInput
    /**
     * Limit how many AssetTransfers to update.
     */
    limit?: number
  }

  /**
   * AssetTransfer updateManyAndReturn
   */
  export type AssetTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * The data used to update AssetTransfers.
     */
    data: XOR<AssetTransferUpdateManyMutationInput, AssetTransferUncheckedUpdateManyInput>
    /**
     * Filter which AssetTransfers to update
     */
    where?: AssetTransferWhereInput
    /**
     * Limit how many AssetTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetTransfer upsert
   */
  export type AssetTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetTransfer to update in case it exists.
     */
    where: AssetTransferWhereUniqueInput
    /**
     * In case the AssetTransfer found by the `where` argument doesn't exist, create a new AssetTransfer with this data.
     */
    create: XOR<AssetTransferCreateInput, AssetTransferUncheckedCreateInput>
    /**
     * In case the AssetTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetTransferUpdateInput, AssetTransferUncheckedUpdateInput>
  }

  /**
   * AssetTransfer delete
   */
  export type AssetTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
    /**
     * Filter which AssetTransfer to delete.
     */
    where: AssetTransferWhereUniqueInput
  }

  /**
   * AssetTransfer deleteMany
   */
  export type AssetTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetTransfers to delete
     */
    where?: AssetTransferWhereInput
    /**
     * Limit how many AssetTransfers to delete.
     */
    limit?: number
  }

  /**
   * AssetTransfer without action
   */
  export type AssetTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTransfer
     */
    select?: AssetTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTransfer
     */
    omit?: AssetTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTransferInclude<ExtArgs> | null
  }


  /**
   * Model Arrival
   */

  export type AggregateArrival = {
    _count: ArrivalCountAggregateOutputType | null
    _avg: ArrivalAvgAggregateOutputType | null
    _sum: ArrivalSumAggregateOutputType | null
    _min: ArrivalMinAggregateOutputType | null
    _max: ArrivalMaxAggregateOutputType | null
  }

  export type ArrivalAvgAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
  }

  export type ArrivalSumAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
  }

  export type ArrivalMinAggregateOutputType = {
    id: number | null
    arrival_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type ArrivalMaxAggregateOutputType = {
    id: number | null
    arrival_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type ArrivalCountAggregateOutputType = {
    id: number
    arrival_number: number
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes: number
    created_at: number
    _all: number
  }


  export type ArrivalAvgAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
  }

  export type ArrivalSumAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
  }

  export type ArrivalMinAggregateInputType = {
    id?: true
    arrival_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
  }

  export type ArrivalMaxAggregateInputType = {
    id?: true
    arrival_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
  }

  export type ArrivalCountAggregateInputType = {
    id?: true
    arrival_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type ArrivalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Arrival to aggregate.
     */
    where?: ArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Arrivals
    **/
    _count?: true | ArrivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArrivalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArrivalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArrivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArrivalMaxAggregateInputType
  }

  export type GetArrivalAggregateType<T extends ArrivalAggregateArgs> = {
        [P in keyof T & keyof AggregateArrival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArrival[P]>
      : GetScalarType<T[P], AggregateArrival[P]>
  }




  export type ArrivalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalWhereInput
    orderBy?: ArrivalOrderByWithAggregationInput | ArrivalOrderByWithAggregationInput[]
    by: ArrivalScalarFieldEnum[] | ArrivalScalarFieldEnum
    having?: ArrivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArrivalCountAggregateInputType | true
    _avg?: ArrivalAvgAggregateInputType
    _sum?: ArrivalSumAggregateInputType
    _min?: ArrivalMinAggregateInputType
    _max?: ArrivalMaxAggregateInputType
  }

  export type ArrivalGroupByOutputType = {
    id: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes: string | null
    created_at: Date
    _count: ArrivalCountAggregateOutputType | null
    _avg: ArrivalAvgAggregateOutputType | null
    _sum: ArrivalSumAggregateOutputType | null
    _min: ArrivalMinAggregateOutputType | null
    _max: ArrivalMaxAggregateOutputType | null
  }

  type GetArrivalGroupByPayload<T extends ArrivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArrivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArrivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArrivalGroupByOutputType[P]>
            : GetScalarType<T[P], ArrivalGroupByOutputType[P]>
        }
      >
    >


  export type ArrivalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrival_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Arrival$assetsArgs<ExtArgs>
    _count?: boolean | ArrivalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrival"]>

  export type ArrivalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrival_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrival"]>

  export type ArrivalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrival_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrival"]>

  export type ArrivalSelectScalar = {
    id?: boolean
    arrival_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type ArrivalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrival_number" | "origin_id" | "destination_id" | "transporter_id" | "created_by_id" | "notes" | "created_at", ExtArgs["result"]["arrival"]>
  export type ArrivalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Arrival$assetsArgs<ExtArgs>
    _count?: boolean | ArrivalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArrivalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ArrivalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | OrganizationDefaultArgs<ExtArgs>
    destination?: boolean | WarehouseDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ArrivalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Arrival"
    objects: {
      origin: Prisma.$OrganizationPayload<ExtArgs>
      destination: Prisma.$WarehousePayload<ExtArgs>
      transporter: Prisma.$OrganizationPayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrival_number: string
      origin_id: number
      destination_id: number
      transporter_id: number
      created_by_id: number
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["arrival"]>
    composites: {}
  }

  type ArrivalGetPayload<S extends boolean | null | undefined | ArrivalDefaultArgs> = $Result.GetResult<Prisma.$ArrivalPayload, S>

  type ArrivalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArrivalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArrivalCountAggregateInputType | true
    }

  export interface ArrivalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Arrival'], meta: { name: 'Arrival' } }
    /**
     * Find zero or one Arrival that matches the filter.
     * @param {ArrivalFindUniqueArgs} args - Arguments to find a Arrival
     * @example
     * // Get one Arrival
     * const arrival = await prisma.arrival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArrivalFindUniqueArgs>(args: SelectSubset<T, ArrivalFindUniqueArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Arrival that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArrivalFindUniqueOrThrowArgs} args - Arguments to find a Arrival
     * @example
     * // Get one Arrival
     * const arrival = await prisma.arrival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArrivalFindUniqueOrThrowArgs>(args: SelectSubset<T, ArrivalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arrival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalFindFirstArgs} args - Arguments to find a Arrival
     * @example
     * // Get one Arrival
     * const arrival = await prisma.arrival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArrivalFindFirstArgs>(args?: SelectSubset<T, ArrivalFindFirstArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arrival that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalFindFirstOrThrowArgs} args - Arguments to find a Arrival
     * @example
     * // Get one Arrival
     * const arrival = await prisma.arrival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArrivalFindFirstOrThrowArgs>(args?: SelectSubset<T, ArrivalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Arrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Arrivals
     * const arrivals = await prisma.arrival.findMany()
     * 
     * // Get first 10 Arrivals
     * const arrivals = await prisma.arrival.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const arrivalWithIdOnly = await prisma.arrival.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArrivalFindManyArgs>(args?: SelectSubset<T, ArrivalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Arrival.
     * @param {ArrivalCreateArgs} args - Arguments to create a Arrival.
     * @example
     * // Create one Arrival
     * const Arrival = await prisma.arrival.create({
     *   data: {
     *     // ... data to create a Arrival
     *   }
     * })
     * 
     */
    create<T extends ArrivalCreateArgs>(args: SelectSubset<T, ArrivalCreateArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Arrivals.
     * @param {ArrivalCreateManyArgs} args - Arguments to create many Arrivals.
     * @example
     * // Create many Arrivals
     * const arrival = await prisma.arrival.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArrivalCreateManyArgs>(args?: SelectSubset<T, ArrivalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Arrivals and returns the data saved in the database.
     * @param {ArrivalCreateManyAndReturnArgs} args - Arguments to create many Arrivals.
     * @example
     * // Create many Arrivals
     * const arrival = await prisma.arrival.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Arrivals and only return the `id`
     * const arrivalWithIdOnly = await prisma.arrival.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArrivalCreateManyAndReturnArgs>(args?: SelectSubset<T, ArrivalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Arrival.
     * @param {ArrivalDeleteArgs} args - Arguments to delete one Arrival.
     * @example
     * // Delete one Arrival
     * const Arrival = await prisma.arrival.delete({
     *   where: {
     *     // ... filter to delete one Arrival
     *   }
     * })
     * 
     */
    delete<T extends ArrivalDeleteArgs>(args: SelectSubset<T, ArrivalDeleteArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Arrival.
     * @param {ArrivalUpdateArgs} args - Arguments to update one Arrival.
     * @example
     * // Update one Arrival
     * const arrival = await prisma.arrival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArrivalUpdateArgs>(args: SelectSubset<T, ArrivalUpdateArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Arrivals.
     * @param {ArrivalDeleteManyArgs} args - Arguments to filter Arrivals to delete.
     * @example
     * // Delete a few Arrivals
     * const { count } = await prisma.arrival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArrivalDeleteManyArgs>(args?: SelectSubset<T, ArrivalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Arrivals
     * const arrival = await prisma.arrival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArrivalUpdateManyArgs>(args: SelectSubset<T, ArrivalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arrivals and returns the data updated in the database.
     * @param {ArrivalUpdateManyAndReturnArgs} args - Arguments to update many Arrivals.
     * @example
     * // Update many Arrivals
     * const arrival = await prisma.arrival.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Arrivals and only return the `id`
     * const arrivalWithIdOnly = await prisma.arrival.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArrivalUpdateManyAndReturnArgs>(args: SelectSubset<T, ArrivalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Arrival.
     * @param {ArrivalUpsertArgs} args - Arguments to update or create a Arrival.
     * @example
     * // Update or create a Arrival
     * const arrival = await prisma.arrival.upsert({
     *   create: {
     *     // ... data to create a Arrival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Arrival we want to update
     *   }
     * })
     */
    upsert<T extends ArrivalUpsertArgs>(args: SelectSubset<T, ArrivalUpsertArgs<ExtArgs>>): Prisma__ArrivalClient<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalCountArgs} args - Arguments to filter Arrivals to count.
     * @example
     * // Count the number of Arrivals
     * const count = await prisma.arrival.count({
     *   where: {
     *     // ... the filter for the Arrivals we want to count
     *   }
     * })
    **/
    count<T extends ArrivalCountArgs>(
      args?: Subset<T, ArrivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArrivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Arrival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArrivalAggregateArgs>(args: Subset<T, ArrivalAggregateArgs>): Prisma.PrismaPromise<GetArrivalAggregateType<T>>

    /**
     * Group by Arrival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArrivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArrivalGroupByArgs['orderBy'] }
        : { orderBy?: ArrivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArrivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArrivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Arrival model
   */
  readonly fields: ArrivalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Arrival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArrivalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destination<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transporter<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends Arrival$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Arrival$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Arrival model
   */
  interface ArrivalFieldRefs {
    readonly id: FieldRef<"Arrival", 'Int'>
    readonly arrival_number: FieldRef<"Arrival", 'String'>
    readonly origin_id: FieldRef<"Arrival", 'Int'>
    readonly destination_id: FieldRef<"Arrival", 'Int'>
    readonly transporter_id: FieldRef<"Arrival", 'Int'>
    readonly created_by_id: FieldRef<"Arrival", 'Int'>
    readonly notes: FieldRef<"Arrival", 'String'>
    readonly created_at: FieldRef<"Arrival", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Arrival findUnique
   */
  export type ArrivalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter, which Arrival to fetch.
     */
    where: ArrivalWhereUniqueInput
  }

  /**
   * Arrival findUniqueOrThrow
   */
  export type ArrivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter, which Arrival to fetch.
     */
    where: ArrivalWhereUniqueInput
  }

  /**
   * Arrival findFirst
   */
  export type ArrivalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter, which Arrival to fetch.
     */
    where?: ArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arrivals.
     */
    cursor?: ArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arrivals.
     */
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Arrival findFirstOrThrow
   */
  export type ArrivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter, which Arrival to fetch.
     */
    where?: ArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arrivals.
     */
    cursor?: ArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arrivals.
     */
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Arrival findMany
   */
  export type ArrivalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where?: ArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Arrivals.
     */
    cursor?: ArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Arrival create
   */
  export type ArrivalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * The data needed to create a Arrival.
     */
    data: XOR<ArrivalCreateInput, ArrivalUncheckedCreateInput>
  }

  /**
   * Arrival createMany
   */
  export type ArrivalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Arrivals.
     */
    data: ArrivalCreateManyInput | ArrivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Arrival createManyAndReturn
   */
  export type ArrivalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * The data used to create many Arrivals.
     */
    data: ArrivalCreateManyInput | ArrivalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Arrival update
   */
  export type ArrivalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * The data needed to update a Arrival.
     */
    data: XOR<ArrivalUpdateInput, ArrivalUncheckedUpdateInput>
    /**
     * Choose, which Arrival to update.
     */
    where: ArrivalWhereUniqueInput
  }

  /**
   * Arrival updateMany
   */
  export type ArrivalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Arrivals.
     */
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyInput>
    /**
     * Filter which Arrivals to update
     */
    where?: ArrivalWhereInput
    /**
     * Limit how many Arrivals to update.
     */
    limit?: number
  }

  /**
   * Arrival updateManyAndReturn
   */
  export type ArrivalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * The data used to update Arrivals.
     */
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyInput>
    /**
     * Filter which Arrivals to update
     */
    where?: ArrivalWhereInput
    /**
     * Limit how many Arrivals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Arrival upsert
   */
  export type ArrivalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * The filter to search for the Arrival to update in case it exists.
     */
    where: ArrivalWhereUniqueInput
    /**
     * In case the Arrival found by the `where` argument doesn't exist, create a new Arrival with this data.
     */
    create: XOR<ArrivalCreateInput, ArrivalUncheckedCreateInput>
    /**
     * In case the Arrival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArrivalUpdateInput, ArrivalUncheckedUpdateInput>
  }

  /**
   * Arrival delete
   */
  export type ArrivalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    /**
     * Filter which Arrival to delete.
     */
    where: ArrivalWhereUniqueInput
  }

  /**
   * Arrival deleteMany
   */
  export type ArrivalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Arrivals to delete
     */
    where?: ArrivalWhereInput
    /**
     * Limit how many Arrivals to delete.
     */
    limit?: number
  }

  /**
   * Arrival.assets
   */
  export type Arrival$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Arrival without action
   */
  export type ArrivalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
  }


  /**
   * Model Departure
   */

  export type AggregateDeparture = {
    _count: DepartureCountAggregateOutputType | null
    _avg: DepartureAvgAggregateOutputType | null
    _sum: DepartureSumAggregateOutputType | null
    _min: DepartureMinAggregateOutputType | null
    _max: DepartureMaxAggregateOutputType | null
  }

  export type DepartureAvgAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    sales_representative_id: number | null
  }

  export type DepartureSumAggregateOutputType = {
    id: number | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    sales_representative_id: number | null
  }

  export type DepartureMinAggregateOutputType = {
    id: number | null
    departure_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    sales_representative_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type DepartureMaxAggregateOutputType = {
    id: number | null
    departure_number: string | null
    origin_id: number | null
    destination_id: number | null
    transporter_id: number | null
    created_by_id: number | null
    sales_representative_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type DepartureCountAggregateOutputType = {
    id: number
    departure_number: number
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes: number
    created_at: number
    _all: number
  }


  export type DepartureAvgAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    sales_representative_id?: true
  }

  export type DepartureSumAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    sales_representative_id?: true
  }

  export type DepartureMinAggregateInputType = {
    id?: true
    departure_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    sales_representative_id?: true
    notes?: true
    created_at?: true
  }

  export type DepartureMaxAggregateInputType = {
    id?: true
    departure_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    sales_representative_id?: true
    notes?: true
    created_at?: true
  }

  export type DepartureCountAggregateInputType = {
    id?: true
    departure_number?: true
    origin_id?: true
    destination_id?: true
    transporter_id?: true
    created_by_id?: true
    sales_representative_id?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type DepartureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departure to aggregate.
     */
    where?: DepartureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departures to fetch.
     */
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departures
    **/
    _count?: true | DepartureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartureMaxAggregateInputType
  }

  export type GetDepartureAggregateType<T extends DepartureAggregateArgs> = {
        [P in keyof T & keyof AggregateDeparture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeparture[P]>
      : GetScalarType<T[P], AggregateDeparture[P]>
  }




  export type DepartureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithAggregationInput | DepartureOrderByWithAggregationInput[]
    by: DepartureScalarFieldEnum[] | DepartureScalarFieldEnum
    having?: DepartureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartureCountAggregateInputType | true
    _avg?: DepartureAvgAggregateInputType
    _sum?: DepartureSumAggregateInputType
    _min?: DepartureMinAggregateInputType
    _max?: DepartureMaxAggregateInputType
  }

  export type DepartureGroupByOutputType = {
    id: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes: string | null
    created_at: Date
    _count: DepartureCountAggregateOutputType | null
    _avg: DepartureAvgAggregateOutputType | null
    _sum: DepartureSumAggregateOutputType | null
    _min: DepartureMinAggregateOutputType | null
    _max: DepartureMaxAggregateOutputType | null
  }

  type GetDepartureGroupByPayload<T extends DepartureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartureGroupByOutputType[P]>
            : GetScalarType<T[P], DepartureGroupByOutputType[P]>
        }
      >
    >


  export type DepartureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departure_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    sales_representative_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Departure$assetsArgs<ExtArgs>
    _count?: boolean | DepartureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departure"]>

  export type DepartureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departure_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    sales_representative_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departure"]>

  export type DepartureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departure_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    sales_representative_id?: boolean
    notes?: boolean
    created_at?: boolean
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departure"]>

  export type DepartureSelectScalar = {
    id?: boolean
    departure_number?: boolean
    origin_id?: boolean
    destination_id?: boolean
    transporter_id?: boolean
    created_by_id?: boolean
    sales_representative_id?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type DepartureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departure_number" | "origin_id" | "destination_id" | "transporter_id" | "created_by_id" | "sales_representative_id" | "notes" | "created_at", ExtArgs["result"]["departure"]>
  export type DepartureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Departure$assetsArgs<ExtArgs>
    _count?: boolean | DepartureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | WarehouseDefaultArgs<ExtArgs>
    destination?: boolean | OrganizationDefaultArgs<ExtArgs>
    transporter?: boolean | OrganizationDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    sales_representative?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeparturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departure"
    objects: {
      origin: Prisma.$WarehousePayload<ExtArgs>
      destination: Prisma.$OrganizationPayload<ExtArgs>
      transporter: Prisma.$OrganizationPayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs>
      sales_representative: Prisma.$UserPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      departure_number: string
      origin_id: number
      destination_id: number
      transporter_id: number
      created_by_id: number
      sales_representative_id: number
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["departure"]>
    composites: {}
  }

  type DepartureGetPayload<S extends boolean | null | undefined | DepartureDefaultArgs> = $Result.GetResult<Prisma.$DeparturePayload, S>

  type DepartureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartureCountAggregateInputType | true
    }

  export interface DepartureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departure'], meta: { name: 'Departure' } }
    /**
     * Find zero or one Departure that matches the filter.
     * @param {DepartureFindUniqueArgs} args - Arguments to find a Departure
     * @example
     * // Get one Departure
     * const departure = await prisma.departure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartureFindUniqueArgs>(args: SelectSubset<T, DepartureFindUniqueArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartureFindUniqueOrThrowArgs} args - Arguments to find a Departure
     * @example
     * // Get one Departure
     * const departure = await prisma.departure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartureFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureFindFirstArgs} args - Arguments to find a Departure
     * @example
     * // Get one Departure
     * const departure = await prisma.departure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartureFindFirstArgs>(args?: SelectSubset<T, DepartureFindFirstArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureFindFirstOrThrowArgs} args - Arguments to find a Departure
     * @example
     * // Get one Departure
     * const departure = await prisma.departure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartureFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departures
     * const departures = await prisma.departure.findMany()
     * 
     * // Get first 10 Departures
     * const departures = await prisma.departure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departureWithIdOnly = await prisma.departure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartureFindManyArgs>(args?: SelectSubset<T, DepartureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departure.
     * @param {DepartureCreateArgs} args - Arguments to create a Departure.
     * @example
     * // Create one Departure
     * const Departure = await prisma.departure.create({
     *   data: {
     *     // ... data to create a Departure
     *   }
     * })
     * 
     */
    create<T extends DepartureCreateArgs>(args: SelectSubset<T, DepartureCreateArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departures.
     * @param {DepartureCreateManyArgs} args - Arguments to create many Departures.
     * @example
     * // Create many Departures
     * const departure = await prisma.departure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartureCreateManyArgs>(args?: SelectSubset<T, DepartureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departures and returns the data saved in the database.
     * @param {DepartureCreateManyAndReturnArgs} args - Arguments to create many Departures.
     * @example
     * // Create many Departures
     * const departure = await prisma.departure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departures and only return the `id`
     * const departureWithIdOnly = await prisma.departure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartureCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Departure.
     * @param {DepartureDeleteArgs} args - Arguments to delete one Departure.
     * @example
     * // Delete one Departure
     * const Departure = await prisma.departure.delete({
     *   where: {
     *     // ... filter to delete one Departure
     *   }
     * })
     * 
     */
    delete<T extends DepartureDeleteArgs>(args: SelectSubset<T, DepartureDeleteArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departure.
     * @param {DepartureUpdateArgs} args - Arguments to update one Departure.
     * @example
     * // Update one Departure
     * const departure = await prisma.departure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartureUpdateArgs>(args: SelectSubset<T, DepartureUpdateArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departures.
     * @param {DepartureDeleteManyArgs} args - Arguments to filter Departures to delete.
     * @example
     * // Delete a few Departures
     * const { count } = await prisma.departure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartureDeleteManyArgs>(args?: SelectSubset<T, DepartureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departures
     * const departure = await prisma.departure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartureUpdateManyArgs>(args: SelectSubset<T, DepartureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departures and returns the data updated in the database.
     * @param {DepartureUpdateManyAndReturnArgs} args - Arguments to update many Departures.
     * @example
     * // Update many Departures
     * const departure = await prisma.departure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departures and only return the `id`
     * const departureWithIdOnly = await prisma.departure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartureUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Departure.
     * @param {DepartureUpsertArgs} args - Arguments to update or create a Departure.
     * @example
     * // Update or create a Departure
     * const departure = await prisma.departure.upsert({
     *   create: {
     *     // ... data to create a Departure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departure we want to update
     *   }
     * })
     */
    upsert<T extends DepartureUpsertArgs>(args: SelectSubset<T, DepartureUpsertArgs<ExtArgs>>): Prisma__DepartureClient<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureCountArgs} args - Arguments to filter Departures to count.
     * @example
     * // Count the number of Departures
     * const count = await prisma.departure.count({
     *   where: {
     *     // ... the filter for the Departures we want to count
     *   }
     * })
    **/
    count<T extends DepartureCountArgs>(
      args?: Subset<T, DepartureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartureAggregateArgs>(args: Subset<T, DepartureAggregateArgs>): Prisma.PrismaPromise<GetDepartureAggregateType<T>>

    /**
     * Group by Departure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartureGroupByArgs['orderBy'] }
        : { orderBy?: DepartureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departure model
   */
  readonly fields: DepartureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destination<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transporter<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales_representative<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends Departure$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Departure$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departure model
   */
  interface DepartureFieldRefs {
    readonly id: FieldRef<"Departure", 'Int'>
    readonly departure_number: FieldRef<"Departure", 'String'>
    readonly origin_id: FieldRef<"Departure", 'Int'>
    readonly destination_id: FieldRef<"Departure", 'Int'>
    readonly transporter_id: FieldRef<"Departure", 'Int'>
    readonly created_by_id: FieldRef<"Departure", 'Int'>
    readonly sales_representative_id: FieldRef<"Departure", 'Int'>
    readonly notes: FieldRef<"Departure", 'String'>
    readonly created_at: FieldRef<"Departure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Departure findUnique
   */
  export type DepartureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter, which Departure to fetch.
     */
    where: DepartureWhereUniqueInput
  }

  /**
   * Departure findUniqueOrThrow
   */
  export type DepartureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter, which Departure to fetch.
     */
    where: DepartureWhereUniqueInput
  }

  /**
   * Departure findFirst
   */
  export type DepartureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter, which Departure to fetch.
     */
    where?: DepartureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departures to fetch.
     */
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departures.
     */
    cursor?: DepartureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departures.
     */
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Departure findFirstOrThrow
   */
  export type DepartureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter, which Departure to fetch.
     */
    where?: DepartureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departures to fetch.
     */
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departures.
     */
    cursor?: DepartureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departures.
     */
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Departure findMany
   */
  export type DepartureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter, which Departures to fetch.
     */
    where?: DepartureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departures to fetch.
     */
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departures.
     */
    cursor?: DepartureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departures.
     */
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Departure create
   */
  export type DepartureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * The data needed to create a Departure.
     */
    data: XOR<DepartureCreateInput, DepartureUncheckedCreateInput>
  }

  /**
   * Departure createMany
   */
  export type DepartureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departures.
     */
    data: DepartureCreateManyInput | DepartureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departure createManyAndReturn
   */
  export type DepartureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * The data used to create many Departures.
     */
    data: DepartureCreateManyInput | DepartureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Departure update
   */
  export type DepartureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * The data needed to update a Departure.
     */
    data: XOR<DepartureUpdateInput, DepartureUncheckedUpdateInput>
    /**
     * Choose, which Departure to update.
     */
    where: DepartureWhereUniqueInput
  }

  /**
   * Departure updateMany
   */
  export type DepartureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departures.
     */
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyInput>
    /**
     * Filter which Departures to update
     */
    where?: DepartureWhereInput
    /**
     * Limit how many Departures to update.
     */
    limit?: number
  }

  /**
   * Departure updateManyAndReturn
   */
  export type DepartureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * The data used to update Departures.
     */
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyInput>
    /**
     * Filter which Departures to update
     */
    where?: DepartureWhereInput
    /**
     * Limit how many Departures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Departure upsert
   */
  export type DepartureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * The filter to search for the Departure to update in case it exists.
     */
    where: DepartureWhereUniqueInput
    /**
     * In case the Departure found by the `where` argument doesn't exist, create a new Departure with this data.
     */
    create: XOR<DepartureCreateInput, DepartureUncheckedCreateInput>
    /**
     * In case the Departure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartureUpdateInput, DepartureUncheckedUpdateInput>
  }

  /**
   * Departure delete
   */
  export type DepartureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    /**
     * Filter which Departure to delete.
     */
    where: DepartureWhereUniqueInput
  }

  /**
   * Departure deleteMany
   */
  export type DepartureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departures to delete
     */
    where?: DepartureWhereInput
    /**
     * Limit how many Departures to delete.
     */
    limit?: number
  }

  /**
   * Departure.assets
   */
  export type Departure$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Departure without action
   */
  export type DepartureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
  }


  /**
   * Model Hold
   */

  export type AggregateHold = {
    _count: HoldCountAggregateOutputType | null
    _avg: HoldAvgAggregateOutputType | null
    _sum: HoldSumAggregateOutputType | null
    _min: HoldMinAggregateOutputType | null
    _max: HoldMaxAggregateOutputType | null
  }

  export type HoldAvgAggregateOutputType = {
    id: number | null
    created_by_id: number | null
    created_for_id: number | null
    customer_id: number | null
  }

  export type HoldSumAggregateOutputType = {
    id: number | null
    created_by_id: number | null
    created_for_id: number | null
    customer_id: number | null
  }

  export type HoldMinAggregateOutputType = {
    id: number | null
    hold_number: string | null
    created_by_id: number | null
    created_for_id: number | null
    customer_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type HoldMaxAggregateOutputType = {
    id: number | null
    hold_number: string | null
    created_by_id: number | null
    created_for_id: number | null
    customer_id: number | null
    notes: string | null
    created_at: Date | null
  }

  export type HoldCountAggregateOutputType = {
    id: number
    hold_number: number
    created_by_id: number
    created_for_id: number
    customer_id: number
    notes: number
    created_at: number
    _all: number
  }


  export type HoldAvgAggregateInputType = {
    id?: true
    created_by_id?: true
    created_for_id?: true
    customer_id?: true
  }

  export type HoldSumAggregateInputType = {
    id?: true
    created_by_id?: true
    created_for_id?: true
    customer_id?: true
  }

  export type HoldMinAggregateInputType = {
    id?: true
    hold_number?: true
    created_by_id?: true
    created_for_id?: true
    customer_id?: true
    notes?: true
    created_at?: true
  }

  export type HoldMaxAggregateInputType = {
    id?: true
    hold_number?: true
    created_by_id?: true
    created_for_id?: true
    customer_id?: true
    notes?: true
    created_at?: true
  }

  export type HoldCountAggregateInputType = {
    id?: true
    hold_number?: true
    created_by_id?: true
    created_for_id?: true
    customer_id?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type HoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hold to aggregate.
     */
    where?: HoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holds to fetch.
     */
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holds
    **/
    _count?: true | HoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoldMaxAggregateInputType
  }

  export type GetHoldAggregateType<T extends HoldAggregateArgs> = {
        [P in keyof T & keyof AggregateHold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHold[P]>
      : GetScalarType<T[P], AggregateHold[P]>
  }




  export type HoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldWhereInput
    orderBy?: HoldOrderByWithAggregationInput | HoldOrderByWithAggregationInput[]
    by: HoldScalarFieldEnum[] | HoldScalarFieldEnum
    having?: HoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoldCountAggregateInputType | true
    _avg?: HoldAvgAggregateInputType
    _sum?: HoldSumAggregateInputType
    _min?: HoldMinAggregateInputType
    _max?: HoldMaxAggregateInputType
  }

  export type HoldGroupByOutputType = {
    id: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    customer_id: number
    notes: string | null
    created_at: Date
    _count: HoldCountAggregateOutputType | null
    _avg: HoldAvgAggregateOutputType | null
    _sum: HoldSumAggregateOutputType | null
    _min: HoldMinAggregateOutputType | null
    _max: HoldMaxAggregateOutputType | null
  }

  type GetHoldGroupByPayload<T extends HoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoldGroupByOutputType[P]>
            : GetScalarType<T[P], HoldGroupByOutputType[P]>
        }
      >
    >


  export type HoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hold_number?: boolean
    created_by_id?: boolean
    created_for_id?: boolean
    customer_id?: boolean
    notes?: boolean
    created_at?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
    assets?: boolean | Hold$assetsArgs<ExtArgs>
    _count?: boolean | HoldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hold"]>

  export type HoldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hold_number?: boolean
    created_by_id?: boolean
    created_for_id?: boolean
    customer_id?: boolean
    notes?: boolean
    created_at?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hold"]>

  export type HoldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hold_number?: boolean
    created_by_id?: boolean
    created_for_id?: boolean
    customer_id?: boolean
    notes?: boolean
    created_at?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hold"]>

  export type HoldSelectScalar = {
    id?: boolean
    hold_number?: boolean
    created_by_id?: boolean
    created_for_id?: boolean
    customer_id?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type HoldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hold_number" | "created_by_id" | "created_for_id" | "customer_id" | "notes" | "created_at", ExtArgs["result"]["hold"]>
  export type HoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
    assets?: boolean | Hold$assetsArgs<ExtArgs>
    _count?: boolean | HoldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HoldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type HoldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
    created_for?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $HoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hold"
    objects: {
      created_by: Prisma.$UserPayload<ExtArgs>
      created_for: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$OrganizationPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hold_number: string
      created_by_id: number
      created_for_id: number
      customer_id: number
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["hold"]>
    composites: {}
  }

  type HoldGetPayload<S extends boolean | null | undefined | HoldDefaultArgs> = $Result.GetResult<Prisma.$HoldPayload, S>

  type HoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HoldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HoldCountAggregateInputType | true
    }

  export interface HoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hold'], meta: { name: 'Hold' } }
    /**
     * Find zero or one Hold that matches the filter.
     * @param {HoldFindUniqueArgs} args - Arguments to find a Hold
     * @example
     * // Get one Hold
     * const hold = await prisma.hold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoldFindUniqueArgs>(args: SelectSubset<T, HoldFindUniqueArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HoldFindUniqueOrThrowArgs} args - Arguments to find a Hold
     * @example
     * // Get one Hold
     * const hold = await prisma.hold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoldFindUniqueOrThrowArgs>(args: SelectSubset<T, HoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldFindFirstArgs} args - Arguments to find a Hold
     * @example
     * // Get one Hold
     * const hold = await prisma.hold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoldFindFirstArgs>(args?: SelectSubset<T, HoldFindFirstArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldFindFirstOrThrowArgs} args - Arguments to find a Hold
     * @example
     * // Get one Hold
     * const hold = await prisma.hold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoldFindFirstOrThrowArgs>(args?: SelectSubset<T, HoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holds
     * const holds = await prisma.hold.findMany()
     * 
     * // Get first 10 Holds
     * const holds = await prisma.hold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holdWithIdOnly = await prisma.hold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoldFindManyArgs>(args?: SelectSubset<T, HoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hold.
     * @param {HoldCreateArgs} args - Arguments to create a Hold.
     * @example
     * // Create one Hold
     * const Hold = await prisma.hold.create({
     *   data: {
     *     // ... data to create a Hold
     *   }
     * })
     * 
     */
    create<T extends HoldCreateArgs>(args: SelectSubset<T, HoldCreateArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holds.
     * @param {HoldCreateManyArgs} args - Arguments to create many Holds.
     * @example
     * // Create many Holds
     * const hold = await prisma.hold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoldCreateManyArgs>(args?: SelectSubset<T, HoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holds and returns the data saved in the database.
     * @param {HoldCreateManyAndReturnArgs} args - Arguments to create many Holds.
     * @example
     * // Create many Holds
     * const hold = await prisma.hold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holds and only return the `id`
     * const holdWithIdOnly = await prisma.hold.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoldCreateManyAndReturnArgs>(args?: SelectSubset<T, HoldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hold.
     * @param {HoldDeleteArgs} args - Arguments to delete one Hold.
     * @example
     * // Delete one Hold
     * const Hold = await prisma.hold.delete({
     *   where: {
     *     // ... filter to delete one Hold
     *   }
     * })
     * 
     */
    delete<T extends HoldDeleteArgs>(args: SelectSubset<T, HoldDeleteArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hold.
     * @param {HoldUpdateArgs} args - Arguments to update one Hold.
     * @example
     * // Update one Hold
     * const hold = await prisma.hold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoldUpdateArgs>(args: SelectSubset<T, HoldUpdateArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holds.
     * @param {HoldDeleteManyArgs} args - Arguments to filter Holds to delete.
     * @example
     * // Delete a few Holds
     * const { count } = await prisma.hold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoldDeleteManyArgs>(args?: SelectSubset<T, HoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holds
     * const hold = await prisma.hold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoldUpdateManyArgs>(args: SelectSubset<T, HoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holds and returns the data updated in the database.
     * @param {HoldUpdateManyAndReturnArgs} args - Arguments to update many Holds.
     * @example
     * // Update many Holds
     * const hold = await prisma.hold.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Holds and only return the `id`
     * const holdWithIdOnly = await prisma.hold.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HoldUpdateManyAndReturnArgs>(args: SelectSubset<T, HoldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hold.
     * @param {HoldUpsertArgs} args - Arguments to update or create a Hold.
     * @example
     * // Update or create a Hold
     * const hold = await prisma.hold.upsert({
     *   create: {
     *     // ... data to create a Hold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hold we want to update
     *   }
     * })
     */
    upsert<T extends HoldUpsertArgs>(args: SelectSubset<T, HoldUpsertArgs<ExtArgs>>): Prisma__HoldClient<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldCountArgs} args - Arguments to filter Holds to count.
     * @example
     * // Count the number of Holds
     * const count = await prisma.hold.count({
     *   where: {
     *     // ... the filter for the Holds we want to count
     *   }
     * })
    **/
    count<T extends HoldCountArgs>(
      args?: Subset<T, HoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoldAggregateArgs>(args: Subset<T, HoldAggregateArgs>): Prisma.PrismaPromise<GetHoldAggregateType<T>>

    /**
     * Group by Hold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoldGroupByArgs['orderBy'] }
        : { orderBy?: HoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hold model
   */
  readonly fields: HoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_for<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends Hold$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Hold$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hold model
   */
  interface HoldFieldRefs {
    readonly id: FieldRef<"Hold", 'Int'>
    readonly hold_number: FieldRef<"Hold", 'String'>
    readonly created_by_id: FieldRef<"Hold", 'Int'>
    readonly created_for_id: FieldRef<"Hold", 'Int'>
    readonly customer_id: FieldRef<"Hold", 'Int'>
    readonly notes: FieldRef<"Hold", 'String'>
    readonly created_at: FieldRef<"Hold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hold findUnique
   */
  export type HoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter, which Hold to fetch.
     */
    where: HoldWhereUniqueInput
  }

  /**
   * Hold findUniqueOrThrow
   */
  export type HoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter, which Hold to fetch.
     */
    where: HoldWhereUniqueInput
  }

  /**
   * Hold findFirst
   */
  export type HoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter, which Hold to fetch.
     */
    where?: HoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holds to fetch.
     */
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holds.
     */
    cursor?: HoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holds.
     */
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * Hold findFirstOrThrow
   */
  export type HoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter, which Hold to fetch.
     */
    where?: HoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holds to fetch.
     */
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holds.
     */
    cursor?: HoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holds.
     */
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * Hold findMany
   */
  export type HoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter, which Holds to fetch.
     */
    where?: HoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holds to fetch.
     */
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holds.
     */
    cursor?: HoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holds.
     */
    skip?: number
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * Hold create
   */
  export type HoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * The data needed to create a Hold.
     */
    data: XOR<HoldCreateInput, HoldUncheckedCreateInput>
  }

  /**
   * Hold createMany
   */
  export type HoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holds.
     */
    data: HoldCreateManyInput | HoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hold createManyAndReturn
   */
  export type HoldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * The data used to create many Holds.
     */
    data: HoldCreateManyInput | HoldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hold update
   */
  export type HoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * The data needed to update a Hold.
     */
    data: XOR<HoldUpdateInput, HoldUncheckedUpdateInput>
    /**
     * Choose, which Hold to update.
     */
    where: HoldWhereUniqueInput
  }

  /**
   * Hold updateMany
   */
  export type HoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holds.
     */
    data: XOR<HoldUpdateManyMutationInput, HoldUncheckedUpdateManyInput>
    /**
     * Filter which Holds to update
     */
    where?: HoldWhereInput
    /**
     * Limit how many Holds to update.
     */
    limit?: number
  }

  /**
   * Hold updateManyAndReturn
   */
  export type HoldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * The data used to update Holds.
     */
    data: XOR<HoldUpdateManyMutationInput, HoldUncheckedUpdateManyInput>
    /**
     * Filter which Holds to update
     */
    where?: HoldWhereInput
    /**
     * Limit how many Holds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hold upsert
   */
  export type HoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * The filter to search for the Hold to update in case it exists.
     */
    where: HoldWhereUniqueInput
    /**
     * In case the Hold found by the `where` argument doesn't exist, create a new Hold with this data.
     */
    create: XOR<HoldCreateInput, HoldUncheckedCreateInput>
    /**
     * In case the Hold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoldUpdateInput, HoldUncheckedUpdateInput>
  }

  /**
   * Hold delete
   */
  export type HoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    /**
     * Filter which Hold to delete.
     */
    where: HoldWhereUniqueInput
  }

  /**
   * Hold deleteMany
   */
  export type HoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holds to delete
     */
    where?: HoldWhereInput
    /**
     * Limit how many Holds to delete.
     */
    limit?: number
  }

  /**
   * Hold.assets
   */
  export type Hold$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Hold without action
   */
  export type HoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    updated_by_id: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    updated_by_id: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    organization_id: number | null
    updated_by_id: number | null
    is_cleared: boolean | null
    created_at: Date | null
    invoice_type: $Enums.InvoiceType | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    organization_id: number | null
    updated_by_id: number | null
    is_cleared: boolean | null
    created_at: Date | null
    invoice_type: $Enums.InvoiceType | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoice_number: number
    organization_id: number
    updated_by_id: number
    is_cleared: number
    created_at: number
    invoice_type: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    organization_id?: true
    updated_by_id?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    organization_id?: true
    updated_by_id?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoice_number?: true
    organization_id?: true
    updated_by_id?: true
    is_cleared?: true
    created_at?: true
    invoice_type?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    organization_id?: true
    updated_by_id?: true
    is_cleared?: true
    created_at?: true
    invoice_type?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoice_number?: true
    organization_id?: true
    updated_by_id?: true
    is_cleared?: true
    created_at?: true
    invoice_type?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    invoice_number: string
    organization_id: number
    updated_by_id: number
    is_cleared: boolean
    created_at: Date
    invoice_type: $Enums.InvoiceType
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    organization_id?: boolean
    updated_by_id?: boolean
    is_cleared?: boolean
    created_at?: boolean
    invoice_type?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
    purchase_assets?: boolean | Invoice$purchase_assetsArgs<ExtArgs>
    sales_assets?: boolean | Invoice$sales_assetsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    organization_id?: boolean
    updated_by_id?: boolean
    is_cleared?: boolean
    created_at?: boolean
    invoice_type?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    organization_id?: boolean
    updated_by_id?: boolean
    is_cleared?: boolean
    created_at?: boolean
    invoice_type?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    organization_id?: boolean
    updated_by_id?: boolean
    is_cleared?: boolean
    created_at?: boolean
    invoice_type?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_number" | "organization_id" | "updated_by_id" | "is_cleared" | "created_at" | "invoice_type", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
    purchase_assets?: boolean | Invoice$purchase_assetsArgs<ExtArgs>
    sales_assets?: boolean | Invoice$sales_assetsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updated_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      updated_by: Prisma.$UserPayload<ExtArgs>
      purchase_assets: Prisma.$AssetPayload<ExtArgs>[]
      sales_assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoice_number: string
      organization_id: number
      updated_by_id: number
      is_cleared: boolean
      created_at: Date
      invoice_type: $Enums.InvoiceType
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updated_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchase_assets<T extends Invoice$purchase_assetsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$purchase_assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales_assets<T extends Invoice$sales_assetsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$sales_assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly invoice_number: FieldRef<"Invoice", 'String'>
    readonly organization_id: FieldRef<"Invoice", 'Int'>
    readonly updated_by_id: FieldRef<"Invoice", 'Int'>
    readonly is_cleared: FieldRef<"Invoice", 'Boolean'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
    readonly invoice_type: FieldRef<"Invoice", 'InvoiceType'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.purchase_assets
   */
  export type Invoice$purchase_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Invoice.sales_assets
   */
  export type Invoice$sales_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    city_code: string | null
    street: string | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    city_code: string | null
    street: string | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    city_code: number
    street: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    city_code?: true
    street?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    city_code?: true
    street?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    city_code?: true
    street?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    city_code: string
    street: string
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city_code?: boolean
    street?: boolean
    assets?: boolean | Warehouse$assetsArgs<ExtArgs>
    origin_transfers?: boolean | Warehouse$origin_transfersArgs<ExtArgs>
    destination_transfers?: boolean | Warehouse$destination_transfersArgs<ExtArgs>
    departures?: boolean | Warehouse$departuresArgs<ExtArgs>
    arrivals?: boolean | Warehouse$arrivalsArgs<ExtArgs>
    locations?: boolean | Warehouse$locationsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city_code?: boolean
    street?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city_code?: boolean
    street?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    city_code?: boolean
    street?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "city_code" | "street", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | Warehouse$assetsArgs<ExtArgs>
    origin_transfers?: boolean | Warehouse$origin_transfersArgs<ExtArgs>
    destination_transfers?: boolean | Warehouse$destination_transfersArgs<ExtArgs>
    departures?: boolean | Warehouse$departuresArgs<ExtArgs>
    arrivals?: boolean | Warehouse$arrivalsArgs<ExtArgs>
    locations?: boolean | Warehouse$locationsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      assets: Prisma.$AssetPayload<ExtArgs>[]
      origin_transfers: Prisma.$TransferPayload<ExtArgs>[]
      destination_transfers: Prisma.$TransferPayload<ExtArgs>[]
      departures: Prisma.$DeparturePayload<ExtArgs>[]
      arrivals: Prisma.$ArrivalPayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      city_code: string
      street: string
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assets<T extends Warehouse$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    origin_transfers<T extends Warehouse$origin_transfersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$origin_transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    destination_transfers<T extends Warehouse$destination_transfersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$destination_transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departures<T extends Warehouse$departuresArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$departuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrivals<T extends Warehouse$arrivalsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$arrivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Warehouse$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly city_code: FieldRef<"Warehouse", 'String'>
    readonly street: FieldRef<"Warehouse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.assets
   */
  export type Warehouse$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Warehouse.origin_transfers
   */
  export type Warehouse$origin_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.destination_transfers
   */
  export type Warehouse$destination_transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.departures
   */
  export type Warehouse$departuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    cursor?: DepartureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Warehouse.arrivals
   */
  export type Warehouse$arrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    where?: ArrivalWhereInput
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    cursor?: ArrivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Warehouse.locations
   */
  export type Warehouse$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    warehouse_id: number | null
  }

  export type LocationSumAggregateOutputType = {
    warehouse_id: number | null
  }

  export type LocationMinAggregateOutputType = {
    warehouse_id: number | null
    location: string | null
  }

  export type LocationMaxAggregateOutputType = {
    warehouse_id: number | null
    location: string | null
  }

  export type LocationCountAggregateOutputType = {
    warehouse_id: number
    location: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    warehouse_id?: true
  }

  export type LocationSumAggregateInputType = {
    warehouse_id?: true
  }

  export type LocationMinAggregateInputType = {
    warehouse_id?: true
    location?: true
  }

  export type LocationMaxAggregateInputType = {
    warehouse_id?: true
    location?: true
  }

  export type LocationCountAggregateInputType = {
    warehouse_id?: true
    location?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    warehouse_id: number
    location: string
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    warehouse_id?: boolean
    location?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    assets?: boolean | Location$assetsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    warehouse_id?: boolean
    location?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    warehouse_id?: boolean
    location?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    warehouse_id?: boolean
    location?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"warehouse_id" | "location", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    assets?: boolean | Location$assetsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      warehouse_id: number
      location: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `warehouse_id`
     * const locationWithWarehouse_idOnly = await prisma.location.findMany({ select: { warehouse_id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `warehouse_id`
     * const locationWithWarehouse_idOnly = await prisma.location.createManyAndReturn({
     *   select: { warehouse_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `warehouse_id`
     * const locationWithWarehouse_idOnly = await prisma.location.updateManyAndReturn({
     *   select: { warehouse_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends Location$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Location$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly warehouse_id: FieldRef<"Location", 'Int'>
    readonly location: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.assets
   */
  export type Location$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    models?: boolean | Brand$modelsArgs<ExtArgs>
    errorCategories?: boolean | Brand$errorCategoriesArgs<ExtArgs>
    assets?: boolean | Brand$assetsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | Brand$modelsArgs<ExtArgs>
    errorCategories?: boolean | Brand$errorCategoriesArgs<ExtArgs>
    assets?: boolean | Brand$assetsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      models: Prisma.$ModelPayload<ExtArgs>[]
      errorCategories: Prisma.$ErrorCategoryPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends Brand$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    errorCategories<T extends Brand$errorCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Brand$errorCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends Brand$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.models
   */
  export type Brand$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Brand.errorCategories
   */
  export type Brand$errorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorCategory
     */
    select?: ErrorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorCategory
     */
    omit?: ErrorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorCategoryInclude<ExtArgs> | null
    where?: ErrorCategoryWhereInput
    orderBy?: ErrorCategoryOrderByWithRelationInput | ErrorCategoryOrderByWithRelationInput[]
    cursor?: ErrorCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorCategoryScalarFieldEnum | ErrorCategoryScalarFieldEnum[]
  }

  /**
   * Brand.assets
   */
  export type Brand$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    size: number | null
    brand_id: number | null
  }

  export type ModelSumAggregateOutputType = {
    id: number | null
    weight: number | null
    size: number | null
    brand_id: number | null
  }

  export type ModelMinAggregateOutputType = {
    id: number | null
    name: string | null
    asset_type: $Enums.AssetType | null
    weight: number | null
    size: number | null
    brand_id: number | null
  }

  export type ModelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    asset_type: $Enums.AssetType | null
    weight: number | null
    size: number | null
    brand_id: number | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    name: number
    asset_type: number
    weight: number
    size: number
    brand_id: number
    _all: number
  }


  export type ModelAvgAggregateInputType = {
    id?: true
    weight?: true
    size?: true
    brand_id?: true
  }

  export type ModelSumAggregateInputType = {
    id?: true
    weight?: true
    size?: true
    brand_id?: true
  }

  export type ModelMinAggregateInputType = {
    id?: true
    name?: true
    asset_type?: true
    weight?: true
    size?: true
    brand_id?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    name?: true
    asset_type?: true
    weight?: true
    size?: true
    brand_id?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    name?: true
    asset_type?: true
    weight?: true
    size?: true
    brand_id?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _avg?: ModelAvgAggregateInputType
    _sum?: ModelSumAggregateInputType
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand_id: number
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    asset_type?: boolean
    weight?: boolean
    size?: boolean
    brand_id?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    assets?: boolean | Model$assetsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    asset_type?: boolean
    weight?: boolean
    size?: boolean
    brand_id?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    asset_type?: boolean
    weight?: boolean
    size?: boolean
    brand_id?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectScalar = {
    id?: boolean
    name?: boolean
    asset_type?: boolean
    weight?: boolean
    size?: boolean
    brand_id?: boolean
  }

  export type ModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "asset_type" | "weight" | "size" | "brand_id", ExtArgs["result"]["model"]>
  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    assets?: boolean | Model$assetsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type ModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      asset_type: $Enums.AssetType
      weight: number
      size: number
      brand_id: number
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models and returns the data updated in the database.
     * @param {ModelUpdateManyAndReturnArgs} args - Arguments to update many Models.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends Model$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Model$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'Int'>
    readonly name: FieldRef<"Model", 'String'>
    readonly asset_type: FieldRef<"Model", 'AssetType'>
    readonly weight: FieldRef<"Model", 'Float'>
    readonly size: FieldRef<"Model", 'Float'>
    readonly brand_id: FieldRef<"Model", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model createManyAndReturn
   */
  export type ModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model updateManyAndReturn
   */
  export type ModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to delete.
     */
    limit?: number
  }

  /**
   * Model.assets
   */
  export type Model$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    id: number | null
    asset_id: number | null
    uploaded_by_id: number | null
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    id: number | null
    asset_id: number | null
    uploaded_by_id: number | null
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: number | null
    asset_id: number | null
    uploaded_by_id: number | null
    name: string | null
    type: $Enums.FileType | null
    data: Uint8Array | null
    url: string | null
    size: number | null
    uploaded_at: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: number | null
    asset_id: number | null
    uploaded_by_id: number | null
    name: string | null
    type: $Enums.FileType | null
    data: Uint8Array | null
    url: string | null
    size: number | null
    uploaded_at: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    asset_id: number
    uploaded_by_id: number
    name: number
    type: number
    data: number
    url: number
    size: number
    uploaded_at: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    id?: true
    asset_id?: true
    uploaded_by_id?: true
    size?: true
  }

  export type FileSumAggregateInputType = {
    id?: true
    asset_id?: true
    uploaded_by_id?: true
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    asset_id?: true
    uploaded_by_id?: true
    name?: true
    type?: true
    data?: true
    url?: true
    size?: true
    uploaded_at?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    asset_id?: true
    uploaded_by_id?: true
    name?: true
    type?: true
    data?: true
    url?: true
    size?: true
    uploaded_at?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    asset_id?: true
    uploaded_by_id?: true
    name?: true
    type?: true
    data?: true
    url?: true
    size?: true
    uploaded_at?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: number
    asset_id: number
    uploaded_by_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    uploaded_by_id?: boolean
    name?: boolean
    type?: boolean
    data?: boolean
    url?: boolean
    size?: boolean
    uploaded_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    uploaded_by_id?: boolean
    name?: boolean
    type?: boolean
    data?: boolean
    url?: boolean
    size?: boolean
    uploaded_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    uploaded_by_id?: boolean
    name?: boolean
    type?: boolean
    data?: boolean
    url?: boolean
    size?: boolean
    uploaded_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    asset_id?: boolean
    uploaded_by_id?: boolean
    name?: boolean
    type?: boolean
    data?: boolean
    url?: boolean
    size?: boolean
    uploaded_at?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset_id" | "uploaded_by_id" | "name" | "type" | "data" | "url" | "size" | "uploaded_at", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    uploaded_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      uploaded_by: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset_id: number
      uploaded_by_id: number
      name: string
      type: $Enums.FileType
      data: Uint8Array
      url: string
      size: number
      uploaded_at: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploaded_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'Int'>
    readonly asset_id: FieldRef<"File", 'Int'>
    readonly uploaded_by_id: FieldRef<"File", 'Int'>
    readonly name: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'FileType'>
    readonly data: FieldRef<"File", 'Bytes'>
    readonly url: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly uploaded_at: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    asset_id: number | null
    created_by_id: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    asset_id: number | null
    created_by_id: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    asset_id: number | null
    created_by_id: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    asset_id: number | null
    created_by_id: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    asset_id: number
    created_by_id: number
    comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    asset_id?: true
    created_by_id?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    asset_id?: true
    created_by_id?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    asset_id?: true
    created_by_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    asset_id?: true
    created_by_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    asset_id?: true
    created_by_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    asset_id: number
    created_by_id: number
    comment: string
    created_at: Date
    updated_at: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    created_by_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    created_by_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    created_by_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    asset_id?: boolean
    created_by_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset_id" | "created_by_id" | "comment" | "created_at" | "updated_at", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset_id: number
      created_by_id: number
      comment: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly asset_id: FieldRef<"Comment", 'Int'>
    readonly created_by_id: FieldRef<"Comment", 'Int'>
    readonly comment: FieldRef<"Comment", 'String'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly updated_at: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    googleId: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    googleId: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    googleId: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    googleId: string | null
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
    asset_errors_added?: boolean | User$asset_errors_addedArgs<ExtArgs>
    asset_errors_fixed?: boolean | User$asset_errors_fixedArgs<ExtArgs>
    transfers?: boolean | User$transfersArgs<ExtArgs>
    departures?: boolean | User$departuresArgs<ExtArgs>
    departure_sales_reps?: boolean | User$departure_sales_repsArgs<ExtArgs>
    arrivals?: boolean | User$arrivalsArgs<ExtArgs>
    holds_created?: boolean | User$holds_createdArgs<ExtArgs>
    holds_for?: boolean | User$holds_forArgs<ExtArgs>
    invoices_updated?: boolean | User$invoices_updatedArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    asset_history?: boolean | User$asset_historyArgs<ExtArgs>
    asset_parts?: boolean | User$asset_partsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "googleId" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset_errors_added?: boolean | User$asset_errors_addedArgs<ExtArgs>
    asset_errors_fixed?: boolean | User$asset_errors_fixedArgs<ExtArgs>
    transfers?: boolean | User$transfersArgs<ExtArgs>
    departures?: boolean | User$departuresArgs<ExtArgs>
    departure_sales_reps?: boolean | User$departure_sales_repsArgs<ExtArgs>
    arrivals?: boolean | User$arrivalsArgs<ExtArgs>
    holds_created?: boolean | User$holds_createdArgs<ExtArgs>
    holds_for?: boolean | User$holds_forArgs<ExtArgs>
    invoices_updated?: boolean | User$invoices_updatedArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    asset_history?: boolean | User$asset_historyArgs<ExtArgs>
    asset_parts?: boolean | User$asset_partsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      asset_errors_added: Prisma.$AssetErrorPayload<ExtArgs>[]
      asset_errors_fixed: Prisma.$AssetErrorPayload<ExtArgs>[]
      transfers: Prisma.$TransferPayload<ExtArgs>[]
      departures: Prisma.$DeparturePayload<ExtArgs>[]
      departure_sales_reps: Prisma.$DeparturePayload<ExtArgs>[]
      arrivals: Prisma.$ArrivalPayload<ExtArgs>[]
      holds_created: Prisma.$HoldPayload<ExtArgs>[]
      holds_for: Prisma.$HoldPayload<ExtArgs>[]
      invoices_updated: Prisma.$InvoicePayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      asset_history: Prisma.$AssetHistoryPayload<ExtArgs>[]
      asset_parts: Prisma.$AssetPartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      googleId: string | null
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset_errors_added<T extends User$asset_errors_addedArgs<ExtArgs> = {}>(args?: Subset<T, User$asset_errors_addedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_errors_fixed<T extends User$asset_errors_fixedArgs<ExtArgs> = {}>(args?: Subset<T, User$asset_errors_fixedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfers<T extends User$transfersArgs<ExtArgs> = {}>(args?: Subset<T, User$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departures<T extends User$departuresArgs<ExtArgs> = {}>(args?: Subset<T, User$departuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departure_sales_reps<T extends User$departure_sales_repsArgs<ExtArgs> = {}>(args?: Subset<T, User$departure_sales_repsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrivals<T extends User$arrivalsArgs<ExtArgs> = {}>(args?: Subset<T, User$arrivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holds_created<T extends User$holds_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$holds_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holds_for<T extends User$holds_forArgs<ExtArgs> = {}>(args?: Subset<T, User$holds_forArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices_updated<T extends User$invoices_updatedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoices_updatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends User$filesArgs<ExtArgs> = {}>(args?: Subset<T, User$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_history<T extends User$asset_historyArgs<ExtArgs> = {}>(args?: Subset<T, User$asset_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asset_parts<T extends User$asset_partsArgs<ExtArgs> = {}>(args?: Subset<T, User$asset_partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.asset_errors_added
   */
  export type User$asset_errors_addedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    where?: AssetErrorWhereInput
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    cursor?: AssetErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * User.asset_errors_fixed
   */
  export type User$asset_errors_fixedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetError
     */
    select?: AssetErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetError
     */
    omit?: AssetErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetErrorInclude<ExtArgs> | null
    where?: AssetErrorWhereInput
    orderBy?: AssetErrorOrderByWithRelationInput | AssetErrorOrderByWithRelationInput[]
    cursor?: AssetErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetErrorScalarFieldEnum | AssetErrorScalarFieldEnum[]
  }

  /**
   * User.transfers
   */
  export type User$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.departures
   */
  export type User$departuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    cursor?: DepartureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * User.departure_sales_reps
   */
  export type User$departure_sales_repsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    cursor?: DepartureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * User.arrivals
   */
  export type User$arrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    where?: ArrivalWhereInput
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    cursor?: ArrivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * User.holds_created
   */
  export type User$holds_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    where?: HoldWhereInput
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    cursor?: HoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * User.holds_for
   */
  export type User$holds_forArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    where?: HoldWhereInput
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    cursor?: HoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * User.invoices_updated
   */
  export type User$invoices_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.files
   */
  export type User$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.asset_history
   */
  export type User$asset_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    cursor?: AssetHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * User.asset_parts
   */
  export type User$asset_partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetPart
     */
    select?: AssetPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetPart
     */
    omit?: AssetPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetPartInclude<ExtArgs> | null
    where?: AssetPartWhereInput
    orderBy?: AssetPartOrderByWithRelationInput | AssetPartOrderByWithRelationInput[]
    cursor?: AssetPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetPartScalarFieldEnum | AssetPartScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    account_number: string | null
    name: string | null
    contact_name: string | null
    phone: string | null
    phone_ext: string | null
    primary_email: string | null
    secondary_email: string | null
    address: string | null
    city: string | null
    province: string | null
    country: string | null
    website: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    account_number: string | null
    name: string | null
    contact_name: string | null
    phone: string | null
    phone_ext: string | null
    primary_email: string | null
    secondary_email: string | null
    address: string | null
    city: string | null
    province: string | null
    country: string | null
    website: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    account_number: number
    name: number
    contact_name: number
    phone: number
    phone_ext: number
    primary_email: number
    secondary_email: number
    address: number
    city: number
    province: number
    country: number
    website: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    account_number?: true
    name?: true
    contact_name?: true
    phone?: true
    phone_ext?: true
    primary_email?: true
    secondary_email?: true
    address?: true
    city?: true
    province?: true
    country?: true
    website?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    account_number?: true
    name?: true
    contact_name?: true
    phone?: true
    phone_ext?: true
    primary_email?: true
    secondary_email?: true
    address?: true
    city?: true
    province?: true
    country?: true
    website?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    account_number?: true
    name?: true
    contact_name?: true
    phone?: true
    phone_ext?: true
    primary_email?: true
    secondary_email?: true
    address?: true
    city?: true
    province?: true
    country?: true
    website?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    account_number: string
    name: string
    contact_name: string | null
    phone: string | null
    phone_ext: string | null
    primary_email: string | null
    secondary_email: string | null
    address: string | null
    city: string | null
    province: string | null
    country: string | null
    website: string | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_number?: boolean
    name?: boolean
    contact_name?: boolean
    phone?: boolean
    phone_ext?: boolean
    primary_email?: boolean
    secondary_email?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    website?: boolean
    invoices?: boolean | Organization$invoicesArgs<ExtArgs>
    arrivals_origin?: boolean | Organization$arrivals_originArgs<ExtArgs>
    arrivals_transporter?: boolean | Organization$arrivals_transporterArgs<ExtArgs>
    departures_destination?: boolean | Organization$departures_destinationArgs<ExtArgs>
    departures_transporter?: boolean | Organization$departures_transporterArgs<ExtArgs>
    holds?: boolean | Organization$holdsArgs<ExtArgs>
    transfers?: boolean | Organization$transfersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_number?: boolean
    name?: boolean
    contact_name?: boolean
    phone?: boolean
    phone_ext?: boolean
    primary_email?: boolean
    secondary_email?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    website?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_number?: boolean
    name?: boolean
    contact_name?: boolean
    phone?: boolean
    phone_ext?: boolean
    primary_email?: boolean
    secondary_email?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    website?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    account_number?: boolean
    name?: boolean
    contact_name?: boolean
    phone?: boolean
    phone_ext?: boolean
    primary_email?: boolean
    secondary_email?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    website?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_number" | "name" | "contact_name" | "phone" | "phone_ext" | "primary_email" | "secondary_email" | "address" | "city" | "province" | "country" | "website", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | Organization$invoicesArgs<ExtArgs>
    arrivals_origin?: boolean | Organization$arrivals_originArgs<ExtArgs>
    arrivals_transporter?: boolean | Organization$arrivals_transporterArgs<ExtArgs>
    departures_destination?: boolean | Organization$departures_destinationArgs<ExtArgs>
    departures_transporter?: boolean | Organization$departures_transporterArgs<ExtArgs>
    holds?: boolean | Organization$holdsArgs<ExtArgs>
    transfers?: boolean | Organization$transfersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      arrivals_origin: Prisma.$ArrivalPayload<ExtArgs>[]
      arrivals_transporter: Prisma.$ArrivalPayload<ExtArgs>[]
      departures_destination: Prisma.$DeparturePayload<ExtArgs>[]
      departures_transporter: Prisma.$DeparturePayload<ExtArgs>[]
      holds: Prisma.$HoldPayload<ExtArgs>[]
      transfers: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      account_number: string
      name: string
      contact_name: string | null
      phone: string | null
      phone_ext: string | null
      primary_email: string | null
      secondary_email: string | null
      address: string | null
      city: string | null
      province: string | null
      country: string | null
      website: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends Organization$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrivals_origin<T extends Organization$arrivals_originArgs<ExtArgs> = {}>(args?: Subset<T, Organization$arrivals_originArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrivals_transporter<T extends Organization$arrivals_transporterArgs<ExtArgs> = {}>(args?: Subset<T, Organization$arrivals_transporterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departures_destination<T extends Organization$departures_destinationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$departures_destinationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departures_transporter<T extends Organization$departures_transporterArgs<ExtArgs> = {}>(args?: Subset<T, Organization$departures_transporterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeparturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holds<T extends Organization$holdsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$holdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfers<T extends Organization$transfersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly account_number: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly contact_name: FieldRef<"Organization", 'String'>
    readonly phone: FieldRef<"Organization", 'String'>
    readonly phone_ext: FieldRef<"Organization", 'String'>
    readonly primary_email: FieldRef<"Organization", 'String'>
    readonly secondary_email: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly city: FieldRef<"Organization", 'String'>
    readonly province: FieldRef<"Organization", 'String'>
    readonly country: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.invoices
   */
  export type Organization$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Organization.arrivals_origin
   */
  export type Organization$arrivals_originArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    where?: ArrivalWhereInput
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    cursor?: ArrivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Organization.arrivals_transporter
   */
  export type Organization$arrivals_transporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrival
     */
    select?: ArrivalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrival
     */
    omit?: ArrivalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalInclude<ExtArgs> | null
    where?: ArrivalWhereInput
    orderBy?: ArrivalOrderByWithRelationInput | ArrivalOrderByWithRelationInput[]
    cursor?: ArrivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalScalarFieldEnum | ArrivalScalarFieldEnum[]
  }

  /**
   * Organization.departures_destination
   */
  export type Organization$departures_destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    cursor?: DepartureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Organization.departures_transporter
   */
  export type Organization$departures_transporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departure
     */
    select?: DepartureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departure
     */
    omit?: DepartureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartureInclude<ExtArgs> | null
    where?: DepartureWhereInput
    orderBy?: DepartureOrderByWithRelationInput | DepartureOrderByWithRelationInput[]
    cursor?: DepartureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartureScalarFieldEnum | DepartureScalarFieldEnum[]
  }

  /**
   * Organization.holds
   */
  export type Organization$holdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hold
     */
    select?: HoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hold
     */
    omit?: HoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldInclude<ExtArgs> | null
    where?: HoldWhereInput
    orderBy?: HoldOrderByWithRelationInput | HoldOrderByWithRelationInput[]
    cursor?: HoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldScalarFieldEnum | HoldScalarFieldEnum[]
  }

  /**
   * Organization.transfers
   */
  export type Organization$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model AssetHistory
   */

  export type AggregateAssetHistory = {
    _count: AssetHistoryCountAggregateOutputType | null
    _avg: AssetHistoryAvgAggregateOutputType | null
    _sum: AssetHistorySumAggregateOutputType | null
    _min: AssetHistoryMinAggregateOutputType | null
    _max: AssetHistoryMaxAggregateOutputType | null
  }

  export type AssetHistoryAvgAggregateOutputType = {
    id: number | null
    asset_id: number | null
    user_id: number | null
  }

  export type AssetHistorySumAggregateOutputType = {
    id: number | null
    asset_id: number | null
    user_id: number | null
  }

  export type AssetHistoryMinAggregateOutputType = {
    id: number | null
    asset_id: number | null
    user_id: number | null
    operation: $Enums.GeneralOperation | null
    data_field: $Enums.DataField | null
    changed_on: Date | null
  }

  export type AssetHistoryMaxAggregateOutputType = {
    id: number | null
    asset_id: number | null
    user_id: number | null
    operation: $Enums.GeneralOperation | null
    data_field: $Enums.DataField | null
    changed_on: Date | null
  }

  export type AssetHistoryCountAggregateOutputType = {
    id: number
    asset_id: number
    user_id: number
    operation: number
    data_field: number
    changed_on: number
    changes: number
    _all: number
  }


  export type AssetHistoryAvgAggregateInputType = {
    id?: true
    asset_id?: true
    user_id?: true
  }

  export type AssetHistorySumAggregateInputType = {
    id?: true
    asset_id?: true
    user_id?: true
  }

  export type AssetHistoryMinAggregateInputType = {
    id?: true
    asset_id?: true
    user_id?: true
    operation?: true
    data_field?: true
    changed_on?: true
  }

  export type AssetHistoryMaxAggregateInputType = {
    id?: true
    asset_id?: true
    user_id?: true
    operation?: true
    data_field?: true
    changed_on?: true
  }

  export type AssetHistoryCountAggregateInputType = {
    id?: true
    asset_id?: true
    user_id?: true
    operation?: true
    data_field?: true
    changed_on?: true
    changes?: true
    _all?: true
  }

  export type AssetHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetHistory to aggregate.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetHistories
    **/
    _count?: true | AssetHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetHistoryMaxAggregateInputType
  }

  export type GetAssetHistoryAggregateType<T extends AssetHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetHistory[P]>
      : GetScalarType<T[P], AggregateAssetHistory[P]>
  }




  export type AssetHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithAggregationInput | AssetHistoryOrderByWithAggregationInput[]
    by: AssetHistoryScalarFieldEnum[] | AssetHistoryScalarFieldEnum
    having?: AssetHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetHistoryCountAggregateInputType | true
    _avg?: AssetHistoryAvgAggregateInputType
    _sum?: AssetHistorySumAggregateInputType
    _min?: AssetHistoryMinAggregateInputType
    _max?: AssetHistoryMaxAggregateInputType
  }

  export type AssetHistoryGroupByOutputType = {
    id: number
    asset_id: number
    user_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date
    changes: JsonValue
    _count: AssetHistoryCountAggregateOutputType | null
    _avg: AssetHistoryAvgAggregateOutputType | null
    _sum: AssetHistorySumAggregateOutputType | null
    _min: AssetHistoryMinAggregateOutputType | null
    _max: AssetHistoryMaxAggregateOutputType | null
  }

  type GetAssetHistoryGroupByPayload<T extends AssetHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AssetHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AssetHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    user_id?: boolean
    operation?: boolean
    data_field?: boolean
    changed_on?: boolean
    changes?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetHistory"]>

  export type AssetHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    user_id?: boolean
    operation?: boolean
    data_field?: boolean
    changed_on?: boolean
    changes?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetHistory"]>

  export type AssetHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset_id?: boolean
    user_id?: boolean
    operation?: boolean
    data_field?: boolean
    changed_on?: boolean
    changes?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetHistory"]>

  export type AssetHistorySelectScalar = {
    id?: boolean
    asset_id?: boolean
    user_id?: boolean
    operation?: boolean
    data_field?: boolean
    changed_on?: boolean
    changes?: boolean
  }

  export type AssetHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset_id" | "user_id" | "operation" | "data_field" | "changed_on" | "changes", ExtArgs["result"]["assetHistory"]>
  export type AssetHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssetHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetHistory"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset_id: number
      user_id: number
      operation: $Enums.GeneralOperation
      data_field: $Enums.DataField
      changed_on: Date
      changes: Prisma.JsonValue
    }, ExtArgs["result"]["assetHistory"]>
    composites: {}
  }

  type AssetHistoryGetPayload<S extends boolean | null | undefined | AssetHistoryDefaultArgs> = $Result.GetResult<Prisma.$AssetHistoryPayload, S>

  type AssetHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetHistoryCountAggregateInputType | true
    }

  export interface AssetHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetHistory'], meta: { name: 'AssetHistory' } }
    /**
     * Find zero or one AssetHistory that matches the filter.
     * @param {AssetHistoryFindUniqueArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetHistoryFindUniqueArgs>(args: SelectSubset<T, AssetHistoryFindUniqueArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetHistoryFindUniqueOrThrowArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindFirstArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetHistoryFindFirstArgs>(args?: SelectSubset<T, AssetHistoryFindFirstArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindFirstOrThrowArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetHistories
     * const assetHistories = await prisma.assetHistory.findMany()
     * 
     * // Get first 10 AssetHistories
     * const assetHistories = await prisma.assetHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetHistoryWithIdOnly = await prisma.assetHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetHistoryFindManyArgs>(args?: SelectSubset<T, AssetHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetHistory.
     * @param {AssetHistoryCreateArgs} args - Arguments to create a AssetHistory.
     * @example
     * // Create one AssetHistory
     * const AssetHistory = await prisma.assetHistory.create({
     *   data: {
     *     // ... data to create a AssetHistory
     *   }
     * })
     * 
     */
    create<T extends AssetHistoryCreateArgs>(args: SelectSubset<T, AssetHistoryCreateArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetHistories.
     * @param {AssetHistoryCreateManyArgs} args - Arguments to create many AssetHistories.
     * @example
     * // Create many AssetHistories
     * const assetHistory = await prisma.assetHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetHistoryCreateManyArgs>(args?: SelectSubset<T, AssetHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetHistories and returns the data saved in the database.
     * @param {AssetHistoryCreateManyAndReturnArgs} args - Arguments to create many AssetHistories.
     * @example
     * // Create many AssetHistories
     * const assetHistory = await prisma.assetHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetHistories and only return the `id`
     * const assetHistoryWithIdOnly = await prisma.assetHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetHistory.
     * @param {AssetHistoryDeleteArgs} args - Arguments to delete one AssetHistory.
     * @example
     * // Delete one AssetHistory
     * const AssetHistory = await prisma.assetHistory.delete({
     *   where: {
     *     // ... filter to delete one AssetHistory
     *   }
     * })
     * 
     */
    delete<T extends AssetHistoryDeleteArgs>(args: SelectSubset<T, AssetHistoryDeleteArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetHistory.
     * @param {AssetHistoryUpdateArgs} args - Arguments to update one AssetHistory.
     * @example
     * // Update one AssetHistory
     * const assetHistory = await prisma.assetHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetHistoryUpdateArgs>(args: SelectSubset<T, AssetHistoryUpdateArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetHistories.
     * @param {AssetHistoryDeleteManyArgs} args - Arguments to filter AssetHistories to delete.
     * @example
     * // Delete a few AssetHistories
     * const { count } = await prisma.assetHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetHistoryDeleteManyArgs>(args?: SelectSubset<T, AssetHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetHistories
     * const assetHistory = await prisma.assetHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetHistoryUpdateManyArgs>(args: SelectSubset<T, AssetHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetHistories and returns the data updated in the database.
     * @param {AssetHistoryUpdateManyAndReturnArgs} args - Arguments to update many AssetHistories.
     * @example
     * // Update many AssetHistories
     * const assetHistory = await prisma.assetHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetHistories and only return the `id`
     * const assetHistoryWithIdOnly = await prisma.assetHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetHistory.
     * @param {AssetHistoryUpsertArgs} args - Arguments to update or create a AssetHistory.
     * @example
     * // Update or create a AssetHistory
     * const assetHistory = await prisma.assetHistory.upsert({
     *   create: {
     *     // ... data to create a AssetHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetHistory we want to update
     *   }
     * })
     */
    upsert<T extends AssetHistoryUpsertArgs>(args: SelectSubset<T, AssetHistoryUpsertArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryCountArgs} args - Arguments to filter AssetHistories to count.
     * @example
     * // Count the number of AssetHistories
     * const count = await prisma.assetHistory.count({
     *   where: {
     *     // ... the filter for the AssetHistories we want to count
     *   }
     * })
    **/
    count<T extends AssetHistoryCountArgs>(
      args?: Subset<T, AssetHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetHistoryAggregateArgs>(args: Subset<T, AssetHistoryAggregateArgs>): Prisma.PrismaPromise<GetAssetHistoryAggregateType<T>>

    /**
     * Group by AssetHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AssetHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetHistory model
   */
  readonly fields: AssetHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetHistory model
   */
  interface AssetHistoryFieldRefs {
    readonly id: FieldRef<"AssetHistory", 'Int'>
    readonly asset_id: FieldRef<"AssetHistory", 'Int'>
    readonly user_id: FieldRef<"AssetHistory", 'Int'>
    readonly operation: FieldRef<"AssetHistory", 'GeneralOperation'>
    readonly data_field: FieldRef<"AssetHistory", 'DataField'>
    readonly changed_on: FieldRef<"AssetHistory", 'DateTime'>
    readonly changes: FieldRef<"AssetHistory", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AssetHistory findUnique
   */
  export type AssetHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory findUniqueOrThrow
   */
  export type AssetHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory findFirst
   */
  export type AssetHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetHistories.
     */
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory findFirstOrThrow
   */
  export type AssetHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetHistories.
     */
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory findMany
   */
  export type AssetHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistories to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory create
   */
  export type AssetHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetHistory.
     */
    data: XOR<AssetHistoryCreateInput, AssetHistoryUncheckedCreateInput>
  }

  /**
   * AssetHistory createMany
   */
  export type AssetHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetHistories.
     */
    data: AssetHistoryCreateManyInput | AssetHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetHistory createManyAndReturn
   */
  export type AssetHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AssetHistories.
     */
    data: AssetHistoryCreateManyInput | AssetHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetHistory update
   */
  export type AssetHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetHistory.
     */
    data: XOR<AssetHistoryUpdateInput, AssetHistoryUncheckedUpdateInput>
    /**
     * Choose, which AssetHistory to update.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory updateMany
   */
  export type AssetHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetHistories.
     */
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetHistories to update
     */
    where?: AssetHistoryWhereInput
    /**
     * Limit how many AssetHistories to update.
     */
    limit?: number
  }

  /**
   * AssetHistory updateManyAndReturn
   */
  export type AssetHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AssetHistories.
     */
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetHistories to update
     */
    where?: AssetHistoryWhereInput
    /**
     * Limit how many AssetHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetHistory upsert
   */
  export type AssetHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetHistory to update in case it exists.
     */
    where: AssetHistoryWhereUniqueInput
    /**
     * In case the AssetHistory found by the `where` argument doesn't exist, create a new AssetHistory with this data.
     */
    create: XOR<AssetHistoryCreateInput, AssetHistoryUncheckedCreateInput>
    /**
     * In case the AssetHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetHistoryUpdateInput, AssetHistoryUncheckedUpdateInput>
  }

  /**
   * AssetHistory delete
   */
  export type AssetHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter which AssetHistory to delete.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory deleteMany
   */
  export type AssetHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetHistories to delete
     */
    where?: AssetHistoryWhereInput
    /**
     * Limit how many AssetHistories to delete.
     */
    limit?: number
  }

  /**
   * AssetHistory without action
   */
  export type AssetHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetHistory
     */
    omit?: AssetHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssetScalarFieldEnum: {
    id: 'id',
    barcode: 'barcode',
    serial_number: 'serial_number',
    brand_id: 'brand_id',
    model_id: 'model_id',
    warehouse_id: 'warehouse_id',
    asset_location: 'asset_location',
    asset_type: 'asset_type',
    tracking_status: 'tracking_status',
    exit_status: 'exit_status',
    technical_status: 'technical_status',
    purchase_invoice_id: 'purchase_invoice_id',
    sales_invoice_id: 'sales_invoice_id',
    arrival_id: 'arrival_id',
    departure_id: 'departure_id',
    hold_id: 'hold_id',
    is_held: 'is_held',
    created_at: 'created_at'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const TechnicalSpecificationScalarFieldEnum: {
    id: 'id',
    asset_id: 'asset_id',
    cassettes: 'cassettes',
    internal_finisher: 'internal_finisher',
    meter_black: 'meter_black',
    meter_colour: 'meter_colour',
    meter_total: 'meter_total',
    drum_life_c: 'drum_life_c',
    drum_life_m: 'drum_life_m',
    drum_life_y: 'drum_life_y',
    drum_life_k: 'drum_life_k'
  };

  export type TechnicalSpecificationScalarFieldEnum = (typeof TechnicalSpecificationScalarFieldEnum)[keyof typeof TechnicalSpecificationScalarFieldEnum]


  export const CostScalarFieldEnum: {
    id: 'id',
    asset_id: 'asset_id',
    purchase_cost: 'purchase_cost',
    transport_cost: 'transport_cost',
    processing_cost: 'processing_cost',
    other_cost: 'other_cost',
    parts_cost: 'parts_cost',
    total_cost: 'total_cost',
    sale_price: 'sale_price'
  };

  export type CostScalarFieldEnum = (typeof CostScalarFieldEnum)[keyof typeof CostScalarFieldEnum]


  export const AssetAccessoryScalarFieldEnum: {
    asset_id: 'asset_id',
    accessory: 'accessory'
  };

  export type AssetAccessoryScalarFieldEnum = (typeof AssetAccessoryScalarFieldEnum)[keyof typeof AssetAccessoryScalarFieldEnum]


  export const ErrorCategoryScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    category: 'category'
  };

  export type ErrorCategoryScalarFieldEnum = (typeof ErrorCategoryScalarFieldEnum)[keyof typeof ErrorCategoryScalarFieldEnum]


  export const ErrorScalarFieldEnum: {
    id: 'id',
    error_category_id: 'error_category_id',
    code: 'code',
    description: 'description'
  };

  export type ErrorScalarFieldEnum = (typeof ErrorScalarFieldEnum)[keyof typeof ErrorScalarFieldEnum]


  export const AssetErrorScalarFieldEnum: {
    asset_id: 'asset_id',
    error_id: 'error_id',
    is_fixed: 'is_fixed',
    added_by: 'added_by',
    added_at: 'added_at',
    fixed_by: 'fixed_by',
    fixed_at: 'fixed_at'
  };

  export type AssetErrorScalarFieldEnum = (typeof AssetErrorScalarFieldEnum)[keyof typeof AssetErrorScalarFieldEnum]


  export const PartScalarFieldEnum: {
    id: 'id',
    description: 'description',
    part_number: 'part_number',
    dealer_price: 'dealer_price',
    sale_price: 'sale_price',
    cost: 'cost'
  };

  export type PartScalarFieldEnum = (typeof PartScalarFieldEnum)[keyof typeof PartScalarFieldEnum]


  export const AssetPartScalarFieldEnum: {
    asset_id: 'asset_id',
    part_id: 'part_id',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    part_operation: 'part_operation'
  };

  export type AssetPartScalarFieldEnum = (typeof AssetPartScalarFieldEnum)[keyof typeof AssetPartScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    transfer_number: 'transfer_number',
    origin_id: 'origin_id',
    destination_id: 'destination_id',
    transporter_id: 'transporter_id',
    created_by_id: 'created_by_id',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const AssetTransferScalarFieldEnum: {
    asset_id: 'asset_id',
    transfer_id: 'transfer_id'
  };

  export type AssetTransferScalarFieldEnum = (typeof AssetTransferScalarFieldEnum)[keyof typeof AssetTransferScalarFieldEnum]


  export const ArrivalScalarFieldEnum: {
    id: 'id',
    arrival_number: 'arrival_number',
    origin_id: 'origin_id',
    destination_id: 'destination_id',
    transporter_id: 'transporter_id',
    created_by_id: 'created_by_id',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type ArrivalScalarFieldEnum = (typeof ArrivalScalarFieldEnum)[keyof typeof ArrivalScalarFieldEnum]


  export const DepartureScalarFieldEnum: {
    id: 'id',
    departure_number: 'departure_number',
    origin_id: 'origin_id',
    destination_id: 'destination_id',
    transporter_id: 'transporter_id',
    created_by_id: 'created_by_id',
    sales_representative_id: 'sales_representative_id',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type DepartureScalarFieldEnum = (typeof DepartureScalarFieldEnum)[keyof typeof DepartureScalarFieldEnum]


  export const HoldScalarFieldEnum: {
    id: 'id',
    hold_number: 'hold_number',
    created_by_id: 'created_by_id',
    created_for_id: 'created_for_id',
    customer_id: 'customer_id',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type HoldScalarFieldEnum = (typeof HoldScalarFieldEnum)[keyof typeof HoldScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    organization_id: 'organization_id',
    updated_by_id: 'updated_by_id',
    is_cleared: 'is_cleared',
    created_at: 'created_at',
    invoice_type: 'invoice_type'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    city_code: 'city_code',
    street: 'street'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    warehouse_id: 'warehouse_id',
    location: 'location'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    asset_type: 'asset_type',
    weight: 'weight',
    size: 'size',
    brand_id: 'brand_id'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    asset_id: 'asset_id',
    uploaded_by_id: 'uploaded_by_id',
    name: 'name',
    type: 'type',
    data: 'data',
    url: 'url',
    size: 'size',
    uploaded_at: 'uploaded_at'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    asset_id: 'asset_id',
    created_by_id: 'created_by_id',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    googleId: 'googleId',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    account_number: 'account_number',
    name: 'name',
    contact_name: 'contact_name',
    phone: 'phone',
    phone_ext: 'phone_ext',
    primary_email: 'primary_email',
    secondary_email: 'secondary_email',
    address: 'address',
    city: 'city',
    province: 'province',
    country: 'country',
    website: 'website'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const AssetHistoryScalarFieldEnum: {
    id: 'id',
    asset_id: 'asset_id',
    user_id: 'user_id',
    operation: 'operation',
    data_field: 'data_field',
    changed_on: 'changed_on',
    changes: 'changes'
  };

  export type AssetHistoryScalarFieldEnum = (typeof AssetHistoryScalarFieldEnum)[keyof typeof AssetHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AssetType'
   */
  export type EnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType'>
    


  /**
   * Reference to a field of type 'AssetType[]'
   */
  export type ListEnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType[]'>
    


  /**
   * Reference to a field of type 'TrackingStatus'
   */
  export type EnumTrackingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingStatus'>
    


  /**
   * Reference to a field of type 'TrackingStatus[]'
   */
  export type ListEnumTrackingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackingStatus[]'>
    


  /**
   * Reference to a field of type 'ExitStatus'
   */
  export type EnumExitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExitStatus'>
    


  /**
   * Reference to a field of type 'ExitStatus[]'
   */
  export type ListEnumExitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExitStatus[]'>
    


  /**
   * Reference to a field of type 'TechnicalStatus'
   */
  export type EnumTechnicalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechnicalStatus'>
    


  /**
   * Reference to a field of type 'TechnicalStatus[]'
   */
  export type ListEnumTechnicalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechnicalStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Accessory'
   */
  export type EnumAccessoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Accessory'>
    


  /**
   * Reference to a field of type 'Accessory[]'
   */
  export type ListEnumAccessoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Accessory[]'>
    


  /**
   * Reference to a field of type 'PartOperation'
   */
  export type EnumPartOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartOperation'>
    


  /**
   * Reference to a field of type 'PartOperation[]'
   */
  export type ListEnumPartOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartOperation[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'GeneralOperation'
   */
  export type EnumGeneralOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GeneralOperation'>
    


  /**
   * Reference to a field of type 'GeneralOperation[]'
   */
  export type ListEnumGeneralOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GeneralOperation[]'>
    


  /**
   * Reference to a field of type 'DataField'
   */
  export type EnumDataFieldFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataField'>
    


  /**
   * Reference to a field of type 'DataField[]'
   */
  export type ListEnumDataFieldFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataField[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: IntFilter<"Asset"> | number
    barcode?: StringFilter<"Asset"> | string
    serial_number?: StringFilter<"Asset"> | string
    brand_id?: IntFilter<"Asset"> | number
    model_id?: IntFilter<"Asset"> | number
    warehouse_id?: IntFilter<"Asset"> | number
    asset_location?: StringNullableFilter<"Asset"> | string | null
    asset_type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFilter<"Asset"> | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFilter<"Asset"> | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFilter<"Asset"> | $Enums.TechnicalStatus
    purchase_invoice_id?: IntNullableFilter<"Asset"> | number | null
    sales_invoice_id?: IntNullableFilter<"Asset"> | number | null
    arrival_id?: IntNullableFilter<"Asset"> | number | null
    departure_id?: IntNullableFilter<"Asset"> | number | null
    hold_id?: IntNullableFilter<"Asset"> | number | null
    is_held?: BoolFilter<"Asset"> | boolean
    created_at?: DateTimeFilter<"Asset"> | Date | string
    cost?: XOR<CostNullableScalarRelationFilter, CostWhereInput> | null
    technical_specification?: XOR<TechnicalSpecificationNullableScalarRelationFilter, TechnicalSpecificationWhereInput> | null
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    purchase_invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    sales_invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    arrival?: XOR<ArrivalNullableScalarRelationFilter, ArrivalWhereInput> | null
    departure?: XOR<DepartureNullableScalarRelationFilter, DepartureWhereInput> | null
    hold?: XOR<HoldNullableScalarRelationFilter, HoldWhereInput> | null
    asset_accessories?: AssetAccessoryListRelationFilter
    asset_errors?: AssetErrorListRelationFilter
    asset_parts?: AssetPartListRelationFilter
    asset_transfers?: AssetTransferListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    asset_history?: AssetHistoryListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    barcode?: SortOrder
    serial_number?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    asset_location?: SortOrderInput | SortOrder
    asset_type?: SortOrder
    tracking_status?: SortOrder
    exit_status?: SortOrder
    technical_status?: SortOrder
    purchase_invoice_id?: SortOrderInput | SortOrder
    sales_invoice_id?: SortOrderInput | SortOrder
    arrival_id?: SortOrderInput | SortOrder
    departure_id?: SortOrderInput | SortOrder
    hold_id?: SortOrderInput | SortOrder
    is_held?: SortOrder
    created_at?: SortOrder
    cost?: CostOrderByWithRelationInput
    technical_specification?: TechnicalSpecificationOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    purchase_invoice?: InvoiceOrderByWithRelationInput
    sales_invoice?: InvoiceOrderByWithRelationInput
    arrival?: ArrivalOrderByWithRelationInput
    departure?: DepartureOrderByWithRelationInput
    hold?: HoldOrderByWithRelationInput
    asset_accessories?: AssetAccessoryOrderByRelationAggregateInput
    asset_errors?: AssetErrorOrderByRelationAggregateInput
    asset_parts?: AssetPartOrderByRelationAggregateInput
    asset_transfers?: AssetTransferOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    asset_history?: AssetHistoryOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    barcode?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    serial_number?: StringFilter<"Asset"> | string
    brand_id?: IntFilter<"Asset"> | number
    model_id?: IntFilter<"Asset"> | number
    warehouse_id?: IntFilter<"Asset"> | number
    asset_location?: StringNullableFilter<"Asset"> | string | null
    asset_type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFilter<"Asset"> | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFilter<"Asset"> | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFilter<"Asset"> | $Enums.TechnicalStatus
    purchase_invoice_id?: IntNullableFilter<"Asset"> | number | null
    sales_invoice_id?: IntNullableFilter<"Asset"> | number | null
    arrival_id?: IntNullableFilter<"Asset"> | number | null
    departure_id?: IntNullableFilter<"Asset"> | number | null
    hold_id?: IntNullableFilter<"Asset"> | number | null
    is_held?: BoolFilter<"Asset"> | boolean
    created_at?: DateTimeFilter<"Asset"> | Date | string
    cost?: XOR<CostNullableScalarRelationFilter, CostWhereInput> | null
    technical_specification?: XOR<TechnicalSpecificationNullableScalarRelationFilter, TechnicalSpecificationWhereInput> | null
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    purchase_invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    sales_invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    arrival?: XOR<ArrivalNullableScalarRelationFilter, ArrivalWhereInput> | null
    departure?: XOR<DepartureNullableScalarRelationFilter, DepartureWhereInput> | null
    hold?: XOR<HoldNullableScalarRelationFilter, HoldWhereInput> | null
    asset_accessories?: AssetAccessoryListRelationFilter
    asset_errors?: AssetErrorListRelationFilter
    asset_parts?: AssetPartListRelationFilter
    asset_transfers?: AssetTransferListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    asset_history?: AssetHistoryListRelationFilter
  }, "id" | "barcode">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    barcode?: SortOrder
    serial_number?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    asset_location?: SortOrderInput | SortOrder
    asset_type?: SortOrder
    tracking_status?: SortOrder
    exit_status?: SortOrder
    technical_status?: SortOrder
    purchase_invoice_id?: SortOrderInput | SortOrder
    sales_invoice_id?: SortOrderInput | SortOrder
    arrival_id?: SortOrderInput | SortOrder
    departure_id?: SortOrderInput | SortOrder
    hold_id?: SortOrderInput | SortOrder
    is_held?: SortOrder
    created_at?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asset"> | number
    barcode?: StringWithAggregatesFilter<"Asset"> | string
    serial_number?: StringWithAggregatesFilter<"Asset"> | string
    brand_id?: IntWithAggregatesFilter<"Asset"> | number
    model_id?: IntWithAggregatesFilter<"Asset"> | number
    warehouse_id?: IntWithAggregatesFilter<"Asset"> | number
    asset_location?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    asset_type?: EnumAssetTypeWithAggregatesFilter<"Asset"> | $Enums.AssetType
    tracking_status?: EnumTrackingStatusWithAggregatesFilter<"Asset"> | $Enums.TrackingStatus
    exit_status?: EnumExitStatusWithAggregatesFilter<"Asset"> | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusWithAggregatesFilter<"Asset"> | $Enums.TechnicalStatus
    purchase_invoice_id?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    sales_invoice_id?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    arrival_id?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    departure_id?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    hold_id?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    is_held?: BoolWithAggregatesFilter<"Asset"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type TechnicalSpecificationWhereInput = {
    AND?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    OR?: TechnicalSpecificationWhereInput[]
    NOT?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    id?: IntFilter<"TechnicalSpecification"> | number
    asset_id?: IntFilter<"TechnicalSpecification"> | number
    cassettes?: IntNullableFilter<"TechnicalSpecification"> | number | null
    internal_finisher?: StringNullableFilter<"TechnicalSpecification"> | string | null
    meter_black?: IntNullableFilter<"TechnicalSpecification"> | number | null
    meter_colour?: IntNullableFilter<"TechnicalSpecification"> | number | null
    meter_total?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_c?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_m?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_y?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_k?: IntNullableFilter<"TechnicalSpecification"> | number | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }

  export type TechnicalSpecificationOrderByWithRelationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrderInput | SortOrder
    internal_finisher?: SortOrderInput | SortOrder
    meter_black?: SortOrderInput | SortOrder
    meter_colour?: SortOrderInput | SortOrder
    meter_total?: SortOrderInput | SortOrder
    drum_life_c?: SortOrderInput | SortOrder
    drum_life_m?: SortOrderInput | SortOrder
    drum_life_y?: SortOrderInput | SortOrder
    drum_life_k?: SortOrderInput | SortOrder
    asset?: AssetOrderByWithRelationInput
  }

  export type TechnicalSpecificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    asset_id?: number
    AND?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    OR?: TechnicalSpecificationWhereInput[]
    NOT?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    cassettes?: IntNullableFilter<"TechnicalSpecification"> | number | null
    internal_finisher?: StringNullableFilter<"TechnicalSpecification"> | string | null
    meter_black?: IntNullableFilter<"TechnicalSpecification"> | number | null
    meter_colour?: IntNullableFilter<"TechnicalSpecification"> | number | null
    meter_total?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_c?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_m?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_y?: IntNullableFilter<"TechnicalSpecification"> | number | null
    drum_life_k?: IntNullableFilter<"TechnicalSpecification"> | number | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }, "id" | "asset_id">

  export type TechnicalSpecificationOrderByWithAggregationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrderInput | SortOrder
    internal_finisher?: SortOrderInput | SortOrder
    meter_black?: SortOrderInput | SortOrder
    meter_colour?: SortOrderInput | SortOrder
    meter_total?: SortOrderInput | SortOrder
    drum_life_c?: SortOrderInput | SortOrder
    drum_life_m?: SortOrderInput | SortOrder
    drum_life_y?: SortOrderInput | SortOrder
    drum_life_k?: SortOrderInput | SortOrder
    _count?: TechnicalSpecificationCountOrderByAggregateInput
    _avg?: TechnicalSpecificationAvgOrderByAggregateInput
    _max?: TechnicalSpecificationMaxOrderByAggregateInput
    _min?: TechnicalSpecificationMinOrderByAggregateInput
    _sum?: TechnicalSpecificationSumOrderByAggregateInput
  }

  export type TechnicalSpecificationScalarWhereWithAggregatesInput = {
    AND?: TechnicalSpecificationScalarWhereWithAggregatesInput | TechnicalSpecificationScalarWhereWithAggregatesInput[]
    OR?: TechnicalSpecificationScalarWhereWithAggregatesInput[]
    NOT?: TechnicalSpecificationScalarWhereWithAggregatesInput | TechnicalSpecificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TechnicalSpecification"> | number
    asset_id?: IntWithAggregatesFilter<"TechnicalSpecification"> | number
    cassettes?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    internal_finisher?: StringNullableWithAggregatesFilter<"TechnicalSpecification"> | string | null
    meter_black?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    meter_colour?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    meter_total?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    drum_life_c?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    drum_life_m?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    drum_life_y?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
    drum_life_k?: IntNullableWithAggregatesFilter<"TechnicalSpecification"> | number | null
  }

  export type CostWhereInput = {
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    id?: IntFilter<"Cost"> | number
    asset_id?: IntFilter<"Cost"> | number
    purchase_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    transport_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    processing_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    other_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    parts_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    total_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    sale_price?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }

  export type CostOrderByWithRelationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrderInput | SortOrder
    transport_cost?: SortOrderInput | SortOrder
    processing_cost?: SortOrderInput | SortOrder
    other_cost?: SortOrderInput | SortOrder
    parts_cost?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    asset?: AssetOrderByWithRelationInput
  }

  export type CostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    asset_id?: number
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    purchase_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    transport_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    processing_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    other_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    parts_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    total_cost?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    sale_price?: DecimalNullableFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }, "id" | "asset_id">

  export type CostOrderByWithAggregationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrderInput | SortOrder
    transport_cost?: SortOrderInput | SortOrder
    processing_cost?: SortOrderInput | SortOrder
    other_cost?: SortOrderInput | SortOrder
    parts_cost?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    _count?: CostCountOrderByAggregateInput
    _avg?: CostAvgOrderByAggregateInput
    _max?: CostMaxOrderByAggregateInput
    _min?: CostMinOrderByAggregateInput
    _sum?: CostSumOrderByAggregateInput
  }

  export type CostScalarWhereWithAggregatesInput = {
    AND?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    OR?: CostScalarWhereWithAggregatesInput[]
    NOT?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cost"> | number
    asset_id?: IntWithAggregatesFilter<"Cost"> | number
    purchase_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    transport_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    processing_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    other_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    parts_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    total_cost?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
    sale_price?: DecimalNullableWithAggregatesFilter<"Cost"> | Decimal | DecimalJsLike | number | string | null
  }

  export type AssetAccessoryWhereInput = {
    AND?: AssetAccessoryWhereInput | AssetAccessoryWhereInput[]
    OR?: AssetAccessoryWhereInput[]
    NOT?: AssetAccessoryWhereInput | AssetAccessoryWhereInput[]
    asset_id?: IntFilter<"AssetAccessory"> | number
    accessory?: EnumAccessoryFilter<"AssetAccessory"> | $Enums.Accessory
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }

  export type AssetAccessoryOrderByWithRelationInput = {
    asset_id?: SortOrder
    accessory?: SortOrder
    asset?: AssetOrderByWithRelationInput
  }

  export type AssetAccessoryWhereUniqueInput = Prisma.AtLeast<{
    asset_id_accessory?: AssetAccessoryAsset_idAccessoryCompoundUniqueInput
    AND?: AssetAccessoryWhereInput | AssetAccessoryWhereInput[]
    OR?: AssetAccessoryWhereInput[]
    NOT?: AssetAccessoryWhereInput | AssetAccessoryWhereInput[]
    asset_id?: IntFilter<"AssetAccessory"> | number
    accessory?: EnumAccessoryFilter<"AssetAccessory"> | $Enums.Accessory
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }, "asset_id_accessory">

  export type AssetAccessoryOrderByWithAggregationInput = {
    asset_id?: SortOrder
    accessory?: SortOrder
    _count?: AssetAccessoryCountOrderByAggregateInput
    _avg?: AssetAccessoryAvgOrderByAggregateInput
    _max?: AssetAccessoryMaxOrderByAggregateInput
    _min?: AssetAccessoryMinOrderByAggregateInput
    _sum?: AssetAccessorySumOrderByAggregateInput
  }

  export type AssetAccessoryScalarWhereWithAggregatesInput = {
    AND?: AssetAccessoryScalarWhereWithAggregatesInput | AssetAccessoryScalarWhereWithAggregatesInput[]
    OR?: AssetAccessoryScalarWhereWithAggregatesInput[]
    NOT?: AssetAccessoryScalarWhereWithAggregatesInput | AssetAccessoryScalarWhereWithAggregatesInput[]
    asset_id?: IntWithAggregatesFilter<"AssetAccessory"> | number
    accessory?: EnumAccessoryWithAggregatesFilter<"AssetAccessory"> | $Enums.Accessory
  }

  export type ErrorCategoryWhereInput = {
    AND?: ErrorCategoryWhereInput | ErrorCategoryWhereInput[]
    OR?: ErrorCategoryWhereInput[]
    NOT?: ErrorCategoryWhereInput | ErrorCategoryWhereInput[]
    id?: IntFilter<"ErrorCategory"> | number
    brand_id?: IntFilter<"ErrorCategory"> | number
    category?: StringFilter<"ErrorCategory"> | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    errors?: ErrorListRelationFilter
  }

  export type ErrorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    category?: SortOrder
    brand?: BrandOrderByWithRelationInput
    errors?: ErrorOrderByRelationAggregateInput
  }

  export type ErrorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    category?: string
    AND?: ErrorCategoryWhereInput | ErrorCategoryWhereInput[]
    OR?: ErrorCategoryWhereInput[]
    NOT?: ErrorCategoryWhereInput | ErrorCategoryWhereInput[]
    brand_id?: IntFilter<"ErrorCategory"> | number
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    errors?: ErrorListRelationFilter
  }, "id" | "category">

  export type ErrorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    category?: SortOrder
    _count?: ErrorCategoryCountOrderByAggregateInput
    _avg?: ErrorCategoryAvgOrderByAggregateInput
    _max?: ErrorCategoryMaxOrderByAggregateInput
    _min?: ErrorCategoryMinOrderByAggregateInput
    _sum?: ErrorCategorySumOrderByAggregateInput
  }

  export type ErrorCategoryScalarWhereWithAggregatesInput = {
    AND?: ErrorCategoryScalarWhereWithAggregatesInput | ErrorCategoryScalarWhereWithAggregatesInput[]
    OR?: ErrorCategoryScalarWhereWithAggregatesInput[]
    NOT?: ErrorCategoryScalarWhereWithAggregatesInput | ErrorCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ErrorCategory"> | number
    brand_id?: IntWithAggregatesFilter<"ErrorCategory"> | number
    category?: StringWithAggregatesFilter<"ErrorCategory"> | string
  }

  export type ErrorWhereInput = {
    AND?: ErrorWhereInput | ErrorWhereInput[]
    OR?: ErrorWhereInput[]
    NOT?: ErrorWhereInput | ErrorWhereInput[]
    id?: IntFilter<"Error"> | number
    error_category_id?: IntFilter<"Error"> | number
    code?: StringFilter<"Error"> | string
    description?: StringNullableFilter<"Error"> | string | null
    category?: XOR<ErrorCategoryScalarRelationFilter, ErrorCategoryWhereInput>
    asset_errors?: AssetErrorListRelationFilter
  }

  export type ErrorOrderByWithRelationInput = {
    id?: SortOrder
    error_category_id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: ErrorCategoryOrderByWithRelationInput
    asset_errors?: AssetErrorOrderByRelationAggregateInput
  }

  export type ErrorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ErrorWhereInput | ErrorWhereInput[]
    OR?: ErrorWhereInput[]
    NOT?: ErrorWhereInput | ErrorWhereInput[]
    error_category_id?: IntFilter<"Error"> | number
    description?: StringNullableFilter<"Error"> | string | null
    category?: XOR<ErrorCategoryScalarRelationFilter, ErrorCategoryWhereInput>
    asset_errors?: AssetErrorListRelationFilter
  }, "id" | "code">

  export type ErrorOrderByWithAggregationInput = {
    id?: SortOrder
    error_category_id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ErrorCountOrderByAggregateInput
    _avg?: ErrorAvgOrderByAggregateInput
    _max?: ErrorMaxOrderByAggregateInput
    _min?: ErrorMinOrderByAggregateInput
    _sum?: ErrorSumOrderByAggregateInput
  }

  export type ErrorScalarWhereWithAggregatesInput = {
    AND?: ErrorScalarWhereWithAggregatesInput | ErrorScalarWhereWithAggregatesInput[]
    OR?: ErrorScalarWhereWithAggregatesInput[]
    NOT?: ErrorScalarWhereWithAggregatesInput | ErrorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Error"> | number
    error_category_id?: IntWithAggregatesFilter<"Error"> | number
    code?: StringWithAggregatesFilter<"Error"> | string
    description?: StringNullableWithAggregatesFilter<"Error"> | string | null
  }

  export type AssetErrorWhereInput = {
    AND?: AssetErrorWhereInput | AssetErrorWhereInput[]
    OR?: AssetErrorWhereInput[]
    NOT?: AssetErrorWhereInput | AssetErrorWhereInput[]
    asset_id?: IntFilter<"AssetError"> | number
    error_id?: IntFilter<"AssetError"> | number
    is_fixed?: BoolFilter<"AssetError"> | boolean
    added_by?: IntFilter<"AssetError"> | number
    added_at?: DateTimeFilter<"AssetError"> | Date | string
    fixed_by?: IntNullableFilter<"AssetError"> | number | null
    fixed_at?: DateTimeNullableFilter<"AssetError"> | Date | string | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    error?: XOR<ErrorScalarRelationFilter, ErrorWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    fixedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AssetErrorOrderByWithRelationInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    is_fixed?: SortOrder
    added_by?: SortOrder
    added_at?: SortOrder
    fixed_by?: SortOrderInput | SortOrder
    fixed_at?: SortOrderInput | SortOrder
    asset?: AssetOrderByWithRelationInput
    error?: ErrorOrderByWithRelationInput
    addedBy?: UserOrderByWithRelationInput
    fixedBy?: UserOrderByWithRelationInput
  }

  export type AssetErrorWhereUniqueInput = Prisma.AtLeast<{
    asset_id_error_id?: AssetErrorAsset_idError_idCompoundUniqueInput
    AND?: AssetErrorWhereInput | AssetErrorWhereInput[]
    OR?: AssetErrorWhereInput[]
    NOT?: AssetErrorWhereInput | AssetErrorWhereInput[]
    asset_id?: IntFilter<"AssetError"> | number
    error_id?: IntFilter<"AssetError"> | number
    is_fixed?: BoolFilter<"AssetError"> | boolean
    added_by?: IntFilter<"AssetError"> | number
    added_at?: DateTimeFilter<"AssetError"> | Date | string
    fixed_by?: IntNullableFilter<"AssetError"> | number | null
    fixed_at?: DateTimeNullableFilter<"AssetError"> | Date | string | null
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    error?: XOR<ErrorScalarRelationFilter, ErrorWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    fixedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "asset_id_error_id">

  export type AssetErrorOrderByWithAggregationInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    is_fixed?: SortOrder
    added_by?: SortOrder
    added_at?: SortOrder
    fixed_by?: SortOrderInput | SortOrder
    fixed_at?: SortOrderInput | SortOrder
    _count?: AssetErrorCountOrderByAggregateInput
    _avg?: AssetErrorAvgOrderByAggregateInput
    _max?: AssetErrorMaxOrderByAggregateInput
    _min?: AssetErrorMinOrderByAggregateInput
    _sum?: AssetErrorSumOrderByAggregateInput
  }

  export type AssetErrorScalarWhereWithAggregatesInput = {
    AND?: AssetErrorScalarWhereWithAggregatesInput | AssetErrorScalarWhereWithAggregatesInput[]
    OR?: AssetErrorScalarWhereWithAggregatesInput[]
    NOT?: AssetErrorScalarWhereWithAggregatesInput | AssetErrorScalarWhereWithAggregatesInput[]
    asset_id?: IntWithAggregatesFilter<"AssetError"> | number
    error_id?: IntWithAggregatesFilter<"AssetError"> | number
    is_fixed?: BoolWithAggregatesFilter<"AssetError"> | boolean
    added_by?: IntWithAggregatesFilter<"AssetError"> | number
    added_at?: DateTimeWithAggregatesFilter<"AssetError"> | Date | string
    fixed_by?: IntNullableWithAggregatesFilter<"AssetError"> | number | null
    fixed_at?: DateTimeNullableWithAggregatesFilter<"AssetError"> | Date | string | null
  }

  export type PartWhereInput = {
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    id?: IntFilter<"Part"> | number
    description?: StringFilter<"Part"> | string
    part_number?: StringFilter<"Part"> | string
    dealer_price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartListRelationFilter
  }

  export type PartOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    part_number?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
    asset_parts?: AssetPartOrderByRelationAggregateInput
  }

  export type PartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    part_number?: string
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    description?: StringFilter<"Part"> | string
    dealer_price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartListRelationFilter
  }, "id" | "part_number">

  export type PartOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    part_number?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
    _count?: PartCountOrderByAggregateInput
    _avg?: PartAvgOrderByAggregateInput
    _max?: PartMaxOrderByAggregateInput
    _min?: PartMinOrderByAggregateInput
    _sum?: PartSumOrderByAggregateInput
  }

  export type PartScalarWhereWithAggregatesInput = {
    AND?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    OR?: PartScalarWhereWithAggregatesInput[]
    NOT?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Part"> | number
    description?: StringWithAggregatesFilter<"Part"> | string
    part_number?: StringWithAggregatesFilter<"Part"> | string
    dealer_price?: DecimalWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string
  }

  export type AssetPartWhereInput = {
    AND?: AssetPartWhereInput | AssetPartWhereInput[]
    OR?: AssetPartWhereInput[]
    NOT?: AssetPartWhereInput | AssetPartWhereInput[]
    asset_id?: IntFilter<"AssetPart"> | number
    part_id?: IntFilter<"AssetPart"> | number
    updated_at?: DateTimeFilter<"AssetPart"> | Date | string
    updated_by?: IntFilter<"AssetPart"> | number
    part_operation?: EnumPartOperationFilter<"AssetPart"> | $Enums.PartOperation
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AssetPartOrderByWithRelationInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    part_operation?: SortOrder
    asset?: AssetOrderByWithRelationInput
    part?: PartOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type AssetPartWhereUniqueInput = Prisma.AtLeast<{
    asset_id_part_id?: AssetPartAsset_idPart_idCompoundUniqueInput
    AND?: AssetPartWhereInput | AssetPartWhereInput[]
    OR?: AssetPartWhereInput[]
    NOT?: AssetPartWhereInput | AssetPartWhereInput[]
    asset_id?: IntFilter<"AssetPart"> | number
    part_id?: IntFilter<"AssetPart"> | number
    updated_at?: DateTimeFilter<"AssetPart"> | Date | string
    updated_by?: IntFilter<"AssetPart"> | number
    part_operation?: EnumPartOperationFilter<"AssetPart"> | $Enums.PartOperation
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "asset_id_part_id">

  export type AssetPartOrderByWithAggregationInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    part_operation?: SortOrder
    _count?: AssetPartCountOrderByAggregateInput
    _avg?: AssetPartAvgOrderByAggregateInput
    _max?: AssetPartMaxOrderByAggregateInput
    _min?: AssetPartMinOrderByAggregateInput
    _sum?: AssetPartSumOrderByAggregateInput
  }

  export type AssetPartScalarWhereWithAggregatesInput = {
    AND?: AssetPartScalarWhereWithAggregatesInput | AssetPartScalarWhereWithAggregatesInput[]
    OR?: AssetPartScalarWhereWithAggregatesInput[]
    NOT?: AssetPartScalarWhereWithAggregatesInput | AssetPartScalarWhereWithAggregatesInput[]
    asset_id?: IntWithAggregatesFilter<"AssetPart"> | number
    part_id?: IntWithAggregatesFilter<"AssetPart"> | number
    updated_at?: DateTimeWithAggregatesFilter<"AssetPart"> | Date | string
    updated_by?: IntWithAggregatesFilter<"AssetPart"> | number
    part_operation?: EnumPartOperationWithAggregatesFilter<"AssetPart"> | $Enums.PartOperation
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: IntFilter<"Transfer"> | number
    transfer_number?: StringFilter<"Transfer"> | string
    origin_id?: IntFilter<"Transfer"> | number
    destination_id?: IntFilter<"Transfer"> | number
    transporter_id?: IntFilter<"Transfer"> | number
    created_by_id?: IntFilter<"Transfer"> | number
    notes?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
    origin?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    destination?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    asset_transfers?: AssetTransferListRelationFilter
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    transfer_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    origin?: WarehouseOrderByWithRelationInput
    destination?: WarehouseOrderByWithRelationInput
    transporter?: OrganizationOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
    asset_transfers?: AssetTransferOrderByRelationAggregateInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transfer_number?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    origin_id?: IntFilter<"Transfer"> | number
    destination_id?: IntFilter<"Transfer"> | number
    transporter_id?: IntFilter<"Transfer"> | number
    created_by_id?: IntFilter<"Transfer"> | number
    notes?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
    origin?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    destination?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    asset_transfers?: AssetTransferListRelationFilter
  }, "id" | "transfer_number">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    transfer_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transfer"> | number
    transfer_number?: StringWithAggregatesFilter<"Transfer"> | string
    origin_id?: IntWithAggregatesFilter<"Transfer"> | number
    destination_id?: IntWithAggregatesFilter<"Transfer"> | number
    transporter_id?: IntWithAggregatesFilter<"Transfer"> | number
    created_by_id?: IntWithAggregatesFilter<"Transfer"> | number
    notes?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type AssetTransferWhereInput = {
    AND?: AssetTransferWhereInput | AssetTransferWhereInput[]
    OR?: AssetTransferWhereInput[]
    NOT?: AssetTransferWhereInput | AssetTransferWhereInput[]
    asset_id?: IntFilter<"AssetTransfer"> | number
    transfer_id?: IntFilter<"AssetTransfer"> | number
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }

  export type AssetTransferOrderByWithRelationInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
    asset?: AssetOrderByWithRelationInput
    transfer?: TransferOrderByWithRelationInput
  }

  export type AssetTransferWhereUniqueInput = Prisma.AtLeast<{
    asset_id_transfer_id?: AssetTransferAsset_idTransfer_idCompoundUniqueInput
    AND?: AssetTransferWhereInput | AssetTransferWhereInput[]
    OR?: AssetTransferWhereInput[]
    NOT?: AssetTransferWhereInput | AssetTransferWhereInput[]
    asset_id?: IntFilter<"AssetTransfer"> | number
    transfer_id?: IntFilter<"AssetTransfer"> | number
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }, "asset_id_transfer_id">

  export type AssetTransferOrderByWithAggregationInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
    _count?: AssetTransferCountOrderByAggregateInput
    _avg?: AssetTransferAvgOrderByAggregateInput
    _max?: AssetTransferMaxOrderByAggregateInput
    _min?: AssetTransferMinOrderByAggregateInput
    _sum?: AssetTransferSumOrderByAggregateInput
  }

  export type AssetTransferScalarWhereWithAggregatesInput = {
    AND?: AssetTransferScalarWhereWithAggregatesInput | AssetTransferScalarWhereWithAggregatesInput[]
    OR?: AssetTransferScalarWhereWithAggregatesInput[]
    NOT?: AssetTransferScalarWhereWithAggregatesInput | AssetTransferScalarWhereWithAggregatesInput[]
    asset_id?: IntWithAggregatesFilter<"AssetTransfer"> | number
    transfer_id?: IntWithAggregatesFilter<"AssetTransfer"> | number
  }

  export type ArrivalWhereInput = {
    AND?: ArrivalWhereInput | ArrivalWhereInput[]
    OR?: ArrivalWhereInput[]
    NOT?: ArrivalWhereInput | ArrivalWhereInput[]
    id?: IntFilter<"Arrival"> | number
    arrival_number?: StringFilter<"Arrival"> | string
    origin_id?: IntFilter<"Arrival"> | number
    destination_id?: IntFilter<"Arrival"> | number
    transporter_id?: IntFilter<"Arrival"> | number
    created_by_id?: IntFilter<"Arrival"> | number
    notes?: StringNullableFilter<"Arrival"> | string | null
    created_at?: DateTimeFilter<"Arrival"> | Date | string
    origin?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    destination?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
  }

  export type ArrivalOrderByWithRelationInput = {
    id?: SortOrder
    arrival_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    origin?: OrganizationOrderByWithRelationInput
    destination?: WarehouseOrderByWithRelationInput
    transporter?: OrganizationOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type ArrivalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    arrival_number?: string
    AND?: ArrivalWhereInput | ArrivalWhereInput[]
    OR?: ArrivalWhereInput[]
    NOT?: ArrivalWhereInput | ArrivalWhereInput[]
    origin_id?: IntFilter<"Arrival"> | number
    destination_id?: IntFilter<"Arrival"> | number
    transporter_id?: IntFilter<"Arrival"> | number
    created_by_id?: IntFilter<"Arrival"> | number
    notes?: StringNullableFilter<"Arrival"> | string | null
    created_at?: DateTimeFilter<"Arrival"> | Date | string
    origin?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    destination?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
  }, "id" | "arrival_number">

  export type ArrivalOrderByWithAggregationInput = {
    id?: SortOrder
    arrival_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ArrivalCountOrderByAggregateInput
    _avg?: ArrivalAvgOrderByAggregateInput
    _max?: ArrivalMaxOrderByAggregateInput
    _min?: ArrivalMinOrderByAggregateInput
    _sum?: ArrivalSumOrderByAggregateInput
  }

  export type ArrivalScalarWhereWithAggregatesInput = {
    AND?: ArrivalScalarWhereWithAggregatesInput | ArrivalScalarWhereWithAggregatesInput[]
    OR?: ArrivalScalarWhereWithAggregatesInput[]
    NOT?: ArrivalScalarWhereWithAggregatesInput | ArrivalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Arrival"> | number
    arrival_number?: StringWithAggregatesFilter<"Arrival"> | string
    origin_id?: IntWithAggregatesFilter<"Arrival"> | number
    destination_id?: IntWithAggregatesFilter<"Arrival"> | number
    transporter_id?: IntWithAggregatesFilter<"Arrival"> | number
    created_by_id?: IntWithAggregatesFilter<"Arrival"> | number
    notes?: StringNullableWithAggregatesFilter<"Arrival"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Arrival"> | Date | string
  }

  export type DepartureWhereInput = {
    AND?: DepartureWhereInput | DepartureWhereInput[]
    OR?: DepartureWhereInput[]
    NOT?: DepartureWhereInput | DepartureWhereInput[]
    id?: IntFilter<"Departure"> | number
    departure_number?: StringFilter<"Departure"> | string
    origin_id?: IntFilter<"Departure"> | number
    destination_id?: IntFilter<"Departure"> | number
    transporter_id?: IntFilter<"Departure"> | number
    created_by_id?: IntFilter<"Departure"> | number
    sales_representative_id?: IntFilter<"Departure"> | number
    notes?: StringNullableFilter<"Departure"> | string | null
    created_at?: DateTimeFilter<"Departure"> | Date | string
    origin?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    destination?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    sales_representative?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
  }

  export type DepartureOrderByWithRelationInput = {
    id?: SortOrder
    departure_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    origin?: WarehouseOrderByWithRelationInput
    destination?: OrganizationOrderByWithRelationInput
    transporter?: OrganizationOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
    sales_representative?: UserOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type DepartureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    departure_number?: string
    AND?: DepartureWhereInput | DepartureWhereInput[]
    OR?: DepartureWhereInput[]
    NOT?: DepartureWhereInput | DepartureWhereInput[]
    origin_id?: IntFilter<"Departure"> | number
    destination_id?: IntFilter<"Departure"> | number
    transporter_id?: IntFilter<"Departure"> | number
    created_by_id?: IntFilter<"Departure"> | number
    sales_representative_id?: IntFilter<"Departure"> | number
    notes?: StringNullableFilter<"Departure"> | string | null
    created_at?: DateTimeFilter<"Departure"> | Date | string
    origin?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    destination?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    transporter?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    sales_representative?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
  }, "id" | "departure_number">

  export type DepartureOrderByWithAggregationInput = {
    id?: SortOrder
    departure_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: DepartureCountOrderByAggregateInput
    _avg?: DepartureAvgOrderByAggregateInput
    _max?: DepartureMaxOrderByAggregateInput
    _min?: DepartureMinOrderByAggregateInput
    _sum?: DepartureSumOrderByAggregateInput
  }

  export type DepartureScalarWhereWithAggregatesInput = {
    AND?: DepartureScalarWhereWithAggregatesInput | DepartureScalarWhereWithAggregatesInput[]
    OR?: DepartureScalarWhereWithAggregatesInput[]
    NOT?: DepartureScalarWhereWithAggregatesInput | DepartureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Departure"> | number
    departure_number?: StringWithAggregatesFilter<"Departure"> | string
    origin_id?: IntWithAggregatesFilter<"Departure"> | number
    destination_id?: IntWithAggregatesFilter<"Departure"> | number
    transporter_id?: IntWithAggregatesFilter<"Departure"> | number
    created_by_id?: IntWithAggregatesFilter<"Departure"> | number
    sales_representative_id?: IntWithAggregatesFilter<"Departure"> | number
    notes?: StringNullableWithAggregatesFilter<"Departure"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Departure"> | Date | string
  }

  export type HoldWhereInput = {
    AND?: HoldWhereInput | HoldWhereInput[]
    OR?: HoldWhereInput[]
    NOT?: HoldWhereInput | HoldWhereInput[]
    id?: IntFilter<"Hold"> | number
    hold_number?: StringFilter<"Hold"> | string
    created_by_id?: IntFilter<"Hold"> | number
    created_for_id?: IntFilter<"Hold"> | number
    customer_id?: IntFilter<"Hold"> | number
    notes?: StringNullableFilter<"Hold"> | string | null
    created_at?: DateTimeFilter<"Hold"> | Date | string
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    created_for?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    assets?: AssetListRelationFilter
  }

  export type HoldOrderByWithRelationInput = {
    id?: SortOrder
    hold_number?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: UserOrderByWithRelationInput
    created_for?: UserOrderByWithRelationInput
    customer?: OrganizationOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type HoldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hold_number?: string
    AND?: HoldWhereInput | HoldWhereInput[]
    OR?: HoldWhereInput[]
    NOT?: HoldWhereInput | HoldWhereInput[]
    created_by_id?: IntFilter<"Hold"> | number
    created_for_id?: IntFilter<"Hold"> | number
    customer_id?: IntFilter<"Hold"> | number
    notes?: StringNullableFilter<"Hold"> | string | null
    created_at?: DateTimeFilter<"Hold"> | Date | string
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    created_for?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    assets?: AssetListRelationFilter
  }, "id" | "hold_number">

  export type HoldOrderByWithAggregationInput = {
    id?: SortOrder
    hold_number?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: HoldCountOrderByAggregateInput
    _avg?: HoldAvgOrderByAggregateInput
    _max?: HoldMaxOrderByAggregateInput
    _min?: HoldMinOrderByAggregateInput
    _sum?: HoldSumOrderByAggregateInput
  }

  export type HoldScalarWhereWithAggregatesInput = {
    AND?: HoldScalarWhereWithAggregatesInput | HoldScalarWhereWithAggregatesInput[]
    OR?: HoldScalarWhereWithAggregatesInput[]
    NOT?: HoldScalarWhereWithAggregatesInput | HoldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hold"> | number
    hold_number?: StringWithAggregatesFilter<"Hold"> | string
    created_by_id?: IntWithAggregatesFilter<"Hold"> | number
    created_for_id?: IntWithAggregatesFilter<"Hold"> | number
    customer_id?: IntWithAggregatesFilter<"Hold"> | number
    notes?: StringNullableWithAggregatesFilter<"Hold"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Hold"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    invoice_number?: StringFilter<"Invoice"> | string
    organization_id?: IntFilter<"Invoice"> | number
    updated_by_id?: IntFilter<"Invoice"> | number
    is_cleared?: BoolFilter<"Invoice"> | boolean
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    invoice_type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    updated_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchase_assets?: AssetListRelationFilter
    sales_assets?: AssetListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
    is_cleared?: SortOrder
    created_at?: SortOrder
    invoice_type?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    updated_by?: UserOrderByWithRelationInput
    purchase_assets?: AssetOrderByRelationAggregateInput
    sales_assets?: AssetOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoice_number?: StringFilter<"Invoice"> | string
    organization_id?: IntFilter<"Invoice"> | number
    updated_by_id?: IntFilter<"Invoice"> | number
    is_cleared?: BoolFilter<"Invoice"> | boolean
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    invoice_type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    updated_by?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchase_assets?: AssetListRelationFilter
    sales_assets?: AssetListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
    is_cleared?: SortOrder
    created_at?: SortOrder
    invoice_type?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    invoice_number?: StringWithAggregatesFilter<"Invoice"> | string
    organization_id?: IntWithAggregatesFilter<"Invoice"> | number
    updated_by_id?: IntWithAggregatesFilter<"Invoice"> | number
    is_cleared?: BoolWithAggregatesFilter<"Invoice"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    invoice_type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    city_code?: StringFilter<"Warehouse"> | string
    street?: StringFilter<"Warehouse"> | string
    assets?: AssetListRelationFilter
    origin_transfers?: TransferListRelationFilter
    destination_transfers?: TransferListRelationFilter
    departures?: DepartureListRelationFilter
    arrivals?: ArrivalListRelationFilter
    locations?: LocationListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    city_code?: SortOrder
    street?: SortOrder
    assets?: AssetOrderByRelationAggregateInput
    origin_transfers?: TransferOrderByRelationAggregateInput
    destination_transfers?: TransferOrderByRelationAggregateInput
    departures?: DepartureOrderByRelationAggregateInput
    arrivals?: ArrivalOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    city_code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    street?: StringFilter<"Warehouse"> | string
    assets?: AssetListRelationFilter
    origin_transfers?: TransferListRelationFilter
    destination_transfers?: TransferListRelationFilter
    departures?: DepartureListRelationFilter
    arrivals?: ArrivalListRelationFilter
    locations?: LocationListRelationFilter
  }, "id" | "city_code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    city_code?: SortOrder
    street?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    city_code?: StringWithAggregatesFilter<"Warehouse"> | string
    street?: StringWithAggregatesFilter<"Warehouse"> | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    warehouse_id?: IntFilter<"Location"> | number
    location?: StringFilter<"Location"> | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    assets?: AssetListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    warehouse_id?: SortOrder
    location?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    warehouse_id_location?: LocationWarehouse_idLocationCompoundUniqueInput
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    warehouse_id?: IntFilter<"Location"> | number
    location?: StringFilter<"Location"> | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    assets?: AssetListRelationFilter
  }, "warehouse_id_location">

  export type LocationOrderByWithAggregationInput = {
    warehouse_id?: SortOrder
    location?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    warehouse_id?: IntWithAggregatesFilter<"Location"> | number
    location?: StringWithAggregatesFilter<"Location"> | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    models?: ModelListRelationFilter
    errorCategories?: ErrorCategoryListRelationFilter
    assets?: AssetListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    models?: ModelOrderByRelationAggregateInput
    errorCategories?: ErrorCategoryOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    models?: ModelListRelationFilter
    errorCategories?: ErrorCategoryListRelationFilter
    assets?: AssetListRelationFilter
  }, "id" | "name">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringWithAggregatesFilter<"Brand"> | string
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: IntFilter<"Model"> | number
    name?: StringFilter<"Model"> | string
    asset_type?: EnumAssetTypeFilter<"Model"> | $Enums.AssetType
    weight?: FloatFilter<"Model"> | number
    size?: FloatFilter<"Model"> | number
    brand_id?: IntFilter<"Model"> | number
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    assets?: AssetListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    asset_type?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
    brand?: BrandOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_brand_id?: ModelNameBrand_idCompoundUniqueInput
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    name?: StringFilter<"Model"> | string
    asset_type?: EnumAssetTypeFilter<"Model"> | $Enums.AssetType
    weight?: FloatFilter<"Model"> | number
    size?: FloatFilter<"Model"> | number
    brand_id?: IntFilter<"Model"> | number
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    assets?: AssetListRelationFilter
  }, "id" | "name_brand_id">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    asset_type?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _avg?: ModelAvgOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
    _sum?: ModelSumOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Model"> | number
    name?: StringWithAggregatesFilter<"Model"> | string
    asset_type?: EnumAssetTypeWithAggregatesFilter<"Model"> | $Enums.AssetType
    weight?: FloatWithAggregatesFilter<"Model"> | number
    size?: FloatWithAggregatesFilter<"Model"> | number
    brand_id?: IntWithAggregatesFilter<"Model"> | number
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: IntFilter<"File"> | number
    asset_id?: IntFilter<"File"> | number
    uploaded_by_id?: IntFilter<"File"> | number
    name?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    data?: BytesFilter<"File"> | Uint8Array
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    uploaded_at?: DateTimeFilter<"File"> | Date | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    uploaded_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    data?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploaded_at?: SortOrder
    asset?: AssetOrderByWithRelationInput
    uploaded_by?: UserOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    asset_id?: IntFilter<"File"> | number
    uploaded_by_id?: IntFilter<"File"> | number
    name?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    data?: BytesFilter<"File"> | Uint8Array
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    uploaded_at?: DateTimeFilter<"File"> | Date | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    uploaded_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    data?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploaded_at?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"File"> | number
    asset_id?: IntWithAggregatesFilter<"File"> | number
    uploaded_by_id?: IntWithAggregatesFilter<"File"> | number
    name?: StringWithAggregatesFilter<"File"> | string
    type?: EnumFileTypeWithAggregatesFilter<"File"> | $Enums.FileType
    data?: BytesWithAggregatesFilter<"File"> | Uint8Array
    url?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    uploaded_at?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    asset_id?: IntFilter<"Comment"> | number
    created_by_id?: IntFilter<"Comment"> | number
    comment?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    asset?: AssetOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    asset_id?: IntFilter<"Comment"> | number
    created_by_id?: IntFilter<"Comment"> | number
    comment?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    asset_id?: IntWithAggregatesFilter<"Comment"> | number
    created_by_id?: IntWithAggregatesFilter<"Comment"> | number
    comment?: StringWithAggregatesFilter<"Comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    asset_errors_added?: AssetErrorListRelationFilter
    asset_errors_fixed?: AssetErrorListRelationFilter
    transfers?: TransferListRelationFilter
    departures?: DepartureListRelationFilter
    departure_sales_reps?: DepartureListRelationFilter
    arrivals?: ArrivalListRelationFilter
    holds_created?: HoldListRelationFilter
    holds_for?: HoldListRelationFilter
    invoices_updated?: InvoiceListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    asset_history?: AssetHistoryListRelationFilter
    asset_parts?: AssetPartListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    asset_errors_added?: AssetErrorOrderByRelationAggregateInput
    asset_errors_fixed?: AssetErrorOrderByRelationAggregateInput
    transfers?: TransferOrderByRelationAggregateInput
    departures?: DepartureOrderByRelationAggregateInput
    departure_sales_reps?: DepartureOrderByRelationAggregateInput
    arrivals?: ArrivalOrderByRelationAggregateInput
    holds_created?: HoldOrderByRelationAggregateInput
    holds_for?: HoldOrderByRelationAggregateInput
    invoices_updated?: InvoiceOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    asset_history?: AssetHistoryOrderByRelationAggregateInput
    asset_parts?: AssetPartOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    name?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    asset_errors_added?: AssetErrorListRelationFilter
    asset_errors_fixed?: AssetErrorListRelationFilter
    transfers?: TransferListRelationFilter
    departures?: DepartureListRelationFilter
    departure_sales_reps?: DepartureListRelationFilter
    arrivals?: ArrivalListRelationFilter
    holds_created?: HoldListRelationFilter
    holds_for?: HoldListRelationFilter
    invoices_updated?: InvoiceListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    asset_history?: AssetHistoryListRelationFilter
    asset_parts?: AssetPartListRelationFilter
  }, "id" | "email" | "name" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    account_number?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    contact_name?: StringNullableFilter<"Organization"> | string | null
    phone?: StringNullableFilter<"Organization"> | string | null
    phone_ext?: StringNullableFilter<"Organization"> | string | null
    primary_email?: StringNullableFilter<"Organization"> | string | null
    secondary_email?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    province?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    invoices?: InvoiceListRelationFilter
    arrivals_origin?: ArrivalListRelationFilter
    arrivals_transporter?: ArrivalListRelationFilter
    departures_destination?: DepartureListRelationFilter
    departures_transporter?: DepartureListRelationFilter
    holds?: HoldListRelationFilter
    transfers?: TransferListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    account_number?: SortOrder
    name?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone_ext?: SortOrderInput | SortOrder
    primary_email?: SortOrderInput | SortOrder
    secondary_email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    arrivals_origin?: ArrivalOrderByRelationAggregateInput
    arrivals_transporter?: ArrivalOrderByRelationAggregateInput
    departures_destination?: DepartureOrderByRelationAggregateInput
    departures_transporter?: DepartureOrderByRelationAggregateInput
    holds?: HoldOrderByRelationAggregateInput
    transfers?: TransferOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    account_number?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    contact_name?: StringNullableFilter<"Organization"> | string | null
    phone?: StringNullableFilter<"Organization"> | string | null
    phone_ext?: StringNullableFilter<"Organization"> | string | null
    primary_email?: StringNullableFilter<"Organization"> | string | null
    secondary_email?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    province?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    invoices?: InvoiceListRelationFilter
    arrivals_origin?: ArrivalListRelationFilter
    arrivals_transporter?: ArrivalListRelationFilter
    departures_destination?: DepartureListRelationFilter
    departures_transporter?: DepartureListRelationFilter
    holds?: HoldListRelationFilter
    transfers?: TransferListRelationFilter
  }, "id" | "account_number">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    account_number?: SortOrder
    name?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone_ext?: SortOrderInput | SortOrder
    primary_email?: SortOrderInput | SortOrder
    secondary_email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    account_number?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    contact_name?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    phone_ext?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    primary_email?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    secondary_email?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    province?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
  }

  export type AssetHistoryWhereInput = {
    AND?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    OR?: AssetHistoryWhereInput[]
    NOT?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    id?: IntFilter<"AssetHistory"> | number
    asset_id?: IntFilter<"AssetHistory"> | number
    user_id?: IntFilter<"AssetHistory"> | number
    operation?: EnumGeneralOperationFilter<"AssetHistory"> | $Enums.GeneralOperation
    data_field?: EnumDataFieldFilter<"AssetHistory"> | $Enums.DataField
    changed_on?: DateTimeFilter<"AssetHistory"> | Date | string
    changes?: JsonFilter<"AssetHistory">
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AssetHistoryOrderByWithRelationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
    operation?: SortOrder
    data_field?: SortOrder
    changed_on?: SortOrder
    changes?: SortOrder
    asset?: AssetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AssetHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    OR?: AssetHistoryWhereInput[]
    NOT?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    asset_id?: IntFilter<"AssetHistory"> | number
    user_id?: IntFilter<"AssetHistory"> | number
    operation?: EnumGeneralOperationFilter<"AssetHistory"> | $Enums.GeneralOperation
    data_field?: EnumDataFieldFilter<"AssetHistory"> | $Enums.DataField
    changed_on?: DateTimeFilter<"AssetHistory"> | Date | string
    changes?: JsonFilter<"AssetHistory">
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AssetHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
    operation?: SortOrder
    data_field?: SortOrder
    changed_on?: SortOrder
    changes?: SortOrder
    _count?: AssetHistoryCountOrderByAggregateInput
    _avg?: AssetHistoryAvgOrderByAggregateInput
    _max?: AssetHistoryMaxOrderByAggregateInput
    _min?: AssetHistoryMinOrderByAggregateInput
    _sum?: AssetHistorySumOrderByAggregateInput
  }

  export type AssetHistoryScalarWhereWithAggregatesInput = {
    AND?: AssetHistoryScalarWhereWithAggregatesInput | AssetHistoryScalarWhereWithAggregatesInput[]
    OR?: AssetHistoryScalarWhereWithAggregatesInput[]
    NOT?: AssetHistoryScalarWhereWithAggregatesInput | AssetHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetHistory"> | number
    asset_id?: IntWithAggregatesFilter<"AssetHistory"> | number
    user_id?: IntWithAggregatesFilter<"AssetHistory"> | number
    operation?: EnumGeneralOperationWithAggregatesFilter<"AssetHistory"> | $Enums.GeneralOperation
    data_field?: EnumDataFieldWithAggregatesFilter<"AssetHistory"> | $Enums.DataField
    changed_on?: DateTimeWithAggregatesFilter<"AssetHistory"> | Date | string
    changes?: JsonWithAggregatesFilter<"AssetHistory">
  }

  export type AssetCreateInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicalSpecificationCreateInput = {
    cassettes?: number | null
    internal_finisher?: string | null
    meter_black?: number | null
    meter_colour?: number | null
    meter_total?: number | null
    drum_life_c?: number | null
    drum_life_m?: number | null
    drum_life_y?: number | null
    drum_life_k?: number | null
    asset: AssetCreateNestedOneWithoutTechnical_specificationInput
  }

  export type TechnicalSpecificationUncheckedCreateInput = {
    id?: number
    asset_id: number
    cassettes?: number | null
    internal_finisher?: string | null
    meter_black?: number | null
    meter_colour?: number | null
    meter_total?: number | null
    drum_life_c?: number | null
    drum_life_m?: number | null
    drum_life_y?: number | null
    drum_life_k?: number | null
  }

  export type TechnicalSpecificationUpdateInput = {
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
    asset?: AssetUpdateOneRequiredWithoutTechnical_specificationNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TechnicalSpecificationCreateManyInput = {
    id?: number
    asset_id: number
    cassettes?: number | null
    internal_finisher?: string | null
    meter_black?: number | null
    meter_colour?: number | null
    meter_total?: number | null
    drum_life_c?: number | null
    drum_life_m?: number | null
    drum_life_y?: number | null
    drum_life_k?: number | null
  }

  export type TechnicalSpecificationUpdateManyMutationInput = {
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TechnicalSpecificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CostCreateInput = {
    purchase_cost?: Decimal | DecimalJsLike | number | string | null
    transport_cost?: Decimal | DecimalJsLike | number | string | null
    processing_cost?: Decimal | DecimalJsLike | number | string | null
    other_cost?: Decimal | DecimalJsLike | number | string | null
    parts_cost?: Decimal | DecimalJsLike | number | string | null
    total_cost?: Decimal | DecimalJsLike | number | string | null
    sale_price?: Decimal | DecimalJsLike | number | string | null
    asset: AssetCreateNestedOneWithoutCostInput
  }

  export type CostUncheckedCreateInput = {
    id?: number
    asset_id: number
    purchase_cost?: Decimal | DecimalJsLike | number | string | null
    transport_cost?: Decimal | DecimalJsLike | number | string | null
    processing_cost?: Decimal | DecimalJsLike | number | string | null
    other_cost?: Decimal | DecimalJsLike | number | string | null
    parts_cost?: Decimal | DecimalJsLike | number | string | null
    total_cost?: Decimal | DecimalJsLike | number | string | null
    sale_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type CostUpdateInput = {
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    asset?: AssetUpdateOneRequiredWithoutCostNestedInput
  }

  export type CostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CostCreateManyInput = {
    id?: number
    asset_id: number
    purchase_cost?: Decimal | DecimalJsLike | number | string | null
    transport_cost?: Decimal | DecimalJsLike | number | string | null
    processing_cost?: Decimal | DecimalJsLike | number | string | null
    other_cost?: Decimal | DecimalJsLike | number | string | null
    parts_cost?: Decimal | DecimalJsLike | number | string | null
    total_cost?: Decimal | DecimalJsLike | number | string | null
    sale_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type CostUpdateManyMutationInput = {
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AssetAccessoryCreateInput = {
    accessory: $Enums.Accessory
    asset: AssetCreateNestedOneWithoutAsset_accessoriesInput
  }

  export type AssetAccessoryUncheckedCreateInput = {
    asset_id: number
    accessory: $Enums.Accessory
  }

  export type AssetAccessoryUpdateInput = {
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
    asset?: AssetUpdateOneRequiredWithoutAsset_accessoriesNestedInput
  }

  export type AssetAccessoryUncheckedUpdateInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type AssetAccessoryCreateManyInput = {
    asset_id: number
    accessory: $Enums.Accessory
  }

  export type AssetAccessoryUpdateManyMutationInput = {
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type AssetAccessoryUncheckedUpdateManyInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type ErrorCategoryCreateInput = {
    category: string
    brand: BrandCreateNestedOneWithoutErrorCategoriesInput
    errors?: ErrorCreateNestedManyWithoutCategoryInput
  }

  export type ErrorCategoryUncheckedCreateInput = {
    id?: number
    brand_id: number
    category: string
    errors?: ErrorUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ErrorCategoryUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    brand?: BrandUpdateOneRequiredWithoutErrorCategoriesNestedInput
    errors?: ErrorUpdateManyWithoutCategoryNestedInput
  }

  export type ErrorCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    errors?: ErrorUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ErrorCategoryCreateManyInput = {
    id?: number
    brand_id: number
    category: string
  }

  export type ErrorCategoryUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ErrorCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ErrorCreateInput = {
    code: string
    description?: string | null
    category: ErrorCategoryCreateNestedOneWithoutErrorsInput
    asset_errors?: AssetErrorCreateNestedManyWithoutErrorInput
  }

  export type ErrorUncheckedCreateInput = {
    id?: number
    error_category_id: number
    code: string
    description?: string | null
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutErrorInput
  }

  export type ErrorUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: ErrorCategoryUpdateOneRequiredWithoutErrorsNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutErrorNestedInput
  }

  export type ErrorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    error_category_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutErrorNestedInput
  }

  export type ErrorCreateManyInput = {
    id?: number
    error_category_id: number
    code: string
    description?: string | null
  }

  export type ErrorUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ErrorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    error_category_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetErrorCreateInput = {
    is_fixed: boolean
    added_at: Date | string
    fixed_at?: Date | string | null
    asset: AssetCreateNestedOneWithoutAsset_errorsInput
    error: ErrorCreateNestedOneWithoutAsset_errorsInput
    addedBy: UserCreateNestedOneWithoutAsset_errors_addedInput
    fixedBy?: UserCreateNestedOneWithoutAsset_errors_fixedInput
  }

  export type AssetErrorUncheckedCreateInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorUpdateInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asset?: AssetUpdateOneRequiredWithoutAsset_errorsNestedInput
    error?: ErrorUpdateOneRequiredWithoutAsset_errorsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutAsset_errors_addedNestedInput
    fixedBy?: UserUpdateOneWithoutAsset_errors_fixedNestedInput
  }

  export type AssetErrorUncheckedUpdateInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorCreateManyInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorUpdateManyMutationInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUncheckedUpdateManyInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartCreateInput = {
    description: string
    part_number: string
    dealer_price: Decimal | DecimalJsLike | number | string
    sale_price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateInput = {
    id?: number
    description: string
    part_number: string
    dealer_price: Decimal | DecimalJsLike | number | string
    sale_price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    asset_parts?: AssetPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartCreateManyInput = {
    id?: number
    description: string
    part_number: string
    dealer_price: Decimal | DecimalJsLike | number | string
    sale_price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
  }

  export type PartUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetPartCreateInput = {
    updated_at: Date | string
    part_operation: $Enums.PartOperation
    asset: AssetCreateNestedOneWithoutAsset_partsInput
    part: PartCreateNestedOneWithoutAsset_partsInput
    updatedBy: UserCreateNestedOneWithoutAsset_partsInput
  }

  export type AssetPartUncheckedCreateInput = {
    asset_id: number
    part_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetPartUpdateInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
    asset?: AssetUpdateOneRequiredWithoutAsset_partsNestedInput
    part?: PartUpdateOneRequiredWithoutAsset_partsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutAsset_partsNestedInput
  }

  export type AssetPartUncheckedUpdateInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetPartCreateManyInput = {
    asset_id: number
    part_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetPartUpdateManyMutationInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetPartUncheckedUpdateManyInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type TransferCreateInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutOrigin_transfersInput
    destination: WarehouseCreateNestedOneWithoutDestination_transfersInput
    transporter: OrganizationCreateNestedOneWithoutTransfersInput
    created_by: UserCreateNestedOneWithoutTransfersInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutTransfersNestedInput
    created_by?: UserUpdateOneRequiredWithoutTransfersNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetTransferCreateInput = {
    asset: AssetCreateNestedOneWithoutAsset_transfersInput
    transfer: TransferCreateNestedOneWithoutAsset_transfersInput
  }

  export type AssetTransferUncheckedCreateInput = {
    asset_id: number
    transfer_id: number
  }

  export type AssetTransferUpdateInput = {
    asset?: AssetUpdateOneRequiredWithoutAsset_transfersNestedInput
    transfer?: TransferUpdateOneRequiredWithoutAsset_transfersNestedInput
  }

  export type AssetTransferUncheckedUpdateInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    transfer_id?: IntFieldUpdateOperationsInput | number
  }

  export type AssetTransferCreateManyInput = {
    asset_id: number
    transfer_id: number
  }

  export type AssetTransferUpdateManyMutationInput = {

  }

  export type AssetTransferUncheckedUpdateManyInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    transfer_id?: IntFieldUpdateOperationsInput | number
  }

  export type ArrivalCreateInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    origin: OrganizationCreateNestedOneWithoutArrivals_originInput
    destination: WarehouseCreateNestedOneWithoutArrivalsInput
    transporter: OrganizationCreateNestedOneWithoutArrivals_transporterInput
    created_by: UserCreateNestedOneWithoutArrivalsInput
    assets?: AssetCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUncheckedCreateInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUpdateInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutArrivalsNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutArrivalsNestedInput
    assets?: AssetUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalCreateManyInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type ArrivalUpdateManyMutationInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureCreateInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUpdateInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureCreateManyInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureUpdateManyMutationInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldCreateInput = {
    hold_number: string
    notes?: string | null
    created_at: Date | string
    created_by: UserCreateNestedOneWithoutHolds_createdInput
    created_for: UserCreateNestedOneWithoutHolds_forInput
    customer: OrganizationCreateNestedOneWithoutHoldsInput
    assets?: AssetCreateNestedManyWithoutHoldInput
  }

  export type HoldUncheckedCreateInput = {
    id?: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutHoldInput
  }

  export type HoldUpdateInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutHolds_createdNestedInput
    created_for?: UserUpdateOneRequiredWithoutHolds_forNestedInput
    customer?: OrganizationUpdateOneRequiredWithoutHoldsNestedInput
    assets?: AssetUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    created_for_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutHoldNestedInput
  }

  export type HoldCreateManyInput = {
    id?: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type HoldUpdateManyMutationInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    created_for_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoice_number: string
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    organization: OrganizationCreateNestedOneWithoutInvoicesInput
    updated_by: UserCreateNestedOneWithoutInvoices_updatedInput
    purchase_assets?: AssetCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    invoice_number: string
    organization_id: number
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    purchase_assets?: AssetUncheckedCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetUncheckedCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceUpdateInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    organization?: OrganizationUpdateOneRequiredWithoutInvoicesNestedInput
    updated_by?: UserUpdateOneRequiredWithoutInvoices_updatedNestedInput
    purchase_assets?: AssetUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    purchase_assets?: AssetUncheckedUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUncheckedUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    invoice_number: string
    organization_id: number
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
  }

  export type InvoiceUpdateManyMutationInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
  }

  export type WarehouseCreateInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    city_code: string
    street: string
  }

  export type WarehouseUpdateManyMutationInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateInput = {
    location: string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
    assets?: AssetCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    warehouse_id: number
    location: string
    assets?: AssetUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
    assets?: AssetUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    warehouse_id: number
    location: string
  }

  export type LocationUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
  }

  export type BrandCreateInput = {
    name: string
    models?: ModelCreateNestedManyWithoutBrandInput
    errorCategories?: ErrorCategoryCreateNestedManyWithoutBrandInput
    assets?: AssetCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name: string
    models?: ModelUncheckedCreateNestedManyWithoutBrandInput
    errorCategories?: ErrorCategoryUncheckedCreateNestedManyWithoutBrandInput
    assets?: AssetUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUpdateManyWithoutBrandNestedInput
    errorCategories?: ErrorCategoryUpdateManyWithoutBrandNestedInput
    assets?: AssetUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUncheckedUpdateManyWithoutBrandNestedInput
    errorCategories?: ErrorCategoryUncheckedUpdateManyWithoutBrandNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name: string
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ModelCreateInput = {
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand: BrandCreateNestedOneWithoutModelsInput
    assets?: AssetCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand_id: number
    assets?: AssetUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    brand?: BrandUpdateOneRequiredWithoutModelsNestedInput
    assets?: AssetUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    assets?: AssetUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand_id: number
  }

  export type ModelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
  }

  export type ModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
  }

  export type FileCreateInput = {
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
    asset: AssetCreateNestedOneWithoutFilesInput
    uploaded_by: UserCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: number
    asset_id: number
    uploaded_by_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type FileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutFilesNestedInput
    uploaded_by?: UserUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    uploaded_by_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyInput = {
    id?: number
    asset_id: number
    uploaded_by_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type FileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    uploaded_by_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    comment: string
    created_at: Date | string
    updated_at: Date | string
    asset: AssetCreateNestedOneWithoutCommentsInput
    created_by: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    asset_id: number
    created_by_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type CommentUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutCommentsNestedInput
    created_by?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    asset_id: number
    created_by_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type OrganizationCreateInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUpdateInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryCreateInput = {
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
    asset: AssetCreateNestedOneWithoutAsset_historyInput
    user: UserCreateNestedOneWithoutAsset_historyInput
  }

  export type AssetHistoryUncheckedCreateInput = {
    id?: number
    asset_id: number
    user_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryUpdateInput = {
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
    asset?: AssetUpdateOneRequiredWithoutAsset_historyNestedInput
    user?: UserUpdateOneRequiredWithoutAsset_historyNestedInput
  }

  export type AssetHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryCreateManyInput = {
    id?: number
    asset_id: number
    user_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryUpdateManyMutationInput = {
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type EnumTrackingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingStatus | EnumTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingStatusFilter<$PrismaModel> | $Enums.TrackingStatus
  }

  export type EnumExitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExitStatus | EnumExitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExitStatusFilter<$PrismaModel> | $Enums.ExitStatus
  }

  export type EnumTechnicalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicalStatus | EnumTechnicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicalStatusFilter<$PrismaModel> | $Enums.TechnicalStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CostNullableScalarRelationFilter = {
    is?: CostWhereInput | null
    isNot?: CostWhereInput | null
  }

  export type TechnicalSpecificationNullableScalarRelationFilter = {
    is?: TechnicalSpecificationWhereInput | null
    isNot?: TechnicalSpecificationWhereInput | null
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type ModelScalarRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type ArrivalNullableScalarRelationFilter = {
    is?: ArrivalWhereInput | null
    isNot?: ArrivalWhereInput | null
  }

  export type DepartureNullableScalarRelationFilter = {
    is?: DepartureWhereInput | null
    isNot?: DepartureWhereInput | null
  }

  export type HoldNullableScalarRelationFilter = {
    is?: HoldWhereInput | null
    isNot?: HoldWhereInput | null
  }

  export type AssetAccessoryListRelationFilter = {
    every?: AssetAccessoryWhereInput
    some?: AssetAccessoryWhereInput
    none?: AssetAccessoryWhereInput
  }

  export type AssetErrorListRelationFilter = {
    every?: AssetErrorWhereInput
    some?: AssetErrorWhereInput
    none?: AssetErrorWhereInput
  }

  export type AssetPartListRelationFilter = {
    every?: AssetPartWhereInput
    some?: AssetPartWhereInput
    none?: AssetPartWhereInput
  }

  export type AssetTransferListRelationFilter = {
    every?: AssetTransferWhereInput
    some?: AssetTransferWhereInput
    none?: AssetTransferWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type AssetHistoryListRelationFilter = {
    every?: AssetHistoryWhereInput
    some?: AssetHistoryWhereInput
    none?: AssetHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AssetAccessoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetErrorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetPartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    serial_number?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    asset_location?: SortOrder
    asset_type?: SortOrder
    tracking_status?: SortOrder
    exit_status?: SortOrder
    technical_status?: SortOrder
    purchase_invoice_id?: SortOrder
    sales_invoice_id?: SortOrder
    arrival_id?: SortOrder
    departure_id?: SortOrder
    hold_id?: SortOrder
    is_held?: SortOrder
    created_at?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    purchase_invoice_id?: SortOrder
    sales_invoice_id?: SortOrder
    arrival_id?: SortOrder
    departure_id?: SortOrder
    hold_id?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    serial_number?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    asset_location?: SortOrder
    asset_type?: SortOrder
    tracking_status?: SortOrder
    exit_status?: SortOrder
    technical_status?: SortOrder
    purchase_invoice_id?: SortOrder
    sales_invoice_id?: SortOrder
    arrival_id?: SortOrder
    departure_id?: SortOrder
    hold_id?: SortOrder
    is_held?: SortOrder
    created_at?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    serial_number?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    asset_location?: SortOrder
    asset_type?: SortOrder
    tracking_status?: SortOrder
    exit_status?: SortOrder
    technical_status?: SortOrder
    purchase_invoice_id?: SortOrder
    sales_invoice_id?: SortOrder
    arrival_id?: SortOrder
    departure_id?: SortOrder
    hold_id?: SortOrder
    is_held?: SortOrder
    created_at?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    warehouse_id?: SortOrder
    purchase_invoice_id?: SortOrder
    sales_invoice_id?: SortOrder
    arrival_id?: SortOrder
    departure_id?: SortOrder
    hold_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type EnumTrackingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingStatus | EnumTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrackingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrackingStatusFilter<$PrismaModel>
  }

  export type EnumExitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExitStatus | EnumExitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExitStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExitStatusFilter<$PrismaModel>
    _max?: NestedEnumExitStatusFilter<$PrismaModel>
  }

  export type EnumTechnicalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicalStatus | EnumTechnicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicalStatusWithAggregatesFilter<$PrismaModel> | $Enums.TechnicalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnicalStatusFilter<$PrismaModel>
    _max?: NestedEnumTechnicalStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AssetScalarRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type TechnicalSpecificationCountOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrder
    internal_finisher?: SortOrder
    meter_black?: SortOrder
    meter_colour?: SortOrder
    meter_total?: SortOrder
    drum_life_c?: SortOrder
    drum_life_m?: SortOrder
    drum_life_y?: SortOrder
    drum_life_k?: SortOrder
  }

  export type TechnicalSpecificationAvgOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrder
    meter_black?: SortOrder
    meter_colour?: SortOrder
    meter_total?: SortOrder
    drum_life_c?: SortOrder
    drum_life_m?: SortOrder
    drum_life_y?: SortOrder
    drum_life_k?: SortOrder
  }

  export type TechnicalSpecificationMaxOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrder
    internal_finisher?: SortOrder
    meter_black?: SortOrder
    meter_colour?: SortOrder
    meter_total?: SortOrder
    drum_life_c?: SortOrder
    drum_life_m?: SortOrder
    drum_life_y?: SortOrder
    drum_life_k?: SortOrder
  }

  export type TechnicalSpecificationMinOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrder
    internal_finisher?: SortOrder
    meter_black?: SortOrder
    meter_colour?: SortOrder
    meter_total?: SortOrder
    drum_life_c?: SortOrder
    drum_life_m?: SortOrder
    drum_life_y?: SortOrder
    drum_life_k?: SortOrder
  }

  export type TechnicalSpecificationSumOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    cassettes?: SortOrder
    meter_black?: SortOrder
    meter_colour?: SortOrder
    meter_total?: SortOrder
    drum_life_c?: SortOrder
    drum_life_m?: SortOrder
    drum_life_y?: SortOrder
    drum_life_k?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CostCountOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrder
    transport_cost?: SortOrder
    processing_cost?: SortOrder
    other_cost?: SortOrder
    parts_cost?: SortOrder
    total_cost?: SortOrder
    sale_price?: SortOrder
  }

  export type CostAvgOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrder
    transport_cost?: SortOrder
    processing_cost?: SortOrder
    other_cost?: SortOrder
    parts_cost?: SortOrder
    total_cost?: SortOrder
    sale_price?: SortOrder
  }

  export type CostMaxOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrder
    transport_cost?: SortOrder
    processing_cost?: SortOrder
    other_cost?: SortOrder
    parts_cost?: SortOrder
    total_cost?: SortOrder
    sale_price?: SortOrder
  }

  export type CostMinOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrder
    transport_cost?: SortOrder
    processing_cost?: SortOrder
    other_cost?: SortOrder
    parts_cost?: SortOrder
    total_cost?: SortOrder
    sale_price?: SortOrder
  }

  export type CostSumOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    purchase_cost?: SortOrder
    transport_cost?: SortOrder
    processing_cost?: SortOrder
    other_cost?: SortOrder
    parts_cost?: SortOrder
    total_cost?: SortOrder
    sale_price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumAccessoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Accessory | EnumAccessoryFieldRefInput<$PrismaModel>
    in?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessoryFilter<$PrismaModel> | $Enums.Accessory
  }

  export type AssetAccessoryAsset_idAccessoryCompoundUniqueInput = {
    asset_id: number
    accessory: $Enums.Accessory
  }

  export type AssetAccessoryCountOrderByAggregateInput = {
    asset_id?: SortOrder
    accessory?: SortOrder
  }

  export type AssetAccessoryAvgOrderByAggregateInput = {
    asset_id?: SortOrder
  }

  export type AssetAccessoryMaxOrderByAggregateInput = {
    asset_id?: SortOrder
    accessory?: SortOrder
  }

  export type AssetAccessoryMinOrderByAggregateInput = {
    asset_id?: SortOrder
    accessory?: SortOrder
  }

  export type AssetAccessorySumOrderByAggregateInput = {
    asset_id?: SortOrder
  }

  export type EnumAccessoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Accessory | EnumAccessoryFieldRefInput<$PrismaModel>
    in?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessoryWithAggregatesFilter<$PrismaModel> | $Enums.Accessory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessoryFilter<$PrismaModel>
    _max?: NestedEnumAccessoryFilter<$PrismaModel>
  }

  export type ErrorListRelationFilter = {
    every?: ErrorWhereInput
    some?: ErrorWhereInput
    none?: ErrorWhereInput
  }

  export type ErrorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ErrorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    category?: SortOrder
  }

  export type ErrorCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type ErrorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    category?: SortOrder
  }

  export type ErrorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    category?: SortOrder
  }

  export type ErrorCategorySumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type ErrorCategoryScalarRelationFilter = {
    is?: ErrorCategoryWhereInput
    isNot?: ErrorCategoryWhereInput
  }

  export type ErrorCountOrderByAggregateInput = {
    id?: SortOrder
    error_category_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ErrorAvgOrderByAggregateInput = {
    id?: SortOrder
    error_category_id?: SortOrder
  }

  export type ErrorMaxOrderByAggregateInput = {
    id?: SortOrder
    error_category_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ErrorMinOrderByAggregateInput = {
    id?: SortOrder
    error_category_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ErrorSumOrderByAggregateInput = {
    id?: SortOrder
    error_category_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ErrorScalarRelationFilter = {
    is?: ErrorWhereInput
    isNot?: ErrorWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AssetErrorAsset_idError_idCompoundUniqueInput = {
    asset_id: number
    error_id: number
  }

  export type AssetErrorCountOrderByAggregateInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    is_fixed?: SortOrder
    added_by?: SortOrder
    added_at?: SortOrder
    fixed_by?: SortOrder
    fixed_at?: SortOrder
  }

  export type AssetErrorAvgOrderByAggregateInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    added_by?: SortOrder
    fixed_by?: SortOrder
  }

  export type AssetErrorMaxOrderByAggregateInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    is_fixed?: SortOrder
    added_by?: SortOrder
    added_at?: SortOrder
    fixed_by?: SortOrder
    fixed_at?: SortOrder
  }

  export type AssetErrorMinOrderByAggregateInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    is_fixed?: SortOrder
    added_by?: SortOrder
    added_at?: SortOrder
    fixed_by?: SortOrder
    fixed_at?: SortOrder
  }

  export type AssetErrorSumOrderByAggregateInput = {
    asset_id?: SortOrder
    error_id?: SortOrder
    added_by?: SortOrder
    fixed_by?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PartCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    part_number?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
  }

  export type PartAvgOrderByAggregateInput = {
    id?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
  }

  export type PartMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    part_number?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
  }

  export type PartMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    part_number?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
  }

  export type PartSumOrderByAggregateInput = {
    id?: SortOrder
    dealer_price?: SortOrder
    sale_price?: SortOrder
    cost?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPartOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.PartOperation | EnumPartOperationFieldRefInput<$PrismaModel>
    in?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumPartOperationFilter<$PrismaModel> | $Enums.PartOperation
  }

  export type PartScalarRelationFilter = {
    is?: PartWhereInput
    isNot?: PartWhereInput
  }

  export type AssetPartAsset_idPart_idCompoundUniqueInput = {
    asset_id: number
    part_id: number
  }

  export type AssetPartCountOrderByAggregateInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    part_operation?: SortOrder
  }

  export type AssetPartAvgOrderByAggregateInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_by?: SortOrder
  }

  export type AssetPartMaxOrderByAggregateInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    part_operation?: SortOrder
  }

  export type AssetPartMinOrderByAggregateInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    part_operation?: SortOrder
  }

  export type AssetPartSumOrderByAggregateInput = {
    asset_id?: SortOrder
    part_id?: SortOrder
    updated_by?: SortOrder
  }

  export type EnumPartOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartOperation | EnumPartOperationFieldRefInput<$PrismaModel>
    in?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumPartOperationWithAggregatesFilter<$PrismaModel> | $Enums.PartOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartOperationFilter<$PrismaModel>
    _max?: NestedEnumPartOperationFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    transfer_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    transfer_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    transfer_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type AssetTransferAsset_idTransfer_idCompoundUniqueInput = {
    asset_id: number
    transfer_id: number
  }

  export type AssetTransferCountOrderByAggregateInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
  }

  export type AssetTransferAvgOrderByAggregateInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
  }

  export type AssetTransferMaxOrderByAggregateInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
  }

  export type AssetTransferMinOrderByAggregateInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
  }

  export type AssetTransferSumOrderByAggregateInput = {
    asset_id?: SortOrder
    transfer_id?: SortOrder
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArrivalCountOrderByAggregateInput = {
    id?: SortOrder
    arrival_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ArrivalAvgOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type ArrivalMaxOrderByAggregateInput = {
    id?: SortOrder
    arrival_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ArrivalMinOrderByAggregateInput = {
    id?: SortOrder
    arrival_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ArrivalSumOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type DepartureCountOrderByAggregateInput = {
    id?: SortOrder
    departure_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type DepartureAvgOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
  }

  export type DepartureMaxOrderByAggregateInput = {
    id?: SortOrder
    departure_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type DepartureMinOrderByAggregateInput = {
    id?: SortOrder
    departure_number?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type DepartureSumOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    transporter_id?: SortOrder
    created_by_id?: SortOrder
    sales_representative_id?: SortOrder
  }

  export type HoldCountOrderByAggregateInput = {
    id?: SortOrder
    hold_number?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type HoldAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
  }

  export type HoldMaxOrderByAggregateInput = {
    id?: SortOrder
    hold_number?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type HoldMinOrderByAggregateInput = {
    id?: SortOrder
    hold_number?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type HoldSumOrderByAggregateInput = {
    id?: SortOrder
    created_by_id?: SortOrder
    created_for_id?: SortOrder
    customer_id?: SortOrder
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
    is_cleared?: SortOrder
    created_at?: SortOrder
    invoice_type?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
    is_cleared?: SortOrder
    created_at?: SortOrder
    invoice_type?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
    is_cleared?: SortOrder
    created_at?: SortOrder
    invoice_type?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    updated_by_id?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type DepartureListRelationFilter = {
    every?: DepartureWhereInput
    some?: DepartureWhereInput
    none?: DepartureWhereInput
  }

  export type ArrivalListRelationFilter = {
    every?: ArrivalWhereInput
    some?: ArrivalWhereInput
    none?: ArrivalWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArrivalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    street?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    street?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    street?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationWarehouse_idLocationCompoundUniqueInput = {
    warehouse_id: number
    location: string
  }

  export type LocationCountOrderByAggregateInput = {
    warehouse_id?: SortOrder
    location?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    warehouse_id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    warehouse_id?: SortOrder
    location?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    warehouse_id?: SortOrder
    location?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    warehouse_id?: SortOrder
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type ErrorCategoryListRelationFilter = {
    every?: ErrorCategoryWhereInput
    some?: ErrorCategoryWhereInput
    none?: ErrorCategoryWhereInput
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ErrorCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ModelNameBrand_idCompoundUniqueInput = {
    name: string
    brand_id: number
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    asset_type?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
  }

  export type ModelAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    asset_type?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    asset_type?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
  }

  export type ModelSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    size?: SortOrder
    brand_id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    data?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    data?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    data?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    uploaded_by_id?: SortOrder
    size?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    created_by_id?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type HoldListRelationFilter = {
    every?: HoldWhereInput
    some?: HoldWhereInput
    none?: HoldWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type HoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    account_number?: SortOrder
    name?: SortOrder
    contact_name?: SortOrder
    phone?: SortOrder
    phone_ext?: SortOrder
    primary_email?: SortOrder
    secondary_email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    website?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    account_number?: SortOrder
    name?: SortOrder
    contact_name?: SortOrder
    phone?: SortOrder
    phone_ext?: SortOrder
    primary_email?: SortOrder
    secondary_email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    website?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    account_number?: SortOrder
    name?: SortOrder
    contact_name?: SortOrder
    phone?: SortOrder
    phone_ext?: SortOrder
    primary_email?: SortOrder
    secondary_email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    website?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGeneralOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneralOperation | EnumGeneralOperationFieldRefInput<$PrismaModel>
    in?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumGeneralOperationFilter<$PrismaModel> | $Enums.GeneralOperation
  }

  export type EnumDataFieldFilter<$PrismaModel = never> = {
    equals?: $Enums.DataField | EnumDataFieldFieldRefInput<$PrismaModel>
    in?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumDataFieldFilter<$PrismaModel> | $Enums.DataField
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AssetHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
    operation?: SortOrder
    data_field?: SortOrder
    changed_on?: SortOrder
    changes?: SortOrder
  }

  export type AssetHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
  }

  export type AssetHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
    operation?: SortOrder
    data_field?: SortOrder
    changed_on?: SortOrder
  }

  export type AssetHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
    operation?: SortOrder
    data_field?: SortOrder
    changed_on?: SortOrder
  }

  export type AssetHistorySumOrderByAggregateInput = {
    id?: SortOrder
    asset_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumGeneralOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneralOperation | EnumGeneralOperationFieldRefInput<$PrismaModel>
    in?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumGeneralOperationWithAggregatesFilter<$PrismaModel> | $Enums.GeneralOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGeneralOperationFilter<$PrismaModel>
    _max?: NestedEnumGeneralOperationFilter<$PrismaModel>
  }

  export type EnumDataFieldWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataField | EnumDataFieldFieldRefInput<$PrismaModel>
    in?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumDataFieldWithAggregatesFilter<$PrismaModel> | $Enums.DataField
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataFieldFilter<$PrismaModel>
    _max?: NestedEnumDataFieldFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CostCreateNestedOneWithoutAssetInput = {
    create?: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
    connectOrCreate?: CostCreateOrConnectWithoutAssetInput
    connect?: CostWhereUniqueInput
  }

  export type TechnicalSpecificationCreateNestedOneWithoutAssetInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutAssetInput
    connect?: TechnicalSpecificationWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutAssetsInput = {
    create?: XOR<BrandCreateWithoutAssetsInput, BrandUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAssetsInput
    connect?: BrandWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutAssetsInput = {
    create?: XOR<ModelCreateWithoutAssetsInput, ModelUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutAssetsInput
    connect?: ModelWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutAssetsInput = {
    create?: XOR<WarehouseCreateWithoutAssetsInput, WarehouseUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAssetsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutAssetsInput = {
    create?: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAssetsInput
    connect?: LocationWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPurchase_assetsInput = {
    create?: XOR<InvoiceCreateWithoutPurchase_assetsInput, InvoiceUncheckedCreateWithoutPurchase_assetsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchase_assetsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutSales_assetsInput = {
    create?: XOR<InvoiceCreateWithoutSales_assetsInput, InvoiceUncheckedCreateWithoutSales_assetsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSales_assetsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ArrivalCreateNestedOneWithoutAssetsInput = {
    create?: XOR<ArrivalCreateWithoutAssetsInput, ArrivalUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ArrivalCreateOrConnectWithoutAssetsInput
    connect?: ArrivalWhereUniqueInput
  }

  export type DepartureCreateNestedOneWithoutAssetsInput = {
    create?: XOR<DepartureCreateWithoutAssetsInput, DepartureUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: DepartureCreateOrConnectWithoutAssetsInput
    connect?: DepartureWhereUniqueInput
  }

  export type HoldCreateNestedOneWithoutAssetsInput = {
    create?: XOR<HoldCreateWithoutAssetsInput, HoldUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: HoldCreateOrConnectWithoutAssetsInput
    connect?: HoldWhereUniqueInput
  }

  export type AssetAccessoryCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput> | AssetAccessoryCreateWithoutAssetInput[] | AssetAccessoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAccessoryCreateOrConnectWithoutAssetInput | AssetAccessoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAccessoryCreateManyAssetInputEnvelope
    connect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
  }

  export type AssetErrorCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput> | AssetErrorCreateWithoutAssetInput[] | AssetErrorUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAssetInput | AssetErrorCreateOrConnectWithoutAssetInput[]
    createMany?: AssetErrorCreateManyAssetInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type AssetPartCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput> | AssetPartCreateWithoutAssetInput[] | AssetPartUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutAssetInput | AssetPartCreateOrConnectWithoutAssetInput[]
    createMany?: AssetPartCreateManyAssetInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type AssetTransferCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput> | AssetTransferCreateWithoutAssetInput[] | AssetTransferUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutAssetInput | AssetTransferCreateOrConnectWithoutAssetInput[]
    createMany?: AssetTransferCreateManyAssetInputEnvelope
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutAssetInput = {
    create?: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput> | FileCreateWithoutAssetInput[] | FileUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssetInput | FileCreateOrConnectWithoutAssetInput[]
    createMany?: FileCreateManyAssetInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAssetInput = {
    create?: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput> | CommentCreateWithoutAssetInput[] | CommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAssetInput | CommentCreateOrConnectWithoutAssetInput[]
    createMany?: CommentCreateManyAssetInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AssetHistoryCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type CostUncheckedCreateNestedOneWithoutAssetInput = {
    create?: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
    connectOrCreate?: CostCreateOrConnectWithoutAssetInput
    connect?: CostWhereUniqueInput
  }

  export type TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutAssetInput
    connect?: TechnicalSpecificationWhereUniqueInput
  }

  export type AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput> | AssetAccessoryCreateWithoutAssetInput[] | AssetAccessoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAccessoryCreateOrConnectWithoutAssetInput | AssetAccessoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAccessoryCreateManyAssetInputEnvelope
    connect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
  }

  export type AssetErrorUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput> | AssetErrorCreateWithoutAssetInput[] | AssetErrorUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAssetInput | AssetErrorCreateOrConnectWithoutAssetInput[]
    createMany?: AssetErrorCreateManyAssetInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type AssetPartUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput> | AssetPartCreateWithoutAssetInput[] | AssetPartUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutAssetInput | AssetPartCreateOrConnectWithoutAssetInput[]
    createMany?: AssetPartCreateManyAssetInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type AssetTransferUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput> | AssetTransferCreateWithoutAssetInput[] | AssetTransferUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutAssetInput | AssetTransferCreateOrConnectWithoutAssetInput[]
    createMany?: AssetTransferCreateManyAssetInputEnvelope
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput> | FileCreateWithoutAssetInput[] | FileUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssetInput | FileCreateOrConnectWithoutAssetInput[]
    createMany?: FileCreateManyAssetInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput> | CommentCreateWithoutAssetInput[] | CommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAssetInput | CommentCreateOrConnectWithoutAssetInput[]
    createMany?: CommentCreateManyAssetInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AssetHistoryUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssetType
  }

  export type EnumTrackingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrackingStatus
  }

  export type EnumExitStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExitStatus
  }

  export type EnumTechnicalStatusFieldUpdateOperationsInput = {
    set?: $Enums.TechnicalStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CostUpdateOneWithoutAssetNestedInput = {
    create?: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
    connectOrCreate?: CostCreateOrConnectWithoutAssetInput
    upsert?: CostUpsertWithoutAssetInput
    disconnect?: CostWhereInput | boolean
    delete?: CostWhereInput | boolean
    connect?: CostWhereUniqueInput
    update?: XOR<XOR<CostUpdateToOneWithWhereWithoutAssetInput, CostUpdateWithoutAssetInput>, CostUncheckedUpdateWithoutAssetInput>
  }

  export type TechnicalSpecificationUpdateOneWithoutAssetNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutAssetInput
    upsert?: TechnicalSpecificationUpsertWithoutAssetInput
    disconnect?: TechnicalSpecificationWhereInput | boolean
    delete?: TechnicalSpecificationWhereInput | boolean
    connect?: TechnicalSpecificationWhereUniqueInput
    update?: XOR<XOR<TechnicalSpecificationUpdateToOneWithWhereWithoutAssetInput, TechnicalSpecificationUpdateWithoutAssetInput>, TechnicalSpecificationUncheckedUpdateWithoutAssetInput>
  }

  export type BrandUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<BrandCreateWithoutAssetsInput, BrandUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAssetsInput
    upsert?: BrandUpsertWithoutAssetsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutAssetsInput, BrandUpdateWithoutAssetsInput>, BrandUncheckedUpdateWithoutAssetsInput>
  }

  export type ModelUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<ModelCreateWithoutAssetsInput, ModelUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutAssetsInput
    upsert?: ModelUpsertWithoutAssetsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutAssetsInput, ModelUpdateWithoutAssetsInput>, ModelUncheckedUpdateWithoutAssetsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<WarehouseCreateWithoutAssetsInput, WarehouseUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAssetsInput
    upsert?: WarehouseUpsertWithoutAssetsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutAssetsInput, WarehouseUpdateWithoutAssetsInput>, WarehouseUncheckedUpdateWithoutAssetsInput>
  }

  export type LocationUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAssetsInput
    upsert?: LocationUpsertWithoutAssetsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAssetsInput, LocationUpdateWithoutAssetsInput>, LocationUncheckedUpdateWithoutAssetsInput>
  }

  export type InvoiceUpdateOneWithoutPurchase_assetsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchase_assetsInput, InvoiceUncheckedCreateWithoutPurchase_assetsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchase_assetsInput
    upsert?: InvoiceUpsertWithoutPurchase_assetsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPurchase_assetsInput, InvoiceUpdateWithoutPurchase_assetsInput>, InvoiceUncheckedUpdateWithoutPurchase_assetsInput>
  }

  export type InvoiceUpdateOneWithoutSales_assetsNestedInput = {
    create?: XOR<InvoiceCreateWithoutSales_assetsInput, InvoiceUncheckedCreateWithoutSales_assetsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSales_assetsInput
    upsert?: InvoiceUpsertWithoutSales_assetsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutSales_assetsInput, InvoiceUpdateWithoutSales_assetsInput>, InvoiceUncheckedUpdateWithoutSales_assetsInput>
  }

  export type ArrivalUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<ArrivalCreateWithoutAssetsInput, ArrivalUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ArrivalCreateOrConnectWithoutAssetsInput
    upsert?: ArrivalUpsertWithoutAssetsInput
    disconnect?: ArrivalWhereInput | boolean
    delete?: ArrivalWhereInput | boolean
    connect?: ArrivalWhereUniqueInput
    update?: XOR<XOR<ArrivalUpdateToOneWithWhereWithoutAssetsInput, ArrivalUpdateWithoutAssetsInput>, ArrivalUncheckedUpdateWithoutAssetsInput>
  }

  export type DepartureUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<DepartureCreateWithoutAssetsInput, DepartureUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: DepartureCreateOrConnectWithoutAssetsInput
    upsert?: DepartureUpsertWithoutAssetsInput
    disconnect?: DepartureWhereInput | boolean
    delete?: DepartureWhereInput | boolean
    connect?: DepartureWhereUniqueInput
    update?: XOR<XOR<DepartureUpdateToOneWithWhereWithoutAssetsInput, DepartureUpdateWithoutAssetsInput>, DepartureUncheckedUpdateWithoutAssetsInput>
  }

  export type HoldUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<HoldCreateWithoutAssetsInput, HoldUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: HoldCreateOrConnectWithoutAssetsInput
    upsert?: HoldUpsertWithoutAssetsInput
    disconnect?: HoldWhereInput | boolean
    delete?: HoldWhereInput | boolean
    connect?: HoldWhereUniqueInput
    update?: XOR<XOR<HoldUpdateToOneWithWhereWithoutAssetsInput, HoldUpdateWithoutAssetsInput>, HoldUncheckedUpdateWithoutAssetsInput>
  }

  export type AssetAccessoryUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput> | AssetAccessoryCreateWithoutAssetInput[] | AssetAccessoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAccessoryCreateOrConnectWithoutAssetInput | AssetAccessoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAccessoryUpsertWithWhereUniqueWithoutAssetInput | AssetAccessoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAccessoryCreateManyAssetInputEnvelope
    set?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    disconnect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    delete?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    connect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    update?: AssetAccessoryUpdateWithWhereUniqueWithoutAssetInput | AssetAccessoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAccessoryUpdateManyWithWhereWithoutAssetInput | AssetAccessoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAccessoryScalarWhereInput | AssetAccessoryScalarWhereInput[]
  }

  export type AssetErrorUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput> | AssetErrorCreateWithoutAssetInput[] | AssetErrorUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAssetInput | AssetErrorCreateOrConnectWithoutAssetInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutAssetInput | AssetErrorUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetErrorCreateManyAssetInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutAssetInput | AssetErrorUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutAssetInput | AssetErrorUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetPartUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput> | AssetPartCreateWithoutAssetInput[] | AssetPartUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutAssetInput | AssetPartCreateOrConnectWithoutAssetInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutAssetInput | AssetPartUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetPartCreateManyAssetInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutAssetInput | AssetPartUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutAssetInput | AssetPartUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type AssetTransferUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput> | AssetTransferCreateWithoutAssetInput[] | AssetTransferUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutAssetInput | AssetTransferCreateOrConnectWithoutAssetInput[]
    upsert?: AssetTransferUpsertWithWhereUniqueWithoutAssetInput | AssetTransferUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetTransferCreateManyAssetInputEnvelope
    set?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    disconnect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    delete?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    update?: AssetTransferUpdateWithWhereUniqueWithoutAssetInput | AssetTransferUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetTransferUpdateManyWithWhereWithoutAssetInput | AssetTransferUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
  }

  export type FileUpdateManyWithoutAssetNestedInput = {
    create?: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput> | FileCreateWithoutAssetInput[] | FileUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssetInput | FileCreateOrConnectWithoutAssetInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAssetInput | FileUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: FileCreateManyAssetInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAssetInput | FileUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAssetInput | FileUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAssetNestedInput = {
    create?: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput> | CommentCreateWithoutAssetInput[] | CommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAssetInput | CommentCreateOrConnectWithoutAssetInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAssetInput | CommentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: CommentCreateManyAssetInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAssetInput | CommentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAssetInput | CommentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssetHistoryUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutAssetInput | AssetHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CostUncheckedUpdateOneWithoutAssetNestedInput = {
    create?: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
    connectOrCreate?: CostCreateOrConnectWithoutAssetInput
    upsert?: CostUpsertWithoutAssetInput
    disconnect?: CostWhereInput | boolean
    delete?: CostWhereInput | boolean
    connect?: CostWhereUniqueInput
    update?: XOR<XOR<CostUpdateToOneWithWhereWithoutAssetInput, CostUpdateWithoutAssetInput>, CostUncheckedUpdateWithoutAssetInput>
  }

  export type TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutAssetInput
    upsert?: TechnicalSpecificationUpsertWithoutAssetInput
    disconnect?: TechnicalSpecificationWhereInput | boolean
    delete?: TechnicalSpecificationWhereInput | boolean
    connect?: TechnicalSpecificationWhereUniqueInput
    update?: XOR<XOR<TechnicalSpecificationUpdateToOneWithWhereWithoutAssetInput, TechnicalSpecificationUpdateWithoutAssetInput>, TechnicalSpecificationUncheckedUpdateWithoutAssetInput>
  }

  export type AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput> | AssetAccessoryCreateWithoutAssetInput[] | AssetAccessoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAccessoryCreateOrConnectWithoutAssetInput | AssetAccessoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAccessoryUpsertWithWhereUniqueWithoutAssetInput | AssetAccessoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAccessoryCreateManyAssetInputEnvelope
    set?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    disconnect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    delete?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    connect?: AssetAccessoryWhereUniqueInput | AssetAccessoryWhereUniqueInput[]
    update?: AssetAccessoryUpdateWithWhereUniqueWithoutAssetInput | AssetAccessoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAccessoryUpdateManyWithWhereWithoutAssetInput | AssetAccessoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAccessoryScalarWhereInput | AssetAccessoryScalarWhereInput[]
  }

  export type AssetErrorUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput> | AssetErrorCreateWithoutAssetInput[] | AssetErrorUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAssetInput | AssetErrorCreateOrConnectWithoutAssetInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutAssetInput | AssetErrorUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetErrorCreateManyAssetInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutAssetInput | AssetErrorUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutAssetInput | AssetErrorUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetPartUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput> | AssetPartCreateWithoutAssetInput[] | AssetPartUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutAssetInput | AssetPartCreateOrConnectWithoutAssetInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutAssetInput | AssetPartUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetPartCreateManyAssetInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutAssetInput | AssetPartUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutAssetInput | AssetPartUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type AssetTransferUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput> | AssetTransferCreateWithoutAssetInput[] | AssetTransferUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutAssetInput | AssetTransferCreateOrConnectWithoutAssetInput[]
    upsert?: AssetTransferUpsertWithWhereUniqueWithoutAssetInput | AssetTransferUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetTransferCreateManyAssetInputEnvelope
    set?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    disconnect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    delete?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    update?: AssetTransferUpdateWithWhereUniqueWithoutAssetInput | AssetTransferUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetTransferUpdateManyWithWhereWithoutAssetInput | AssetTransferUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput> | FileCreateWithoutAssetInput[] | FileUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssetInput | FileCreateOrConnectWithoutAssetInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAssetInput | FileUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: FileCreateManyAssetInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAssetInput | FileUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAssetInput | FileUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput> | CommentCreateWithoutAssetInput[] | CommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAssetInput | CommentCreateOrConnectWithoutAssetInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAssetInput | CommentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: CommentCreateManyAssetInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAssetInput | CommentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAssetInput | CommentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutAssetInput | AssetHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutTechnical_specificationInput = {
    create?: XOR<AssetCreateWithoutTechnical_specificationInput, AssetUncheckedCreateWithoutTechnical_specificationInput>
    connectOrCreate?: AssetCreateOrConnectWithoutTechnical_specificationInput
    connect?: AssetWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutTechnical_specificationNestedInput = {
    create?: XOR<AssetCreateWithoutTechnical_specificationInput, AssetUncheckedCreateWithoutTechnical_specificationInput>
    connectOrCreate?: AssetCreateOrConnectWithoutTechnical_specificationInput
    upsert?: AssetUpsertWithoutTechnical_specificationInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutTechnical_specificationInput, AssetUpdateWithoutTechnical_specificationInput>, AssetUncheckedUpdateWithoutTechnical_specificationInput>
  }

  export type AssetCreateNestedOneWithoutCostInput = {
    create?: XOR<AssetCreateWithoutCostInput, AssetUncheckedCreateWithoutCostInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCostInput
    connect?: AssetWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AssetUpdateOneRequiredWithoutCostNestedInput = {
    create?: XOR<AssetCreateWithoutCostInput, AssetUncheckedCreateWithoutCostInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCostInput
    upsert?: AssetUpsertWithoutCostInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutCostInput, AssetUpdateWithoutCostInput>, AssetUncheckedUpdateWithoutCostInput>
  }

  export type AssetCreateNestedOneWithoutAsset_accessoriesInput = {
    create?: XOR<AssetCreateWithoutAsset_accessoriesInput, AssetUncheckedCreateWithoutAsset_accessoriesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_accessoriesInput
    connect?: AssetWhereUniqueInput
  }

  export type EnumAccessoryFieldUpdateOperationsInput = {
    set?: $Enums.Accessory
  }

  export type AssetUpdateOneRequiredWithoutAsset_accessoriesNestedInput = {
    create?: XOR<AssetCreateWithoutAsset_accessoriesInput, AssetUncheckedCreateWithoutAsset_accessoriesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_accessoriesInput
    upsert?: AssetUpsertWithoutAsset_accessoriesInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAsset_accessoriesInput, AssetUpdateWithoutAsset_accessoriesInput>, AssetUncheckedUpdateWithoutAsset_accessoriesInput>
  }

  export type BrandCreateNestedOneWithoutErrorCategoriesInput = {
    create?: XOR<BrandCreateWithoutErrorCategoriesInput, BrandUncheckedCreateWithoutErrorCategoriesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutErrorCategoriesInput
    connect?: BrandWhereUniqueInput
  }

  export type ErrorCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput> | ErrorCreateWithoutCategoryInput[] | ErrorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ErrorCreateOrConnectWithoutCategoryInput | ErrorCreateOrConnectWithoutCategoryInput[]
    createMany?: ErrorCreateManyCategoryInputEnvelope
    connect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
  }

  export type ErrorUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput> | ErrorCreateWithoutCategoryInput[] | ErrorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ErrorCreateOrConnectWithoutCategoryInput | ErrorCreateOrConnectWithoutCategoryInput[]
    createMany?: ErrorCreateManyCategoryInputEnvelope
    connect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
  }

  export type BrandUpdateOneRequiredWithoutErrorCategoriesNestedInput = {
    create?: XOR<BrandCreateWithoutErrorCategoriesInput, BrandUncheckedCreateWithoutErrorCategoriesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutErrorCategoriesInput
    upsert?: BrandUpsertWithoutErrorCategoriesInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutErrorCategoriesInput, BrandUpdateWithoutErrorCategoriesInput>, BrandUncheckedUpdateWithoutErrorCategoriesInput>
  }

  export type ErrorUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput> | ErrorCreateWithoutCategoryInput[] | ErrorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ErrorCreateOrConnectWithoutCategoryInput | ErrorCreateOrConnectWithoutCategoryInput[]
    upsert?: ErrorUpsertWithWhereUniqueWithoutCategoryInput | ErrorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ErrorCreateManyCategoryInputEnvelope
    set?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    disconnect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    delete?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    connect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    update?: ErrorUpdateWithWhereUniqueWithoutCategoryInput | ErrorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ErrorUpdateManyWithWhereWithoutCategoryInput | ErrorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ErrorScalarWhereInput | ErrorScalarWhereInput[]
  }

  export type ErrorUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput> | ErrorCreateWithoutCategoryInput[] | ErrorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ErrorCreateOrConnectWithoutCategoryInput | ErrorCreateOrConnectWithoutCategoryInput[]
    upsert?: ErrorUpsertWithWhereUniqueWithoutCategoryInput | ErrorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ErrorCreateManyCategoryInputEnvelope
    set?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    disconnect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    delete?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    connect?: ErrorWhereUniqueInput | ErrorWhereUniqueInput[]
    update?: ErrorUpdateWithWhereUniqueWithoutCategoryInput | ErrorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ErrorUpdateManyWithWhereWithoutCategoryInput | ErrorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ErrorScalarWhereInput | ErrorScalarWhereInput[]
  }

  export type ErrorCategoryCreateNestedOneWithoutErrorsInput = {
    create?: XOR<ErrorCategoryCreateWithoutErrorsInput, ErrorCategoryUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutErrorsInput
    connect?: ErrorCategoryWhereUniqueInput
  }

  export type AssetErrorCreateNestedManyWithoutErrorInput = {
    create?: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput> | AssetErrorCreateWithoutErrorInput[] | AssetErrorUncheckedCreateWithoutErrorInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutErrorInput | AssetErrorCreateOrConnectWithoutErrorInput[]
    createMany?: AssetErrorCreateManyErrorInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type AssetErrorUncheckedCreateNestedManyWithoutErrorInput = {
    create?: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput> | AssetErrorCreateWithoutErrorInput[] | AssetErrorUncheckedCreateWithoutErrorInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutErrorInput | AssetErrorCreateOrConnectWithoutErrorInput[]
    createMany?: AssetErrorCreateManyErrorInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type ErrorCategoryUpdateOneRequiredWithoutErrorsNestedInput = {
    create?: XOR<ErrorCategoryCreateWithoutErrorsInput, ErrorCategoryUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutErrorsInput
    upsert?: ErrorCategoryUpsertWithoutErrorsInput
    connect?: ErrorCategoryWhereUniqueInput
    update?: XOR<XOR<ErrorCategoryUpdateToOneWithWhereWithoutErrorsInput, ErrorCategoryUpdateWithoutErrorsInput>, ErrorCategoryUncheckedUpdateWithoutErrorsInput>
  }

  export type AssetErrorUpdateManyWithoutErrorNestedInput = {
    create?: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput> | AssetErrorCreateWithoutErrorInput[] | AssetErrorUncheckedCreateWithoutErrorInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutErrorInput | AssetErrorCreateOrConnectWithoutErrorInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutErrorInput | AssetErrorUpsertWithWhereUniqueWithoutErrorInput[]
    createMany?: AssetErrorCreateManyErrorInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutErrorInput | AssetErrorUpdateWithWhereUniqueWithoutErrorInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutErrorInput | AssetErrorUpdateManyWithWhereWithoutErrorInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetErrorUncheckedUpdateManyWithoutErrorNestedInput = {
    create?: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput> | AssetErrorCreateWithoutErrorInput[] | AssetErrorUncheckedCreateWithoutErrorInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutErrorInput | AssetErrorCreateOrConnectWithoutErrorInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutErrorInput | AssetErrorUpsertWithWhereUniqueWithoutErrorInput[]
    createMany?: AssetErrorCreateManyErrorInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutErrorInput | AssetErrorUpdateWithWhereUniqueWithoutErrorInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutErrorInput | AssetErrorUpdateManyWithWhereWithoutErrorInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAsset_errorsInput = {
    create?: XOR<AssetCreateWithoutAsset_errorsInput, AssetUncheckedCreateWithoutAsset_errorsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_errorsInput
    connect?: AssetWhereUniqueInput
  }

  export type ErrorCreateNestedOneWithoutAsset_errorsInput = {
    create?: XOR<ErrorCreateWithoutAsset_errorsInput, ErrorUncheckedCreateWithoutAsset_errorsInput>
    connectOrCreate?: ErrorCreateOrConnectWithoutAsset_errorsInput
    connect?: ErrorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAsset_errors_addedInput = {
    create?: XOR<UserCreateWithoutAsset_errors_addedInput, UserUncheckedCreateWithoutAsset_errors_addedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_errors_addedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAsset_errors_fixedInput = {
    create?: XOR<UserCreateWithoutAsset_errors_fixedInput, UserUncheckedCreateWithoutAsset_errors_fixedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_errors_fixedInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AssetUpdateOneRequiredWithoutAsset_errorsNestedInput = {
    create?: XOR<AssetCreateWithoutAsset_errorsInput, AssetUncheckedCreateWithoutAsset_errorsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_errorsInput
    upsert?: AssetUpsertWithoutAsset_errorsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAsset_errorsInput, AssetUpdateWithoutAsset_errorsInput>, AssetUncheckedUpdateWithoutAsset_errorsInput>
  }

  export type ErrorUpdateOneRequiredWithoutAsset_errorsNestedInput = {
    create?: XOR<ErrorCreateWithoutAsset_errorsInput, ErrorUncheckedCreateWithoutAsset_errorsInput>
    connectOrCreate?: ErrorCreateOrConnectWithoutAsset_errorsInput
    upsert?: ErrorUpsertWithoutAsset_errorsInput
    connect?: ErrorWhereUniqueInput
    update?: XOR<XOR<ErrorUpdateToOneWithWhereWithoutAsset_errorsInput, ErrorUpdateWithoutAsset_errorsInput>, ErrorUncheckedUpdateWithoutAsset_errorsInput>
  }

  export type UserUpdateOneRequiredWithoutAsset_errors_addedNestedInput = {
    create?: XOR<UserCreateWithoutAsset_errors_addedInput, UserUncheckedCreateWithoutAsset_errors_addedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_errors_addedInput
    upsert?: UserUpsertWithoutAsset_errors_addedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAsset_errors_addedInput, UserUpdateWithoutAsset_errors_addedInput>, UserUncheckedUpdateWithoutAsset_errors_addedInput>
  }

  export type UserUpdateOneWithoutAsset_errors_fixedNestedInput = {
    create?: XOR<UserCreateWithoutAsset_errors_fixedInput, UserUncheckedCreateWithoutAsset_errors_fixedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_errors_fixedInput
    upsert?: UserUpsertWithoutAsset_errors_fixedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAsset_errors_fixedInput, UserUpdateWithoutAsset_errors_fixedInput>, UserUncheckedUpdateWithoutAsset_errors_fixedInput>
  }

  export type AssetPartCreateNestedManyWithoutPartInput = {
    create?: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput> | AssetPartCreateWithoutPartInput[] | AssetPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutPartInput | AssetPartCreateOrConnectWithoutPartInput[]
    createMany?: AssetPartCreateManyPartInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type AssetPartUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput> | AssetPartCreateWithoutPartInput[] | AssetPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutPartInput | AssetPartCreateOrConnectWithoutPartInput[]
    createMany?: AssetPartCreateManyPartInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AssetPartUpdateManyWithoutPartNestedInput = {
    create?: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput> | AssetPartCreateWithoutPartInput[] | AssetPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutPartInput | AssetPartCreateOrConnectWithoutPartInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutPartInput | AssetPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: AssetPartCreateManyPartInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutPartInput | AssetPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutPartInput | AssetPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type AssetPartUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput> | AssetPartCreateWithoutPartInput[] | AssetPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutPartInput | AssetPartCreateOrConnectWithoutPartInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutPartInput | AssetPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: AssetPartCreateManyPartInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutPartInput | AssetPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutPartInput | AssetPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAsset_partsInput = {
    create?: XOR<AssetCreateWithoutAsset_partsInput, AssetUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_partsInput
    connect?: AssetWhereUniqueInput
  }

  export type PartCreateNestedOneWithoutAsset_partsInput = {
    create?: XOR<PartCreateWithoutAsset_partsInput, PartUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: PartCreateOrConnectWithoutAsset_partsInput
    connect?: PartWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAsset_partsInput = {
    create?: XOR<UserCreateWithoutAsset_partsInput, UserUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_partsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPartOperationFieldUpdateOperationsInput = {
    set?: $Enums.PartOperation
  }

  export type AssetUpdateOneRequiredWithoutAsset_partsNestedInput = {
    create?: XOR<AssetCreateWithoutAsset_partsInput, AssetUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_partsInput
    upsert?: AssetUpsertWithoutAsset_partsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAsset_partsInput, AssetUpdateWithoutAsset_partsInput>, AssetUncheckedUpdateWithoutAsset_partsInput>
  }

  export type PartUpdateOneRequiredWithoutAsset_partsNestedInput = {
    create?: XOR<PartCreateWithoutAsset_partsInput, PartUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: PartCreateOrConnectWithoutAsset_partsInput
    upsert?: PartUpsertWithoutAsset_partsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutAsset_partsInput, PartUpdateWithoutAsset_partsInput>, PartUncheckedUpdateWithoutAsset_partsInput>
  }

  export type UserUpdateOneRequiredWithoutAsset_partsNestedInput = {
    create?: XOR<UserCreateWithoutAsset_partsInput, UserUncheckedCreateWithoutAsset_partsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_partsInput
    upsert?: UserUpsertWithoutAsset_partsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAsset_partsInput, UserUpdateWithoutAsset_partsInput>, UserUncheckedUpdateWithoutAsset_partsInput>
  }

  export type WarehouseCreateNestedOneWithoutOrigin_transfersInput = {
    create?: XOR<WarehouseCreateWithoutOrigin_transfersInput, WarehouseUncheckedCreateWithoutOrigin_transfersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutOrigin_transfersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutDestination_transfersInput = {
    create?: XOR<WarehouseCreateWithoutDestination_transfersInput, WarehouseUncheckedCreateWithoutDestination_transfersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDestination_transfersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutTransfersInput = {
    create?: XOR<OrganizationCreateWithoutTransfersInput, OrganizationUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTransfersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransfersInput = {
    create?: XOR<UserCreateWithoutTransfersInput, UserUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type AssetTransferCreateNestedManyWithoutTransferInput = {
    create?: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput> | AssetTransferCreateWithoutTransferInput[] | AssetTransferUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutTransferInput | AssetTransferCreateOrConnectWithoutTransferInput[]
    createMany?: AssetTransferCreateManyTransferInputEnvelope
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
  }

  export type AssetTransferUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput> | AssetTransferCreateWithoutTransferInput[] | AssetTransferUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutTransferInput | AssetTransferCreateOrConnectWithoutTransferInput[]
    createMany?: AssetTransferCreateManyTransferInputEnvelope
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput = {
    create?: XOR<WarehouseCreateWithoutOrigin_transfersInput, WarehouseUncheckedCreateWithoutOrigin_transfersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutOrigin_transfersInput
    upsert?: WarehouseUpsertWithoutOrigin_transfersInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutOrigin_transfersInput, WarehouseUpdateWithoutOrigin_transfersInput>, WarehouseUncheckedUpdateWithoutOrigin_transfersInput>
  }

  export type WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput = {
    create?: XOR<WarehouseCreateWithoutDestination_transfersInput, WarehouseUncheckedCreateWithoutDestination_transfersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDestination_transfersInput
    upsert?: WarehouseUpsertWithoutDestination_transfersInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutDestination_transfersInput, WarehouseUpdateWithoutDestination_transfersInput>, WarehouseUncheckedUpdateWithoutDestination_transfersInput>
  }

  export type OrganizationUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<OrganizationCreateWithoutTransfersInput, OrganizationUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTransfersInput
    upsert?: OrganizationUpsertWithoutTransfersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTransfersInput, OrganizationUpdateWithoutTransfersInput>, OrganizationUncheckedUpdateWithoutTransfersInput>
  }

  export type UserUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<UserCreateWithoutTransfersInput, UserUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfersInput
    upsert?: UserUpsertWithoutTransfersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfersInput, UserUpdateWithoutTransfersInput>, UserUncheckedUpdateWithoutTransfersInput>
  }

  export type AssetTransferUpdateManyWithoutTransferNestedInput = {
    create?: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput> | AssetTransferCreateWithoutTransferInput[] | AssetTransferUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutTransferInput | AssetTransferCreateOrConnectWithoutTransferInput[]
    upsert?: AssetTransferUpsertWithWhereUniqueWithoutTransferInput | AssetTransferUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: AssetTransferCreateManyTransferInputEnvelope
    set?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    disconnect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    delete?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    update?: AssetTransferUpdateWithWhereUniqueWithoutTransferInput | AssetTransferUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: AssetTransferUpdateManyWithWhereWithoutTransferInput | AssetTransferUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
  }

  export type AssetTransferUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput> | AssetTransferCreateWithoutTransferInput[] | AssetTransferUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: AssetTransferCreateOrConnectWithoutTransferInput | AssetTransferCreateOrConnectWithoutTransferInput[]
    upsert?: AssetTransferUpsertWithWhereUniqueWithoutTransferInput | AssetTransferUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: AssetTransferCreateManyTransferInputEnvelope
    set?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    disconnect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    delete?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    connect?: AssetTransferWhereUniqueInput | AssetTransferWhereUniqueInput[]
    update?: AssetTransferUpdateWithWhereUniqueWithoutTransferInput | AssetTransferUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: AssetTransferUpdateManyWithWhereWithoutTransferInput | AssetTransferUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAsset_transfersInput = {
    create?: XOR<AssetCreateWithoutAsset_transfersInput, AssetUncheckedCreateWithoutAsset_transfersInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_transfersInput
    connect?: AssetWhereUniqueInput
  }

  export type TransferCreateNestedOneWithoutAsset_transfersInput = {
    create?: XOR<TransferCreateWithoutAsset_transfersInput, TransferUncheckedCreateWithoutAsset_transfersInput>
    connectOrCreate?: TransferCreateOrConnectWithoutAsset_transfersInput
    connect?: TransferWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutAsset_transfersNestedInput = {
    create?: XOR<AssetCreateWithoutAsset_transfersInput, AssetUncheckedCreateWithoutAsset_transfersInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_transfersInput
    upsert?: AssetUpsertWithoutAsset_transfersInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAsset_transfersInput, AssetUpdateWithoutAsset_transfersInput>, AssetUncheckedUpdateWithoutAsset_transfersInput>
  }

  export type TransferUpdateOneRequiredWithoutAsset_transfersNestedInput = {
    create?: XOR<TransferCreateWithoutAsset_transfersInput, TransferUncheckedCreateWithoutAsset_transfersInput>
    connectOrCreate?: TransferCreateOrConnectWithoutAsset_transfersInput
    upsert?: TransferUpsertWithoutAsset_transfersInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutAsset_transfersInput, TransferUpdateWithoutAsset_transfersInput>, TransferUncheckedUpdateWithoutAsset_transfersInput>
  }

  export type OrganizationCreateNestedOneWithoutArrivals_originInput = {
    create?: XOR<OrganizationCreateWithoutArrivals_originInput, OrganizationUncheckedCreateWithoutArrivals_originInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutArrivals_originInput
    connect?: OrganizationWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutArrivalsInput = {
    create?: XOR<WarehouseCreateWithoutArrivalsInput, WarehouseUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutArrivalsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutArrivals_transporterInput = {
    create?: XOR<OrganizationCreateWithoutArrivals_transporterInput, OrganizationUncheckedCreateWithoutArrivals_transporterInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutArrivals_transporterInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArrivalsInput = {
    create?: XOR<UserCreateWithoutArrivalsInput, UserUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArrivalsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutArrivalInput = {
    create?: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput> | AssetCreateWithoutArrivalInput[] | AssetUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutArrivalInput | AssetCreateOrConnectWithoutArrivalInput[]
    createMany?: AssetCreateManyArrivalInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutArrivalInput = {
    create?: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput> | AssetCreateWithoutArrivalInput[] | AssetUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutArrivalInput | AssetCreateOrConnectWithoutArrivalInput[]
    createMany?: AssetCreateManyArrivalInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput = {
    create?: XOR<OrganizationCreateWithoutArrivals_originInput, OrganizationUncheckedCreateWithoutArrivals_originInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutArrivals_originInput
    upsert?: OrganizationUpsertWithoutArrivals_originInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutArrivals_originInput, OrganizationUpdateWithoutArrivals_originInput>, OrganizationUncheckedUpdateWithoutArrivals_originInput>
  }

  export type WarehouseUpdateOneRequiredWithoutArrivalsNestedInput = {
    create?: XOR<WarehouseCreateWithoutArrivalsInput, WarehouseUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutArrivalsInput
    upsert?: WarehouseUpsertWithoutArrivalsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutArrivalsInput, WarehouseUpdateWithoutArrivalsInput>, WarehouseUncheckedUpdateWithoutArrivalsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput = {
    create?: XOR<OrganizationCreateWithoutArrivals_transporterInput, OrganizationUncheckedCreateWithoutArrivals_transporterInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutArrivals_transporterInput
    upsert?: OrganizationUpsertWithoutArrivals_transporterInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutArrivals_transporterInput, OrganizationUpdateWithoutArrivals_transporterInput>, OrganizationUncheckedUpdateWithoutArrivals_transporterInput>
  }

  export type UserUpdateOneRequiredWithoutArrivalsNestedInput = {
    create?: XOR<UserCreateWithoutArrivalsInput, UserUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArrivalsInput
    upsert?: UserUpsertWithoutArrivalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArrivalsInput, UserUpdateWithoutArrivalsInput>, UserUncheckedUpdateWithoutArrivalsInput>
  }

  export type AssetUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput> | AssetCreateWithoutArrivalInput[] | AssetUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutArrivalInput | AssetCreateOrConnectWithoutArrivalInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutArrivalInput | AssetUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: AssetCreateManyArrivalInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutArrivalInput | AssetUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutArrivalInput | AssetUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput> | AssetCreateWithoutArrivalInput[] | AssetUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutArrivalInput | AssetCreateOrConnectWithoutArrivalInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutArrivalInput | AssetUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: AssetCreateManyArrivalInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutArrivalInput | AssetUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutArrivalInput | AssetUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type WarehouseCreateNestedOneWithoutDeparturesInput = {
    create?: XOR<WarehouseCreateWithoutDeparturesInput, WarehouseUncheckedCreateWithoutDeparturesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDeparturesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutDepartures_destinationInput = {
    create?: XOR<OrganizationCreateWithoutDepartures_destinationInput, OrganizationUncheckedCreateWithoutDepartures_destinationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartures_destinationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutDepartures_transporterInput = {
    create?: XOR<OrganizationCreateWithoutDepartures_transporterInput, OrganizationUncheckedCreateWithoutDepartures_transporterInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartures_transporterInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeparturesInput = {
    create?: XOR<UserCreateWithoutDeparturesInput, UserUncheckedCreateWithoutDeparturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeparturesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeparture_sales_repsInput = {
    create?: XOR<UserCreateWithoutDeparture_sales_repsInput, UserUncheckedCreateWithoutDeparture_sales_repsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeparture_sales_repsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutDepartureInput = {
    create?: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput> | AssetCreateWithoutDepartureInput[] | AssetUncheckedCreateWithoutDepartureInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutDepartureInput | AssetCreateOrConnectWithoutDepartureInput[]
    createMany?: AssetCreateManyDepartureInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutDepartureInput = {
    create?: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput> | AssetCreateWithoutDepartureInput[] | AssetUncheckedCreateWithoutDepartureInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutDepartureInput | AssetCreateOrConnectWithoutDepartureInput[]
    createMany?: AssetCreateManyDepartureInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutDeparturesNestedInput = {
    create?: XOR<WarehouseCreateWithoutDeparturesInput, WarehouseUncheckedCreateWithoutDeparturesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDeparturesInput
    upsert?: WarehouseUpsertWithoutDeparturesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutDeparturesInput, WarehouseUpdateWithoutDeparturesInput>, WarehouseUncheckedUpdateWithoutDeparturesInput>
  }

  export type OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput = {
    create?: XOR<OrganizationCreateWithoutDepartures_destinationInput, OrganizationUncheckedCreateWithoutDepartures_destinationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartures_destinationInput
    upsert?: OrganizationUpsertWithoutDepartures_destinationInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDepartures_destinationInput, OrganizationUpdateWithoutDepartures_destinationInput>, OrganizationUncheckedUpdateWithoutDepartures_destinationInput>
  }

  export type OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput = {
    create?: XOR<OrganizationCreateWithoutDepartures_transporterInput, OrganizationUncheckedCreateWithoutDepartures_transporterInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartures_transporterInput
    upsert?: OrganizationUpsertWithoutDepartures_transporterInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDepartures_transporterInput, OrganizationUpdateWithoutDepartures_transporterInput>, OrganizationUncheckedUpdateWithoutDepartures_transporterInput>
  }

  export type UserUpdateOneRequiredWithoutDeparturesNestedInput = {
    create?: XOR<UserCreateWithoutDeparturesInput, UserUncheckedCreateWithoutDeparturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeparturesInput
    upsert?: UserUpsertWithoutDeparturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeparturesInput, UserUpdateWithoutDeparturesInput>, UserUncheckedUpdateWithoutDeparturesInput>
  }

  export type UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput = {
    create?: XOR<UserCreateWithoutDeparture_sales_repsInput, UserUncheckedCreateWithoutDeparture_sales_repsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeparture_sales_repsInput
    upsert?: UserUpsertWithoutDeparture_sales_repsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeparture_sales_repsInput, UserUpdateWithoutDeparture_sales_repsInput>, UserUncheckedUpdateWithoutDeparture_sales_repsInput>
  }

  export type AssetUpdateManyWithoutDepartureNestedInput = {
    create?: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput> | AssetCreateWithoutDepartureInput[] | AssetUncheckedCreateWithoutDepartureInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutDepartureInput | AssetCreateOrConnectWithoutDepartureInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutDepartureInput | AssetUpsertWithWhereUniqueWithoutDepartureInput[]
    createMany?: AssetCreateManyDepartureInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutDepartureInput | AssetUpdateWithWhereUniqueWithoutDepartureInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutDepartureInput | AssetUpdateManyWithWhereWithoutDepartureInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutDepartureNestedInput = {
    create?: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput> | AssetCreateWithoutDepartureInput[] | AssetUncheckedCreateWithoutDepartureInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutDepartureInput | AssetCreateOrConnectWithoutDepartureInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutDepartureInput | AssetUpsertWithWhereUniqueWithoutDepartureInput[]
    createMany?: AssetCreateManyDepartureInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutDepartureInput | AssetUpdateWithWhereUniqueWithoutDepartureInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutDepartureInput | AssetUpdateManyWithWhereWithoutDepartureInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHolds_createdInput = {
    create?: XOR<UserCreateWithoutHolds_createdInput, UserUncheckedCreateWithoutHolds_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolds_createdInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHolds_forInput = {
    create?: XOR<UserCreateWithoutHolds_forInput, UserUncheckedCreateWithoutHolds_forInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolds_forInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutHoldsInput = {
    create?: XOR<OrganizationCreateWithoutHoldsInput, OrganizationUncheckedCreateWithoutHoldsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutHoldsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutHoldInput = {
    create?: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput> | AssetCreateWithoutHoldInput[] | AssetUncheckedCreateWithoutHoldInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutHoldInput | AssetCreateOrConnectWithoutHoldInput[]
    createMany?: AssetCreateManyHoldInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutHoldInput = {
    create?: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput> | AssetCreateWithoutHoldInput[] | AssetUncheckedCreateWithoutHoldInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutHoldInput | AssetCreateOrConnectWithoutHoldInput[]
    createMany?: AssetCreateManyHoldInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHolds_createdNestedInput = {
    create?: XOR<UserCreateWithoutHolds_createdInput, UserUncheckedCreateWithoutHolds_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolds_createdInput
    upsert?: UserUpsertWithoutHolds_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHolds_createdInput, UserUpdateWithoutHolds_createdInput>, UserUncheckedUpdateWithoutHolds_createdInput>
  }

  export type UserUpdateOneRequiredWithoutHolds_forNestedInput = {
    create?: XOR<UserCreateWithoutHolds_forInput, UserUncheckedCreateWithoutHolds_forInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolds_forInput
    upsert?: UserUpsertWithoutHolds_forInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHolds_forInput, UserUpdateWithoutHolds_forInput>, UserUncheckedUpdateWithoutHolds_forInput>
  }

  export type OrganizationUpdateOneRequiredWithoutHoldsNestedInput = {
    create?: XOR<OrganizationCreateWithoutHoldsInput, OrganizationUncheckedCreateWithoutHoldsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutHoldsInput
    upsert?: OrganizationUpsertWithoutHoldsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutHoldsInput, OrganizationUpdateWithoutHoldsInput>, OrganizationUncheckedUpdateWithoutHoldsInput>
  }

  export type AssetUpdateManyWithoutHoldNestedInput = {
    create?: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput> | AssetCreateWithoutHoldInput[] | AssetUncheckedCreateWithoutHoldInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutHoldInput | AssetCreateOrConnectWithoutHoldInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutHoldInput | AssetUpsertWithWhereUniqueWithoutHoldInput[]
    createMany?: AssetCreateManyHoldInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutHoldInput | AssetUpdateWithWhereUniqueWithoutHoldInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutHoldInput | AssetUpdateManyWithWhereWithoutHoldInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutHoldNestedInput = {
    create?: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput> | AssetCreateWithoutHoldInput[] | AssetUncheckedCreateWithoutHoldInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutHoldInput | AssetCreateOrConnectWithoutHoldInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutHoldInput | AssetUpsertWithWhereUniqueWithoutHoldInput[]
    createMany?: AssetCreateManyHoldInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutHoldInput | AssetUpdateWithWhereUniqueWithoutHoldInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutHoldInput | AssetUpdateManyWithWhereWithoutHoldInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrganizationCreateWithoutInvoicesInput, OrganizationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoicesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoices_updatedInput = {
    create?: XOR<UserCreateWithoutInvoices_updatedInput, UserUncheckedCreateWithoutInvoices_updatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoices_updatedInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutPurchase_invoiceInput = {
    create?: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput> | AssetCreateWithoutPurchase_invoiceInput[] | AssetUncheckedCreateWithoutPurchase_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchase_invoiceInput | AssetCreateOrConnectWithoutPurchase_invoiceInput[]
    createMany?: AssetCreateManyPurchase_invoiceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutSales_invoiceInput = {
    create?: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput> | AssetCreateWithoutSales_invoiceInput[] | AssetUncheckedCreateWithoutSales_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSales_invoiceInput | AssetCreateOrConnectWithoutSales_invoiceInput[]
    createMany?: AssetCreateManySales_invoiceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutPurchase_invoiceInput = {
    create?: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput> | AssetCreateWithoutPurchase_invoiceInput[] | AssetUncheckedCreateWithoutPurchase_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchase_invoiceInput | AssetCreateOrConnectWithoutPurchase_invoiceInput[]
    createMany?: AssetCreateManyPurchase_invoiceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutSales_invoiceInput = {
    create?: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput> | AssetCreateWithoutSales_invoiceInput[] | AssetUncheckedCreateWithoutSales_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSales_invoiceInput | AssetCreateOrConnectWithoutSales_invoiceInput[]
    createMany?: AssetCreateManySales_invoiceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type OrganizationUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvoicesInput, OrganizationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoicesInput
    upsert?: OrganizationUpsertWithoutInvoicesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvoicesInput, OrganizationUpdateWithoutInvoicesInput>, OrganizationUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutInvoices_updatedNestedInput = {
    create?: XOR<UserCreateWithoutInvoices_updatedInput, UserUncheckedCreateWithoutInvoices_updatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoices_updatedInput
    upsert?: UserUpsertWithoutInvoices_updatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoices_updatedInput, UserUpdateWithoutInvoices_updatedInput>, UserUncheckedUpdateWithoutInvoices_updatedInput>
  }

  export type AssetUpdateManyWithoutPurchase_invoiceNestedInput = {
    create?: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput> | AssetCreateWithoutPurchase_invoiceInput[] | AssetUncheckedCreateWithoutPurchase_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchase_invoiceInput | AssetCreateOrConnectWithoutPurchase_invoiceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPurchase_invoiceInput | AssetUpsertWithWhereUniqueWithoutPurchase_invoiceInput[]
    createMany?: AssetCreateManyPurchase_invoiceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPurchase_invoiceInput | AssetUpdateWithWhereUniqueWithoutPurchase_invoiceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPurchase_invoiceInput | AssetUpdateManyWithWhereWithoutPurchase_invoiceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutSales_invoiceNestedInput = {
    create?: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput> | AssetCreateWithoutSales_invoiceInput[] | AssetUncheckedCreateWithoutSales_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSales_invoiceInput | AssetCreateOrConnectWithoutSales_invoiceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutSales_invoiceInput | AssetUpsertWithWhereUniqueWithoutSales_invoiceInput[]
    createMany?: AssetCreateManySales_invoiceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutSales_invoiceInput | AssetUpdateWithWhereUniqueWithoutSales_invoiceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutSales_invoiceInput | AssetUpdateManyWithWhereWithoutSales_invoiceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutPurchase_invoiceNestedInput = {
    create?: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput> | AssetCreateWithoutPurchase_invoiceInput[] | AssetUncheckedCreateWithoutPurchase_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchase_invoiceInput | AssetCreateOrConnectWithoutPurchase_invoiceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPurchase_invoiceInput | AssetUpsertWithWhereUniqueWithoutPurchase_invoiceInput[]
    createMany?: AssetCreateManyPurchase_invoiceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPurchase_invoiceInput | AssetUpdateWithWhereUniqueWithoutPurchase_invoiceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPurchase_invoiceInput | AssetUpdateManyWithWhereWithoutPurchase_invoiceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutSales_invoiceNestedInput = {
    create?: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput> | AssetCreateWithoutSales_invoiceInput[] | AssetUncheckedCreateWithoutSales_invoiceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSales_invoiceInput | AssetCreateOrConnectWithoutSales_invoiceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutSales_invoiceInput | AssetUpsertWithWhereUniqueWithoutSales_invoiceInput[]
    createMany?: AssetCreateManySales_invoiceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutSales_invoiceInput | AssetUpdateWithWhereUniqueWithoutSales_invoiceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutSales_invoiceInput | AssetUpdateManyWithWhereWithoutSales_invoiceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput> | AssetCreateWithoutWarehouseInput[] | AssetUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWarehouseInput | AssetCreateOrConnectWithoutWarehouseInput[]
    createMany?: AssetCreateManyWarehouseInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutOriginInput = {
    create?: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput> | TransferCreateWithoutOriginInput[] | TransferUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutOriginInput | TransferCreateOrConnectWithoutOriginInput[]
    createMany?: TransferCreateManyOriginInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutDestinationInput = {
    create?: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput> | TransferCreateWithoutDestinationInput[] | TransferUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestinationInput | TransferCreateOrConnectWithoutDestinationInput[]
    createMany?: TransferCreateManyDestinationInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type DepartureCreateNestedManyWithoutOriginInput = {
    create?: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput> | DepartureCreateWithoutOriginInput[] | DepartureUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutOriginInput | DepartureCreateOrConnectWithoutOriginInput[]
    createMany?: DepartureCreateManyOriginInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type ArrivalCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput> | ArrivalCreateWithoutDestinationInput[] | ArrivalUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutDestinationInput | ArrivalCreateOrConnectWithoutDestinationInput[]
    createMany?: ArrivalCreateManyDestinationInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput> | AssetCreateWithoutWarehouseInput[] | AssetUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWarehouseInput | AssetCreateOrConnectWithoutWarehouseInput[]
    createMany?: AssetCreateManyWarehouseInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput> | TransferCreateWithoutOriginInput[] | TransferUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutOriginInput | TransferCreateOrConnectWithoutOriginInput[]
    createMany?: TransferCreateManyOriginInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput> | TransferCreateWithoutDestinationInput[] | TransferUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestinationInput | TransferCreateOrConnectWithoutDestinationInput[]
    createMany?: TransferCreateManyDestinationInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type DepartureUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput> | DepartureCreateWithoutOriginInput[] | DepartureUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutOriginInput | DepartureCreateOrConnectWithoutOriginInput[]
    createMany?: DepartureCreateManyOriginInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type ArrivalUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput> | ArrivalCreateWithoutDestinationInput[] | ArrivalUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutDestinationInput | ArrivalCreateOrConnectWithoutDestinationInput[]
    createMany?: ArrivalCreateManyDestinationInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AssetUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput> | AssetCreateWithoutWarehouseInput[] | AssetUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWarehouseInput | AssetCreateOrConnectWithoutWarehouseInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWarehouseInput | AssetUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AssetCreateManyWarehouseInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWarehouseInput | AssetUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWarehouseInput | AssetUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutOriginNestedInput = {
    create?: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput> | TransferCreateWithoutOriginInput[] | TransferUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutOriginInput | TransferCreateOrConnectWithoutOriginInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutOriginInput | TransferUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: TransferCreateManyOriginInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutOriginInput | TransferUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutOriginInput | TransferUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput> | TransferCreateWithoutDestinationInput[] | TransferUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestinationInput | TransferCreateOrConnectWithoutDestinationInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestinationInput | TransferUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: TransferCreateManyDestinationInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestinationInput | TransferUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestinationInput | TransferUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type DepartureUpdateManyWithoutOriginNestedInput = {
    create?: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput> | DepartureCreateWithoutOriginInput[] | DepartureUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutOriginInput | DepartureCreateOrConnectWithoutOriginInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutOriginInput | DepartureUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: DepartureCreateManyOriginInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutOriginInput | DepartureUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutOriginInput | DepartureUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type ArrivalUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput> | ArrivalCreateWithoutDestinationInput[] | ArrivalUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutDestinationInput | ArrivalCreateOrConnectWithoutDestinationInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutDestinationInput | ArrivalUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ArrivalCreateManyDestinationInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutDestinationInput | ArrivalUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutDestinationInput | ArrivalUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutWarehouseInput | LocationUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutWarehouseInput | LocationUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutWarehouseInput | LocationUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput> | AssetCreateWithoutWarehouseInput[] | AssetUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWarehouseInput | AssetCreateOrConnectWithoutWarehouseInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWarehouseInput | AssetUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AssetCreateManyWarehouseInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWarehouseInput | AssetUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWarehouseInput | AssetUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput> | TransferCreateWithoutOriginInput[] | TransferUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutOriginInput | TransferCreateOrConnectWithoutOriginInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutOriginInput | TransferUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: TransferCreateManyOriginInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutOriginInput | TransferUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutOriginInput | TransferUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput> | TransferCreateWithoutDestinationInput[] | TransferUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestinationInput | TransferCreateOrConnectWithoutDestinationInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestinationInput | TransferUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: TransferCreateManyDestinationInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestinationInput | TransferUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestinationInput | TransferUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type DepartureUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput> | DepartureCreateWithoutOriginInput[] | DepartureUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutOriginInput | DepartureCreateOrConnectWithoutOriginInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutOriginInput | DepartureUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: DepartureCreateManyOriginInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutOriginInput | DepartureUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutOriginInput | DepartureUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type ArrivalUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput> | ArrivalCreateWithoutDestinationInput[] | ArrivalUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutDestinationInput | ArrivalCreateOrConnectWithoutDestinationInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutDestinationInput | ArrivalUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ArrivalCreateManyDestinationInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutDestinationInput | ArrivalUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutDestinationInput | ArrivalUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutWarehouseInput | LocationUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutWarehouseInput | LocationUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutWarehouseInput | LocationUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type WarehouseCreateNestedOneWithoutLocationsInput = {
    create?: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutLocationInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationsInput
    upsert?: WarehouseUpsertWithoutLocationsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutLocationsInput, WarehouseUpdateWithoutLocationsInput>, WarehouseUncheckedUpdateWithoutLocationsInput>
  }

  export type AssetUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutLocationInput | AssetUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutLocationInput | AssetUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutLocationInput | AssetUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutLocationInput | AssetUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutLocationInput | AssetUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutLocationInput | AssetUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type ModelCreateNestedManyWithoutBrandInput = {
    create?: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput> | ModelCreateWithoutBrandInput[] | ModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutBrandInput | ModelCreateOrConnectWithoutBrandInput[]
    createMany?: ModelCreateManyBrandInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ErrorCategoryCreateNestedManyWithoutBrandInput = {
    create?: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput> | ErrorCategoryCreateWithoutBrandInput[] | ErrorCategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutBrandInput | ErrorCategoryCreateOrConnectWithoutBrandInput[]
    createMany?: ErrorCategoryCreateManyBrandInputEnvelope
    connect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutBrandInput = {
    create?: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput> | AssetCreateWithoutBrandInput[] | AssetUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBrandInput | AssetCreateOrConnectWithoutBrandInput[]
    createMany?: AssetCreateManyBrandInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput> | ModelCreateWithoutBrandInput[] | ModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutBrandInput | ModelCreateOrConnectWithoutBrandInput[]
    createMany?: ModelCreateManyBrandInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ErrorCategoryUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput> | ErrorCategoryCreateWithoutBrandInput[] | ErrorCategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutBrandInput | ErrorCategoryCreateOrConnectWithoutBrandInput[]
    createMany?: ErrorCategoryCreateManyBrandInputEnvelope
    connect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput> | AssetCreateWithoutBrandInput[] | AssetUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBrandInput | AssetCreateOrConnectWithoutBrandInput[]
    createMany?: AssetCreateManyBrandInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type ModelUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput> | ModelCreateWithoutBrandInput[] | ModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutBrandInput | ModelCreateOrConnectWithoutBrandInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutBrandInput | ModelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ModelCreateManyBrandInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutBrandInput | ModelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutBrandInput | ModelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ErrorCategoryUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput> | ErrorCategoryCreateWithoutBrandInput[] | ErrorCategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutBrandInput | ErrorCategoryCreateOrConnectWithoutBrandInput[]
    upsert?: ErrorCategoryUpsertWithWhereUniqueWithoutBrandInput | ErrorCategoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ErrorCategoryCreateManyBrandInputEnvelope
    set?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    disconnect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    delete?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    connect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    update?: ErrorCategoryUpdateWithWhereUniqueWithoutBrandInput | ErrorCategoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ErrorCategoryUpdateManyWithWhereWithoutBrandInput | ErrorCategoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ErrorCategoryScalarWhereInput | ErrorCategoryScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutBrandNestedInput = {
    create?: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput> | AssetCreateWithoutBrandInput[] | AssetUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBrandInput | AssetCreateOrConnectWithoutBrandInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBrandInput | AssetUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: AssetCreateManyBrandInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBrandInput | AssetUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBrandInput | AssetUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput> | ModelCreateWithoutBrandInput[] | ModelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutBrandInput | ModelCreateOrConnectWithoutBrandInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutBrandInput | ModelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ModelCreateManyBrandInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutBrandInput | ModelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutBrandInput | ModelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ErrorCategoryUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput> | ErrorCategoryCreateWithoutBrandInput[] | ErrorCategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ErrorCategoryCreateOrConnectWithoutBrandInput | ErrorCategoryCreateOrConnectWithoutBrandInput[]
    upsert?: ErrorCategoryUpsertWithWhereUniqueWithoutBrandInput | ErrorCategoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ErrorCategoryCreateManyBrandInputEnvelope
    set?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    disconnect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    delete?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    connect?: ErrorCategoryWhereUniqueInput | ErrorCategoryWhereUniqueInput[]
    update?: ErrorCategoryUpdateWithWhereUniqueWithoutBrandInput | ErrorCategoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ErrorCategoryUpdateManyWithWhereWithoutBrandInput | ErrorCategoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ErrorCategoryScalarWhereInput | ErrorCategoryScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput> | AssetCreateWithoutBrandInput[] | AssetUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBrandInput | AssetCreateOrConnectWithoutBrandInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBrandInput | AssetUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: AssetCreateManyBrandInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBrandInput | AssetUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBrandInput | AssetUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type BrandCreateNestedOneWithoutModelsInput = {
    create?: XOR<BrandCreateWithoutModelsInput, BrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutModelsInput
    connect?: BrandWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutModelInput = {
    create?: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput> | AssetCreateWithoutModelInput[] | AssetUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutModelInput | AssetCreateOrConnectWithoutModelInput[]
    createMany?: AssetCreateManyModelInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput> | AssetCreateWithoutModelInput[] | AssetUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutModelInput | AssetCreateOrConnectWithoutModelInput[]
    createMany?: AssetCreateManyModelInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BrandUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<BrandCreateWithoutModelsInput, BrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutModelsInput
    upsert?: BrandUpsertWithoutModelsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutModelsInput, BrandUpdateWithoutModelsInput>, BrandUncheckedUpdateWithoutModelsInput>
  }

  export type AssetUpdateManyWithoutModelNestedInput = {
    create?: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput> | AssetCreateWithoutModelInput[] | AssetUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutModelInput | AssetCreateOrConnectWithoutModelInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutModelInput | AssetUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AssetCreateManyModelInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutModelInput | AssetUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutModelInput | AssetUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput> | AssetCreateWithoutModelInput[] | AssetUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutModelInput | AssetCreateOrConnectWithoutModelInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutModelInput | AssetUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AssetCreateManyModelInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutModelInput | AssetUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutModelInput | AssetUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutFilesInput = {
    create?: XOR<AssetCreateWithoutFilesInput, AssetUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutFilesInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFilesInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type AssetUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<AssetCreateWithoutFilesInput, AssetUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutFilesInput
    upsert?: AssetUpsertWithoutFilesInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutFilesInput, AssetUpdateWithoutFilesInput>, AssetUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    upsert?: UserUpsertWithoutFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesInput, UserUpdateWithoutFilesInput>, UserUncheckedUpdateWithoutFilesInput>
  }

  export type AssetCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCommentsInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCommentsInput
    upsert?: AssetUpsertWithoutCommentsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutCommentsInput, AssetUpdateWithoutCommentsInput>, AssetUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type AssetErrorCreateNestedManyWithoutAddedByInput = {
    create?: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput> | AssetErrorCreateWithoutAddedByInput[] | AssetErrorUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAddedByInput | AssetErrorCreateOrConnectWithoutAddedByInput[]
    createMany?: AssetErrorCreateManyAddedByInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type AssetErrorCreateNestedManyWithoutFixedByInput = {
    create?: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput> | AssetErrorCreateWithoutFixedByInput[] | AssetErrorUncheckedCreateWithoutFixedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutFixedByInput | AssetErrorCreateOrConnectWithoutFixedByInput[]
    createMany?: AssetErrorCreateManyFixedByInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput> | TransferCreateWithoutCreated_byInput[] | TransferUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreated_byInput | TransferCreateOrConnectWithoutCreated_byInput[]
    createMany?: TransferCreateManyCreated_byInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type DepartureCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput> | DepartureCreateWithoutCreated_byInput[] | DepartureUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutCreated_byInput | DepartureCreateOrConnectWithoutCreated_byInput[]
    createMany?: DepartureCreateManyCreated_byInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type DepartureCreateNestedManyWithoutSales_representativeInput = {
    create?: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput> | DepartureCreateWithoutSales_representativeInput[] | DepartureUncheckedCreateWithoutSales_representativeInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutSales_representativeInput | DepartureCreateOrConnectWithoutSales_representativeInput[]
    createMany?: DepartureCreateManySales_representativeInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type ArrivalCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput> | ArrivalCreateWithoutCreated_byInput[] | ArrivalUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutCreated_byInput | ArrivalCreateOrConnectWithoutCreated_byInput[]
    createMany?: ArrivalCreateManyCreated_byInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type HoldCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput> | HoldCreateWithoutCreated_byInput[] | HoldUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_byInput | HoldCreateOrConnectWithoutCreated_byInput[]
    createMany?: HoldCreateManyCreated_byInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type HoldCreateNestedManyWithoutCreated_forInput = {
    create?: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput> | HoldCreateWithoutCreated_forInput[] | HoldUncheckedCreateWithoutCreated_forInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_forInput | HoldCreateOrConnectWithoutCreated_forInput[]
    createMany?: HoldCreateManyCreated_forInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUpdated_byInput = {
    create?: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput> | InvoiceCreateWithoutUpdated_byInput[] | InvoiceUncheckedCreateWithoutUpdated_byInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdated_byInput | InvoiceCreateOrConnectWithoutUpdated_byInput[]
    createMany?: InvoiceCreateManyUpdated_byInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUploaded_byInput = {
    create?: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput> | FileCreateWithoutUploaded_byInput[] | FileUncheckedCreateWithoutUploaded_byInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaded_byInput | FileCreateOrConnectWithoutUploaded_byInput[]
    createMany?: FileCreateManyUploaded_byInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput> | CommentCreateWithoutCreated_byInput[] | CommentUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreated_byInput | CommentCreateOrConnectWithoutCreated_byInput[]
    createMany?: CommentCreateManyCreated_byInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AssetHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput> | AssetHistoryCreateWithoutUserInput[] | AssetHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUserInput | AssetHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AssetHistoryCreateManyUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AssetPartCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput> | AssetPartCreateWithoutUpdatedByInput[] | AssetPartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutUpdatedByInput | AssetPartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: AssetPartCreateManyUpdatedByInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type AssetErrorUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput> | AssetErrorCreateWithoutAddedByInput[] | AssetErrorUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAddedByInput | AssetErrorCreateOrConnectWithoutAddedByInput[]
    createMany?: AssetErrorCreateManyAddedByInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type AssetErrorUncheckedCreateNestedManyWithoutFixedByInput = {
    create?: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput> | AssetErrorCreateWithoutFixedByInput[] | AssetErrorUncheckedCreateWithoutFixedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutFixedByInput | AssetErrorCreateOrConnectWithoutFixedByInput[]
    createMany?: AssetErrorCreateManyFixedByInputEnvelope
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput> | TransferCreateWithoutCreated_byInput[] | TransferUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreated_byInput | TransferCreateOrConnectWithoutCreated_byInput[]
    createMany?: TransferCreateManyCreated_byInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type DepartureUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput> | DepartureCreateWithoutCreated_byInput[] | DepartureUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutCreated_byInput | DepartureCreateOrConnectWithoutCreated_byInput[]
    createMany?: DepartureCreateManyCreated_byInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type DepartureUncheckedCreateNestedManyWithoutSales_representativeInput = {
    create?: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput> | DepartureCreateWithoutSales_representativeInput[] | DepartureUncheckedCreateWithoutSales_representativeInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutSales_representativeInput | DepartureCreateOrConnectWithoutSales_representativeInput[]
    createMany?: DepartureCreateManySales_representativeInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type ArrivalUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput> | ArrivalCreateWithoutCreated_byInput[] | ArrivalUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutCreated_byInput | ArrivalCreateOrConnectWithoutCreated_byInput[]
    createMany?: ArrivalCreateManyCreated_byInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type HoldUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput> | HoldCreateWithoutCreated_byInput[] | HoldUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_byInput | HoldCreateOrConnectWithoutCreated_byInput[]
    createMany?: HoldCreateManyCreated_byInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type HoldUncheckedCreateNestedManyWithoutCreated_forInput = {
    create?: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput> | HoldCreateWithoutCreated_forInput[] | HoldUncheckedCreateWithoutCreated_forInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_forInput | HoldCreateOrConnectWithoutCreated_forInput[]
    createMany?: HoldCreateManyCreated_forInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput = {
    create?: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput> | InvoiceCreateWithoutUpdated_byInput[] | InvoiceUncheckedCreateWithoutUpdated_byInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdated_byInput | InvoiceCreateOrConnectWithoutUpdated_byInput[]
    createMany?: InvoiceCreateManyUpdated_byInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUploaded_byInput = {
    create?: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput> | FileCreateWithoutUploaded_byInput[] | FileUncheckedCreateWithoutUploaded_byInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaded_byInput | FileCreateOrConnectWithoutUploaded_byInput[]
    createMany?: FileCreateManyUploaded_byInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput> | CommentCreateWithoutCreated_byInput[] | CommentUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreated_byInput | CommentCreateOrConnectWithoutCreated_byInput[]
    createMany?: CommentCreateManyCreated_byInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AssetHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput> | AssetHistoryCreateWithoutUserInput[] | AssetHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUserInput | AssetHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AssetHistoryCreateManyUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput> | AssetPartCreateWithoutUpdatedByInput[] | AssetPartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutUpdatedByInput | AssetPartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: AssetPartCreateManyUpdatedByInputEnvelope
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AssetErrorUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput> | AssetErrorCreateWithoutAddedByInput[] | AssetErrorUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAddedByInput | AssetErrorCreateOrConnectWithoutAddedByInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutAddedByInput | AssetErrorUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: AssetErrorCreateManyAddedByInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutAddedByInput | AssetErrorUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutAddedByInput | AssetErrorUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetErrorUpdateManyWithoutFixedByNestedInput = {
    create?: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput> | AssetErrorCreateWithoutFixedByInput[] | AssetErrorUncheckedCreateWithoutFixedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutFixedByInput | AssetErrorCreateOrConnectWithoutFixedByInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutFixedByInput | AssetErrorUpsertWithWhereUniqueWithoutFixedByInput[]
    createMany?: AssetErrorCreateManyFixedByInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutFixedByInput | AssetErrorUpdateWithWhereUniqueWithoutFixedByInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutFixedByInput | AssetErrorUpdateManyWithWhereWithoutFixedByInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput> | TransferCreateWithoutCreated_byInput[] | TransferUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreated_byInput | TransferCreateOrConnectWithoutCreated_byInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreated_byInput | TransferUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: TransferCreateManyCreated_byInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreated_byInput | TransferUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreated_byInput | TransferUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type DepartureUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput> | DepartureCreateWithoutCreated_byInput[] | DepartureUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutCreated_byInput | DepartureCreateOrConnectWithoutCreated_byInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutCreated_byInput | DepartureUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: DepartureCreateManyCreated_byInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutCreated_byInput | DepartureUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutCreated_byInput | DepartureUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type DepartureUpdateManyWithoutSales_representativeNestedInput = {
    create?: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput> | DepartureCreateWithoutSales_representativeInput[] | DepartureUncheckedCreateWithoutSales_representativeInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutSales_representativeInput | DepartureCreateOrConnectWithoutSales_representativeInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutSales_representativeInput | DepartureUpsertWithWhereUniqueWithoutSales_representativeInput[]
    createMany?: DepartureCreateManySales_representativeInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutSales_representativeInput | DepartureUpdateWithWhereUniqueWithoutSales_representativeInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutSales_representativeInput | DepartureUpdateManyWithWhereWithoutSales_representativeInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type ArrivalUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput> | ArrivalCreateWithoutCreated_byInput[] | ArrivalUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutCreated_byInput | ArrivalCreateOrConnectWithoutCreated_byInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutCreated_byInput | ArrivalUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: ArrivalCreateManyCreated_byInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutCreated_byInput | ArrivalUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutCreated_byInput | ArrivalUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type HoldUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput> | HoldCreateWithoutCreated_byInput[] | HoldUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_byInput | HoldCreateOrConnectWithoutCreated_byInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCreated_byInput | HoldUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: HoldCreateManyCreated_byInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCreated_byInput | HoldUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCreated_byInput | HoldUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type HoldUpdateManyWithoutCreated_forNestedInput = {
    create?: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput> | HoldCreateWithoutCreated_forInput[] | HoldUncheckedCreateWithoutCreated_forInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_forInput | HoldCreateOrConnectWithoutCreated_forInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCreated_forInput | HoldUpsertWithWhereUniqueWithoutCreated_forInput[]
    createMany?: HoldCreateManyCreated_forInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCreated_forInput | HoldUpdateWithWhereUniqueWithoutCreated_forInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCreated_forInput | HoldUpdateManyWithWhereWithoutCreated_forInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUpdated_byNestedInput = {
    create?: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput> | InvoiceCreateWithoutUpdated_byInput[] | InvoiceUncheckedCreateWithoutUpdated_byInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdated_byInput | InvoiceCreateOrConnectWithoutUpdated_byInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUpdated_byInput | InvoiceUpsertWithWhereUniqueWithoutUpdated_byInput[]
    createMany?: InvoiceCreateManyUpdated_byInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUpdated_byInput | InvoiceUpdateWithWhereUniqueWithoutUpdated_byInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUpdated_byInput | InvoiceUpdateManyWithWhereWithoutUpdated_byInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUploaded_byNestedInput = {
    create?: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput> | FileCreateWithoutUploaded_byInput[] | FileUncheckedCreateWithoutUploaded_byInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaded_byInput | FileCreateOrConnectWithoutUploaded_byInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaded_byInput | FileUpsertWithWhereUniqueWithoutUploaded_byInput[]
    createMany?: FileCreateManyUploaded_byInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaded_byInput | FileUpdateWithWhereUniqueWithoutUploaded_byInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaded_byInput | FileUpdateManyWithWhereWithoutUploaded_byInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput> | CommentCreateWithoutCreated_byInput[] | CommentUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreated_byInput | CommentCreateOrConnectWithoutCreated_byInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCreated_byInput | CommentUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: CommentCreateManyCreated_byInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCreated_byInput | CommentUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCreated_byInput | CommentUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssetHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput> | AssetHistoryCreateWithoutUserInput[] | AssetHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUserInput | AssetHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssetHistoryCreateManyUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUserInput | AssetHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AssetPartUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput> | AssetPartCreateWithoutUpdatedByInput[] | AssetPartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutUpdatedByInput | AssetPartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutUpdatedByInput | AssetPartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: AssetPartCreateManyUpdatedByInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutUpdatedByInput | AssetPartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutUpdatedByInput | AssetPartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput> | AssetErrorCreateWithoutAddedByInput[] | AssetErrorUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutAddedByInput | AssetErrorCreateOrConnectWithoutAddedByInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutAddedByInput | AssetErrorUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: AssetErrorCreateManyAddedByInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutAddedByInput | AssetErrorUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutAddedByInput | AssetErrorUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput = {
    create?: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput> | AssetErrorCreateWithoutFixedByInput[] | AssetErrorUncheckedCreateWithoutFixedByInput[]
    connectOrCreate?: AssetErrorCreateOrConnectWithoutFixedByInput | AssetErrorCreateOrConnectWithoutFixedByInput[]
    upsert?: AssetErrorUpsertWithWhereUniqueWithoutFixedByInput | AssetErrorUpsertWithWhereUniqueWithoutFixedByInput[]
    createMany?: AssetErrorCreateManyFixedByInputEnvelope
    set?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    disconnect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    delete?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    connect?: AssetErrorWhereUniqueInput | AssetErrorWhereUniqueInput[]
    update?: AssetErrorUpdateWithWhereUniqueWithoutFixedByInput | AssetErrorUpdateWithWhereUniqueWithoutFixedByInput[]
    updateMany?: AssetErrorUpdateManyWithWhereWithoutFixedByInput | AssetErrorUpdateManyWithWhereWithoutFixedByInput[]
    deleteMany?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput> | TransferCreateWithoutCreated_byInput[] | TransferUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreated_byInput | TransferCreateOrConnectWithoutCreated_byInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreated_byInput | TransferUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: TransferCreateManyCreated_byInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreated_byInput | TransferUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreated_byInput | TransferUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type DepartureUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput> | DepartureCreateWithoutCreated_byInput[] | DepartureUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutCreated_byInput | DepartureCreateOrConnectWithoutCreated_byInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutCreated_byInput | DepartureUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: DepartureCreateManyCreated_byInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutCreated_byInput | DepartureUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutCreated_byInput | DepartureUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput = {
    create?: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput> | DepartureCreateWithoutSales_representativeInput[] | DepartureUncheckedCreateWithoutSales_representativeInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutSales_representativeInput | DepartureCreateOrConnectWithoutSales_representativeInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutSales_representativeInput | DepartureUpsertWithWhereUniqueWithoutSales_representativeInput[]
    createMany?: DepartureCreateManySales_representativeInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutSales_representativeInput | DepartureUpdateWithWhereUniqueWithoutSales_representativeInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutSales_representativeInput | DepartureUpdateManyWithWhereWithoutSales_representativeInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput> | ArrivalCreateWithoutCreated_byInput[] | ArrivalUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutCreated_byInput | ArrivalCreateOrConnectWithoutCreated_byInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutCreated_byInput | ArrivalUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: ArrivalCreateManyCreated_byInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutCreated_byInput | ArrivalUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutCreated_byInput | ArrivalUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type HoldUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput> | HoldCreateWithoutCreated_byInput[] | HoldUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_byInput | HoldCreateOrConnectWithoutCreated_byInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCreated_byInput | HoldUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: HoldCreateManyCreated_byInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCreated_byInput | HoldUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCreated_byInput | HoldUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type HoldUncheckedUpdateManyWithoutCreated_forNestedInput = {
    create?: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput> | HoldCreateWithoutCreated_forInput[] | HoldUncheckedCreateWithoutCreated_forInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCreated_forInput | HoldCreateOrConnectWithoutCreated_forInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCreated_forInput | HoldUpsertWithWhereUniqueWithoutCreated_forInput[]
    createMany?: HoldCreateManyCreated_forInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCreated_forInput | HoldUpdateWithWhereUniqueWithoutCreated_forInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCreated_forInput | HoldUpdateManyWithWhereWithoutCreated_forInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput = {
    create?: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput> | InvoiceCreateWithoutUpdated_byInput[] | InvoiceUncheckedCreateWithoutUpdated_byInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdated_byInput | InvoiceCreateOrConnectWithoutUpdated_byInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUpdated_byInput | InvoiceUpsertWithWhereUniqueWithoutUpdated_byInput[]
    createMany?: InvoiceCreateManyUpdated_byInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUpdated_byInput | InvoiceUpdateWithWhereUniqueWithoutUpdated_byInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUpdated_byInput | InvoiceUpdateManyWithWhereWithoutUpdated_byInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUploaded_byNestedInput = {
    create?: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput> | FileCreateWithoutUploaded_byInput[] | FileUncheckedCreateWithoutUploaded_byInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaded_byInput | FileCreateOrConnectWithoutUploaded_byInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaded_byInput | FileUpsertWithWhereUniqueWithoutUploaded_byInput[]
    createMany?: FileCreateManyUploaded_byInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaded_byInput | FileUpdateWithWhereUniqueWithoutUploaded_byInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaded_byInput | FileUpdateManyWithWhereWithoutUploaded_byInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput> | CommentCreateWithoutCreated_byInput[] | CommentUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreated_byInput | CommentCreateOrConnectWithoutCreated_byInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCreated_byInput | CommentUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: CommentCreateManyCreated_byInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCreated_byInput | CommentUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCreated_byInput | CommentUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput> | AssetHistoryCreateWithoutUserInput[] | AssetHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUserInput | AssetHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssetHistoryCreateManyUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUserInput | AssetHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput> | AssetPartCreateWithoutUpdatedByInput[] | AssetPartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AssetPartCreateOrConnectWithoutUpdatedByInput | AssetPartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: AssetPartUpsertWithWhereUniqueWithoutUpdatedByInput | AssetPartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: AssetPartCreateManyUpdatedByInputEnvelope
    set?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    disconnect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    delete?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    connect?: AssetPartWhereUniqueInput | AssetPartWhereUniqueInput[]
    update?: AssetPartUpdateWithWhereUniqueWithoutUpdatedByInput | AssetPartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: AssetPartUpdateManyWithWhereWithoutUpdatedByInput | AssetPartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ArrivalCreateNestedManyWithoutOriginInput = {
    create?: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput> | ArrivalCreateWithoutOriginInput[] | ArrivalUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutOriginInput | ArrivalCreateOrConnectWithoutOriginInput[]
    createMany?: ArrivalCreateManyOriginInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type ArrivalCreateNestedManyWithoutTransporterInput = {
    create?: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput> | ArrivalCreateWithoutTransporterInput[] | ArrivalUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutTransporterInput | ArrivalCreateOrConnectWithoutTransporterInput[]
    createMany?: ArrivalCreateManyTransporterInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type DepartureCreateNestedManyWithoutDestinationInput = {
    create?: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput> | DepartureCreateWithoutDestinationInput[] | DepartureUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutDestinationInput | DepartureCreateOrConnectWithoutDestinationInput[]
    createMany?: DepartureCreateManyDestinationInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type DepartureCreateNestedManyWithoutTransporterInput = {
    create?: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput> | DepartureCreateWithoutTransporterInput[] | DepartureUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutTransporterInput | DepartureCreateOrConnectWithoutTransporterInput[]
    createMany?: DepartureCreateManyTransporterInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type HoldCreateNestedManyWithoutCustomerInput = {
    create?: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput> | HoldCreateWithoutCustomerInput[] | HoldUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCustomerInput | HoldCreateOrConnectWithoutCustomerInput[]
    createMany?: HoldCreateManyCustomerInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutTransporterInput = {
    create?: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput> | TransferCreateWithoutTransporterInput[] | TransferUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTransporterInput | TransferCreateOrConnectWithoutTransporterInput[]
    createMany?: TransferCreateManyTransporterInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ArrivalUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput> | ArrivalCreateWithoutOriginInput[] | ArrivalUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutOriginInput | ArrivalCreateOrConnectWithoutOriginInput[]
    createMany?: ArrivalCreateManyOriginInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type ArrivalUncheckedCreateNestedManyWithoutTransporterInput = {
    create?: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput> | ArrivalCreateWithoutTransporterInput[] | ArrivalUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutTransporterInput | ArrivalCreateOrConnectWithoutTransporterInput[]
    createMany?: ArrivalCreateManyTransporterInputEnvelope
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
  }

  export type DepartureUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput> | DepartureCreateWithoutDestinationInput[] | DepartureUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutDestinationInput | DepartureCreateOrConnectWithoutDestinationInput[]
    createMany?: DepartureCreateManyDestinationInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type DepartureUncheckedCreateNestedManyWithoutTransporterInput = {
    create?: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput> | DepartureCreateWithoutTransporterInput[] | DepartureUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutTransporterInput | DepartureCreateOrConnectWithoutTransporterInput[]
    createMany?: DepartureCreateManyTransporterInputEnvelope
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
  }

  export type HoldUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput> | HoldCreateWithoutCustomerInput[] | HoldUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCustomerInput | HoldCreateOrConnectWithoutCustomerInput[]
    createMany?: HoldCreateManyCustomerInputEnvelope
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutTransporterInput = {
    create?: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput> | TransferCreateWithoutTransporterInput[] | TransferUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTransporterInput | TransferCreateOrConnectWithoutTransporterInput[]
    createMany?: TransferCreateManyTransporterInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InvoiceUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrganizationInput | InvoiceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrganizationInput | InvoiceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrganizationInput | InvoiceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ArrivalUpdateManyWithoutOriginNestedInput = {
    create?: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput> | ArrivalCreateWithoutOriginInput[] | ArrivalUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutOriginInput | ArrivalCreateOrConnectWithoutOriginInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutOriginInput | ArrivalUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: ArrivalCreateManyOriginInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutOriginInput | ArrivalUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutOriginInput | ArrivalUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type ArrivalUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput> | ArrivalCreateWithoutTransporterInput[] | ArrivalUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutTransporterInput | ArrivalCreateOrConnectWithoutTransporterInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutTransporterInput | ArrivalUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: ArrivalCreateManyTransporterInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutTransporterInput | ArrivalUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutTransporterInput | ArrivalUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type DepartureUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput> | DepartureCreateWithoutDestinationInput[] | DepartureUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutDestinationInput | DepartureCreateOrConnectWithoutDestinationInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutDestinationInput | DepartureUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: DepartureCreateManyDestinationInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutDestinationInput | DepartureUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutDestinationInput | DepartureUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type DepartureUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput> | DepartureCreateWithoutTransporterInput[] | DepartureUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutTransporterInput | DepartureCreateOrConnectWithoutTransporterInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutTransporterInput | DepartureUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: DepartureCreateManyTransporterInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutTransporterInput | DepartureUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutTransporterInput | DepartureUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type HoldUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput> | HoldCreateWithoutCustomerInput[] | HoldUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCustomerInput | HoldCreateOrConnectWithoutCustomerInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCustomerInput | HoldUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: HoldCreateManyCustomerInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCustomerInput | HoldUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCustomerInput | HoldUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput> | TransferCreateWithoutTransporterInput[] | TransferUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTransporterInput | TransferCreateOrConnectWithoutTransporterInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTransporterInput | TransferUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: TransferCreateManyTransporterInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTransporterInput | TransferUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTransporterInput | TransferUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrganizationInput | InvoiceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrganizationInput | InvoiceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrganizationInput | InvoiceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ArrivalUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput> | ArrivalCreateWithoutOriginInput[] | ArrivalUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutOriginInput | ArrivalCreateOrConnectWithoutOriginInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutOriginInput | ArrivalUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: ArrivalCreateManyOriginInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutOriginInput | ArrivalUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutOriginInput | ArrivalUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type ArrivalUncheckedUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput> | ArrivalCreateWithoutTransporterInput[] | ArrivalUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: ArrivalCreateOrConnectWithoutTransporterInput | ArrivalCreateOrConnectWithoutTransporterInput[]
    upsert?: ArrivalUpsertWithWhereUniqueWithoutTransporterInput | ArrivalUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: ArrivalCreateManyTransporterInputEnvelope
    set?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    disconnect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    delete?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    connect?: ArrivalWhereUniqueInput | ArrivalWhereUniqueInput[]
    update?: ArrivalUpdateWithWhereUniqueWithoutTransporterInput | ArrivalUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: ArrivalUpdateManyWithWhereWithoutTransporterInput | ArrivalUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
  }

  export type DepartureUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput> | DepartureCreateWithoutDestinationInput[] | DepartureUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutDestinationInput | DepartureCreateOrConnectWithoutDestinationInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutDestinationInput | DepartureUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: DepartureCreateManyDestinationInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutDestinationInput | DepartureUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutDestinationInput | DepartureUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type DepartureUncheckedUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput> | DepartureCreateWithoutTransporterInput[] | DepartureUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: DepartureCreateOrConnectWithoutTransporterInput | DepartureCreateOrConnectWithoutTransporterInput[]
    upsert?: DepartureUpsertWithWhereUniqueWithoutTransporterInput | DepartureUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: DepartureCreateManyTransporterInputEnvelope
    set?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    disconnect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    delete?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    connect?: DepartureWhereUniqueInput | DepartureWhereUniqueInput[]
    update?: DepartureUpdateWithWhereUniqueWithoutTransporterInput | DepartureUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: DepartureUpdateManyWithWhereWithoutTransporterInput | DepartureUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
  }

  export type HoldUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput> | HoldCreateWithoutCustomerInput[] | HoldUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: HoldCreateOrConnectWithoutCustomerInput | HoldCreateOrConnectWithoutCustomerInput[]
    upsert?: HoldUpsertWithWhereUniqueWithoutCustomerInput | HoldUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: HoldCreateManyCustomerInputEnvelope
    set?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    disconnect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    delete?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    connect?: HoldWhereUniqueInput | HoldWhereUniqueInput[]
    update?: HoldUpdateWithWhereUniqueWithoutCustomerInput | HoldUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: HoldUpdateManyWithWhereWithoutCustomerInput | HoldUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: HoldScalarWhereInput | HoldScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutTransporterNestedInput = {
    create?: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput> | TransferCreateWithoutTransporterInput[] | TransferUncheckedCreateWithoutTransporterInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTransporterInput | TransferCreateOrConnectWithoutTransporterInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTransporterInput | TransferUpsertWithWhereUniqueWithoutTransporterInput[]
    createMany?: TransferCreateManyTransporterInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTransporterInput | TransferUpdateWithWhereUniqueWithoutTransporterInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTransporterInput | TransferUpdateManyWithWhereWithoutTransporterInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAsset_historyInput = {
    create?: XOR<AssetCreateWithoutAsset_historyInput, AssetUncheckedCreateWithoutAsset_historyInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_historyInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAsset_historyInput = {
    create?: XOR<UserCreateWithoutAsset_historyInput, UserUncheckedCreateWithoutAsset_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_historyInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGeneralOperationFieldUpdateOperationsInput = {
    set?: $Enums.GeneralOperation
  }

  export type EnumDataFieldFieldUpdateOperationsInput = {
    set?: $Enums.DataField
  }

  export type AssetUpdateOneRequiredWithoutAsset_historyNestedInput = {
    create?: XOR<AssetCreateWithoutAsset_historyInput, AssetUncheckedCreateWithoutAsset_historyInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAsset_historyInput
    upsert?: AssetUpsertWithoutAsset_historyInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAsset_historyInput, AssetUpdateWithoutAsset_historyInput>, AssetUncheckedUpdateWithoutAsset_historyInput>
  }

  export type UserUpdateOneRequiredWithoutAsset_historyNestedInput = {
    create?: XOR<UserCreateWithoutAsset_historyInput, UserUncheckedCreateWithoutAsset_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutAsset_historyInput
    upsert?: UserUpsertWithoutAsset_historyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAsset_historyInput, UserUpdateWithoutAsset_historyInput>, UserUncheckedUpdateWithoutAsset_historyInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type NestedEnumTrackingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingStatus | EnumTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingStatusFilter<$PrismaModel> | $Enums.TrackingStatus
  }

  export type NestedEnumExitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExitStatus | EnumExitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExitStatusFilter<$PrismaModel> | $Enums.ExitStatus
  }

  export type NestedEnumTechnicalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicalStatus | EnumTechnicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicalStatusFilter<$PrismaModel> | $Enums.TechnicalStatus
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrackingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackingStatus | EnumTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackingStatus[] | ListEnumTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrackingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrackingStatusFilter<$PrismaModel>
  }

  export type NestedEnumExitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExitStatus | EnumExitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExitStatus[] | ListEnumExitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExitStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExitStatusFilter<$PrismaModel>
    _max?: NestedEnumExitStatusFilter<$PrismaModel>
  }

  export type NestedEnumTechnicalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicalStatus | EnumTechnicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicalStatus[] | ListEnumTechnicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicalStatusWithAggregatesFilter<$PrismaModel> | $Enums.TechnicalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnicalStatusFilter<$PrismaModel>
    _max?: NestedEnumTechnicalStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccessoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Accessory | EnumAccessoryFieldRefInput<$PrismaModel>
    in?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessoryFilter<$PrismaModel> | $Enums.Accessory
  }

  export type NestedEnumAccessoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Accessory | EnumAccessoryFieldRefInput<$PrismaModel>
    in?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Accessory[] | ListEnumAccessoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessoryWithAggregatesFilter<$PrismaModel> | $Enums.Accessory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessoryFilter<$PrismaModel>
    _max?: NestedEnumAccessoryFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPartOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.PartOperation | EnumPartOperationFieldRefInput<$PrismaModel>
    in?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumPartOperationFilter<$PrismaModel> | $Enums.PartOperation
  }

  export type NestedEnumPartOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartOperation | EnumPartOperationFieldRefInput<$PrismaModel>
    in?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartOperation[] | ListEnumPartOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumPartOperationWithAggregatesFilter<$PrismaModel> | $Enums.PartOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartOperationFilter<$PrismaModel>
    _max?: NestedEnumPartOperationFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumGeneralOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneralOperation | EnumGeneralOperationFieldRefInput<$PrismaModel>
    in?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumGeneralOperationFilter<$PrismaModel> | $Enums.GeneralOperation
  }

  export type NestedEnumDataFieldFilter<$PrismaModel = never> = {
    equals?: $Enums.DataField | EnumDataFieldFieldRefInput<$PrismaModel>
    in?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumDataFieldFilter<$PrismaModel> | $Enums.DataField
  }

  export type NestedEnumGeneralOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneralOperation | EnumGeneralOperationFieldRefInput<$PrismaModel>
    in?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.GeneralOperation[] | ListEnumGeneralOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumGeneralOperationWithAggregatesFilter<$PrismaModel> | $Enums.GeneralOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGeneralOperationFilter<$PrismaModel>
    _max?: NestedEnumGeneralOperationFilter<$PrismaModel>
  }

  export type NestedEnumDataFieldWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataField | EnumDataFieldFieldRefInput<$PrismaModel>
    in?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataField[] | ListEnumDataFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumDataFieldWithAggregatesFilter<$PrismaModel> | $Enums.DataField
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataFieldFilter<$PrismaModel>
    _max?: NestedEnumDataFieldFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CostCreateWithoutAssetInput = {
    purchase_cost?: Decimal | DecimalJsLike | number | string | null
    transport_cost?: Decimal | DecimalJsLike | number | string | null
    processing_cost?: Decimal | DecimalJsLike | number | string | null
    other_cost?: Decimal | DecimalJsLike | number | string | null
    parts_cost?: Decimal | DecimalJsLike | number | string | null
    total_cost?: Decimal | DecimalJsLike | number | string | null
    sale_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type CostUncheckedCreateWithoutAssetInput = {
    id?: number
    purchase_cost?: Decimal | DecimalJsLike | number | string | null
    transport_cost?: Decimal | DecimalJsLike | number | string | null
    processing_cost?: Decimal | DecimalJsLike | number | string | null
    other_cost?: Decimal | DecimalJsLike | number | string | null
    parts_cost?: Decimal | DecimalJsLike | number | string | null
    total_cost?: Decimal | DecimalJsLike | number | string | null
    sale_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type CostCreateOrConnectWithoutAssetInput = {
    where: CostWhereUniqueInput
    create: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
  }

  export type TechnicalSpecificationCreateWithoutAssetInput = {
    cassettes?: number | null
    internal_finisher?: string | null
    meter_black?: number | null
    meter_colour?: number | null
    meter_total?: number | null
    drum_life_c?: number | null
    drum_life_m?: number | null
    drum_life_y?: number | null
    drum_life_k?: number | null
  }

  export type TechnicalSpecificationUncheckedCreateWithoutAssetInput = {
    id?: number
    cassettes?: number | null
    internal_finisher?: string | null
    meter_black?: number | null
    meter_colour?: number | null
    meter_total?: number | null
    drum_life_c?: number | null
    drum_life_m?: number | null
    drum_life_y?: number | null
    drum_life_k?: number | null
  }

  export type TechnicalSpecificationCreateOrConnectWithoutAssetInput = {
    where: TechnicalSpecificationWhereUniqueInput
    create: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
  }

  export type BrandCreateWithoutAssetsInput = {
    name: string
    models?: ModelCreateNestedManyWithoutBrandInput
    errorCategories?: ErrorCategoryCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutAssetsInput = {
    id?: number
    name: string
    models?: ModelUncheckedCreateNestedManyWithoutBrandInput
    errorCategories?: ErrorCategoryUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutAssetsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutAssetsInput, BrandUncheckedCreateWithoutAssetsInput>
  }

  export type ModelCreateWithoutAssetsInput = {
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand: BrandCreateNestedOneWithoutModelsInput
  }

  export type ModelUncheckedCreateWithoutAssetsInput = {
    id?: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    brand_id: number
  }

  export type ModelCreateOrConnectWithoutAssetsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutAssetsInput, ModelUncheckedCreateWithoutAssetsInput>
  }

  export type WarehouseCreateWithoutAssetsInput = {
    city_code: string
    street: string
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutAssetsInput = {
    id?: number
    city_code: string
    street: string
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutAssetsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutAssetsInput, WarehouseUncheckedCreateWithoutAssetsInput>
  }

  export type LocationCreateWithoutAssetsInput = {
    location: string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateWithoutAssetsInput = {
    warehouse_id: number
    location: string
  }

  export type LocationCreateOrConnectWithoutAssetsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
  }

  export type InvoiceCreateWithoutPurchase_assetsInput = {
    invoice_number: string
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    organization: OrganizationCreateNestedOneWithoutInvoicesInput
    updated_by: UserCreateNestedOneWithoutInvoices_updatedInput
    sales_assets?: AssetCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPurchase_assetsInput = {
    id?: number
    invoice_number: string
    organization_id: number
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    sales_assets?: AssetUncheckedCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPurchase_assetsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPurchase_assetsInput, InvoiceUncheckedCreateWithoutPurchase_assetsInput>
  }

  export type InvoiceCreateWithoutSales_assetsInput = {
    invoice_number: string
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    organization: OrganizationCreateNestedOneWithoutInvoicesInput
    updated_by: UserCreateNestedOneWithoutInvoices_updatedInput
    purchase_assets?: AssetCreateNestedManyWithoutPurchase_invoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSales_assetsInput = {
    id?: number
    invoice_number: string
    organization_id: number
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    purchase_assets?: AssetUncheckedCreateNestedManyWithoutPurchase_invoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSales_assetsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSales_assetsInput, InvoiceUncheckedCreateWithoutSales_assetsInput>
  }

  export type ArrivalCreateWithoutAssetsInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    origin: OrganizationCreateNestedOneWithoutArrivals_originInput
    destination: WarehouseCreateNestedOneWithoutArrivalsInput
    transporter: OrganizationCreateNestedOneWithoutArrivals_transporterInput
    created_by: UserCreateNestedOneWithoutArrivalsInput
  }

  export type ArrivalUncheckedCreateWithoutAssetsInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type ArrivalCreateOrConnectWithoutAssetsInput = {
    where: ArrivalWhereUniqueInput
    create: XOR<ArrivalCreateWithoutAssetsInput, ArrivalUncheckedCreateWithoutAssetsInput>
  }

  export type DepartureCreateWithoutAssetsInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
  }

  export type DepartureUncheckedCreateWithoutAssetsInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateOrConnectWithoutAssetsInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutAssetsInput, DepartureUncheckedCreateWithoutAssetsInput>
  }

  export type HoldCreateWithoutAssetsInput = {
    hold_number: string
    notes?: string | null
    created_at: Date | string
    created_by: UserCreateNestedOneWithoutHolds_createdInput
    created_for: UserCreateNestedOneWithoutHolds_forInput
    customer: OrganizationCreateNestedOneWithoutHoldsInput
  }

  export type HoldUncheckedCreateWithoutAssetsInput = {
    id?: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type HoldCreateOrConnectWithoutAssetsInput = {
    where: HoldWhereUniqueInput
    create: XOR<HoldCreateWithoutAssetsInput, HoldUncheckedCreateWithoutAssetsInput>
  }

  export type AssetAccessoryCreateWithoutAssetInput = {
    accessory: $Enums.Accessory
  }

  export type AssetAccessoryUncheckedCreateWithoutAssetInput = {
    accessory: $Enums.Accessory
  }

  export type AssetAccessoryCreateOrConnectWithoutAssetInput = {
    where: AssetAccessoryWhereUniqueInput
    create: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetAccessoryCreateManyAssetInputEnvelope = {
    data: AssetAccessoryCreateManyAssetInput | AssetAccessoryCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetErrorCreateWithoutAssetInput = {
    is_fixed: boolean
    added_at: Date | string
    fixed_at?: Date | string | null
    error: ErrorCreateNestedOneWithoutAsset_errorsInput
    addedBy: UserCreateNestedOneWithoutAsset_errors_addedInput
    fixedBy?: UserCreateNestedOneWithoutAsset_errors_fixedInput
  }

  export type AssetErrorUncheckedCreateWithoutAssetInput = {
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorCreateOrConnectWithoutAssetInput = {
    where: AssetErrorWhereUniqueInput
    create: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput>
  }

  export type AssetErrorCreateManyAssetInputEnvelope = {
    data: AssetErrorCreateManyAssetInput | AssetErrorCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetPartCreateWithoutAssetInput = {
    updated_at: Date | string
    part_operation: $Enums.PartOperation
    part: PartCreateNestedOneWithoutAsset_partsInput
    updatedBy: UserCreateNestedOneWithoutAsset_partsInput
  }

  export type AssetPartUncheckedCreateWithoutAssetInput = {
    part_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetPartCreateOrConnectWithoutAssetInput = {
    where: AssetPartWhereUniqueInput
    create: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput>
  }

  export type AssetPartCreateManyAssetInputEnvelope = {
    data: AssetPartCreateManyAssetInput | AssetPartCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetTransferCreateWithoutAssetInput = {
    transfer: TransferCreateNestedOneWithoutAsset_transfersInput
  }

  export type AssetTransferUncheckedCreateWithoutAssetInput = {
    transfer_id: number
  }

  export type AssetTransferCreateOrConnectWithoutAssetInput = {
    where: AssetTransferWhereUniqueInput
    create: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput>
  }

  export type AssetTransferCreateManyAssetInputEnvelope = {
    data: AssetTransferCreateManyAssetInput | AssetTransferCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutAssetInput = {
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
    uploaded_by: UserCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutAssetInput = {
    id?: number
    uploaded_by_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type FileCreateOrConnectWithoutAssetInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput>
  }

  export type FileCreateManyAssetInputEnvelope = {
    data: FileCreateManyAssetInput | FileCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAssetInput = {
    comment: string
    created_at: Date | string
    updated_at: Date | string
    created_by: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAssetInput = {
    id?: number
    created_by_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type CommentCreateOrConnectWithoutAssetInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput>
  }

  export type CommentCreateManyAssetInputEnvelope = {
    data: CommentCreateManyAssetInput | CommentCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetHistoryCreateWithoutAssetInput = {
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAsset_historyInput
  }

  export type AssetHistoryUncheckedCreateWithoutAssetInput = {
    id?: number
    user_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryCreateOrConnectWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    create: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetHistoryCreateManyAssetInputEnvelope = {
    data: AssetHistoryCreateManyAssetInput | AssetHistoryCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type CostUpsertWithoutAssetInput = {
    update: XOR<CostUpdateWithoutAssetInput, CostUncheckedUpdateWithoutAssetInput>
    create: XOR<CostCreateWithoutAssetInput, CostUncheckedCreateWithoutAssetInput>
    where?: CostWhereInput
  }

  export type CostUpdateToOneWithWhereWithoutAssetInput = {
    where?: CostWhereInput
    data: XOR<CostUpdateWithoutAssetInput, CostUncheckedUpdateWithoutAssetInput>
  }

  export type CostUpdateWithoutAssetInput = {
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CostUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchase_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transport_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    other_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parts_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TechnicalSpecificationUpsertWithoutAssetInput = {
    update: XOR<TechnicalSpecificationUpdateWithoutAssetInput, TechnicalSpecificationUncheckedUpdateWithoutAssetInput>
    create: XOR<TechnicalSpecificationCreateWithoutAssetInput, TechnicalSpecificationUncheckedCreateWithoutAssetInput>
    where?: TechnicalSpecificationWhereInput
  }

  export type TechnicalSpecificationUpdateToOneWithWhereWithoutAssetInput = {
    where?: TechnicalSpecificationWhereInput
    data: XOR<TechnicalSpecificationUpdateWithoutAssetInput, TechnicalSpecificationUncheckedUpdateWithoutAssetInput>
  }

  export type TechnicalSpecificationUpdateWithoutAssetInput = {
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TechnicalSpecificationUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    cassettes?: NullableIntFieldUpdateOperationsInput | number | null
    internal_finisher?: NullableStringFieldUpdateOperationsInput | string | null
    meter_black?: NullableIntFieldUpdateOperationsInput | number | null
    meter_colour?: NullableIntFieldUpdateOperationsInput | number | null
    meter_total?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_c?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_m?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_y?: NullableIntFieldUpdateOperationsInput | number | null
    drum_life_k?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandUpsertWithoutAssetsInput = {
    update: XOR<BrandUpdateWithoutAssetsInput, BrandUncheckedUpdateWithoutAssetsInput>
    create: XOR<BrandCreateWithoutAssetsInput, BrandUncheckedCreateWithoutAssetsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutAssetsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutAssetsInput, BrandUncheckedUpdateWithoutAssetsInput>
  }

  export type BrandUpdateWithoutAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUpdateManyWithoutBrandNestedInput
    errorCategories?: ErrorCategoryUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUncheckedUpdateManyWithoutBrandNestedInput
    errorCategories?: ErrorCategoryUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ModelUpsertWithoutAssetsInput = {
    update: XOR<ModelUpdateWithoutAssetsInput, ModelUncheckedUpdateWithoutAssetsInput>
    create: XOR<ModelCreateWithoutAssetsInput, ModelUncheckedCreateWithoutAssetsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutAssetsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutAssetsInput, ModelUncheckedUpdateWithoutAssetsInput>
  }

  export type ModelUpdateWithoutAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    brand?: BrandUpdateOneRequiredWithoutModelsNestedInput
  }

  export type ModelUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseUpsertWithoutAssetsInput = {
    update: XOR<WarehouseUpdateWithoutAssetsInput, WarehouseUncheckedUpdateWithoutAssetsInput>
    create: XOR<WarehouseCreateWithoutAssetsInput, WarehouseUncheckedCreateWithoutAssetsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutAssetsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutAssetsInput, WarehouseUncheckedUpdateWithoutAssetsInput>
  }

  export type WarehouseUpdateWithoutAssetsInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type LocationUpsertWithoutAssetsInput = {
    update: XOR<LocationUpdateWithoutAssetsInput, LocationUncheckedUpdateWithoutAssetsInput>
    create: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAssetsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAssetsInput, LocationUncheckedUpdateWithoutAssetsInput>
  }

  export type LocationUpdateWithoutAssetsInput = {
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateWithoutAssetsInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpsertWithoutPurchase_assetsInput = {
    update: XOR<InvoiceUpdateWithoutPurchase_assetsInput, InvoiceUncheckedUpdateWithoutPurchase_assetsInput>
    create: XOR<InvoiceCreateWithoutPurchase_assetsInput, InvoiceUncheckedCreateWithoutPurchase_assetsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPurchase_assetsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPurchase_assetsInput, InvoiceUncheckedUpdateWithoutPurchase_assetsInput>
  }

  export type InvoiceUpdateWithoutPurchase_assetsInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    organization?: OrganizationUpdateOneRequiredWithoutInvoicesNestedInput
    updated_by?: UserUpdateOneRequiredWithoutInvoices_updatedNestedInput
    sales_assets?: AssetUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPurchase_assetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    sales_assets?: AssetUncheckedUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUpsertWithoutSales_assetsInput = {
    update: XOR<InvoiceUpdateWithoutSales_assetsInput, InvoiceUncheckedUpdateWithoutSales_assetsInput>
    create: XOR<InvoiceCreateWithoutSales_assetsInput, InvoiceUncheckedCreateWithoutSales_assetsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutSales_assetsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutSales_assetsInput, InvoiceUncheckedUpdateWithoutSales_assetsInput>
  }

  export type InvoiceUpdateWithoutSales_assetsInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    organization?: OrganizationUpdateOneRequiredWithoutInvoicesNestedInput
    updated_by?: UserUpdateOneRequiredWithoutInvoices_updatedNestedInput
    purchase_assets?: AssetUpdateManyWithoutPurchase_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSales_assetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    purchase_assets?: AssetUncheckedUpdateManyWithoutPurchase_invoiceNestedInput
  }

  export type ArrivalUpsertWithoutAssetsInput = {
    update: XOR<ArrivalUpdateWithoutAssetsInput, ArrivalUncheckedUpdateWithoutAssetsInput>
    create: XOR<ArrivalCreateWithoutAssetsInput, ArrivalUncheckedCreateWithoutAssetsInput>
    where?: ArrivalWhereInput
  }

  export type ArrivalUpdateToOneWithWhereWithoutAssetsInput = {
    where?: ArrivalWhereInput
    data: XOR<ArrivalUpdateWithoutAssetsInput, ArrivalUncheckedUpdateWithoutAssetsInput>
  }

  export type ArrivalUpdateWithoutAssetsInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutArrivalsNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutArrivalsNestedInput
  }

  export type ArrivalUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpsertWithoutAssetsInput = {
    update: XOR<DepartureUpdateWithoutAssetsInput, DepartureUncheckedUpdateWithoutAssetsInput>
    create: XOR<DepartureCreateWithoutAssetsInput, DepartureUncheckedCreateWithoutAssetsInput>
    where?: DepartureWhereInput
  }

  export type DepartureUpdateToOneWithWhereWithoutAssetsInput = {
    where?: DepartureWhereInput
    data: XOR<DepartureUpdateWithoutAssetsInput, DepartureUncheckedUpdateWithoutAssetsInput>
  }

  export type DepartureUpdateWithoutAssetsInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
  }

  export type DepartureUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldUpsertWithoutAssetsInput = {
    update: XOR<HoldUpdateWithoutAssetsInput, HoldUncheckedUpdateWithoutAssetsInput>
    create: XOR<HoldCreateWithoutAssetsInput, HoldUncheckedCreateWithoutAssetsInput>
    where?: HoldWhereInput
  }

  export type HoldUpdateToOneWithWhereWithoutAssetsInput = {
    where?: HoldWhereInput
    data: XOR<HoldUpdateWithoutAssetsInput, HoldUncheckedUpdateWithoutAssetsInput>
  }

  export type HoldUpdateWithoutAssetsInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutHolds_createdNestedInput
    created_for?: UserUpdateOneRequiredWithoutHolds_forNestedInput
    customer?: OrganizationUpdateOneRequiredWithoutHoldsNestedInput
  }

  export type HoldUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    created_for_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAccessoryUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetAccessoryWhereUniqueInput
    update: XOR<AssetAccessoryUpdateWithoutAssetInput, AssetAccessoryUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetAccessoryCreateWithoutAssetInput, AssetAccessoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetAccessoryUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetAccessoryWhereUniqueInput
    data: XOR<AssetAccessoryUpdateWithoutAssetInput, AssetAccessoryUncheckedUpdateWithoutAssetInput>
  }

  export type AssetAccessoryUpdateManyWithWhereWithoutAssetInput = {
    where: AssetAccessoryScalarWhereInput
    data: XOR<AssetAccessoryUpdateManyMutationInput, AssetAccessoryUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetAccessoryScalarWhereInput = {
    AND?: AssetAccessoryScalarWhereInput | AssetAccessoryScalarWhereInput[]
    OR?: AssetAccessoryScalarWhereInput[]
    NOT?: AssetAccessoryScalarWhereInput | AssetAccessoryScalarWhereInput[]
    asset_id?: IntFilter<"AssetAccessory"> | number
    accessory?: EnumAccessoryFilter<"AssetAccessory"> | $Enums.Accessory
  }

  export type AssetErrorUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetErrorWhereUniqueInput
    update: XOR<AssetErrorUpdateWithoutAssetInput, AssetErrorUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetErrorCreateWithoutAssetInput, AssetErrorUncheckedCreateWithoutAssetInput>
  }

  export type AssetErrorUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetErrorWhereUniqueInput
    data: XOR<AssetErrorUpdateWithoutAssetInput, AssetErrorUncheckedUpdateWithoutAssetInput>
  }

  export type AssetErrorUpdateManyWithWhereWithoutAssetInput = {
    where: AssetErrorScalarWhereInput
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetErrorScalarWhereInput = {
    AND?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
    OR?: AssetErrorScalarWhereInput[]
    NOT?: AssetErrorScalarWhereInput | AssetErrorScalarWhereInput[]
    asset_id?: IntFilter<"AssetError"> | number
    error_id?: IntFilter<"AssetError"> | number
    is_fixed?: BoolFilter<"AssetError"> | boolean
    added_by?: IntFilter<"AssetError"> | number
    added_at?: DateTimeFilter<"AssetError"> | Date | string
    fixed_by?: IntNullableFilter<"AssetError"> | number | null
    fixed_at?: DateTimeNullableFilter<"AssetError"> | Date | string | null
  }

  export type AssetPartUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetPartWhereUniqueInput
    update: XOR<AssetPartUpdateWithoutAssetInput, AssetPartUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetPartCreateWithoutAssetInput, AssetPartUncheckedCreateWithoutAssetInput>
  }

  export type AssetPartUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetPartWhereUniqueInput
    data: XOR<AssetPartUpdateWithoutAssetInput, AssetPartUncheckedUpdateWithoutAssetInput>
  }

  export type AssetPartUpdateManyWithWhereWithoutAssetInput = {
    where: AssetPartScalarWhereInput
    data: XOR<AssetPartUpdateManyMutationInput, AssetPartUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetPartScalarWhereInput = {
    AND?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
    OR?: AssetPartScalarWhereInput[]
    NOT?: AssetPartScalarWhereInput | AssetPartScalarWhereInput[]
    asset_id?: IntFilter<"AssetPart"> | number
    part_id?: IntFilter<"AssetPart"> | number
    updated_at?: DateTimeFilter<"AssetPart"> | Date | string
    updated_by?: IntFilter<"AssetPart"> | number
    part_operation?: EnumPartOperationFilter<"AssetPart"> | $Enums.PartOperation
  }

  export type AssetTransferUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetTransferWhereUniqueInput
    update: XOR<AssetTransferUpdateWithoutAssetInput, AssetTransferUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetTransferCreateWithoutAssetInput, AssetTransferUncheckedCreateWithoutAssetInput>
  }

  export type AssetTransferUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetTransferWhereUniqueInput
    data: XOR<AssetTransferUpdateWithoutAssetInput, AssetTransferUncheckedUpdateWithoutAssetInput>
  }

  export type AssetTransferUpdateManyWithWhereWithoutAssetInput = {
    where: AssetTransferScalarWhereInput
    data: XOR<AssetTransferUpdateManyMutationInput, AssetTransferUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetTransferScalarWhereInput = {
    AND?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
    OR?: AssetTransferScalarWhereInput[]
    NOT?: AssetTransferScalarWhereInput | AssetTransferScalarWhereInput[]
    asset_id?: IntFilter<"AssetTransfer"> | number
    transfer_id?: IntFilter<"AssetTransfer"> | number
  }

  export type FileUpsertWithWhereUniqueWithoutAssetInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutAssetInput, FileUncheckedUpdateWithoutAssetInput>
    create: XOR<FileCreateWithoutAssetInput, FileUncheckedCreateWithoutAssetInput>
  }

  export type FileUpdateWithWhereUniqueWithoutAssetInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutAssetInput, FileUncheckedUpdateWithoutAssetInput>
  }

  export type FileUpdateManyWithWhereWithoutAssetInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutAssetInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: IntFilter<"File"> | number
    asset_id?: IntFilter<"File"> | number
    uploaded_by_id?: IntFilter<"File"> | number
    name?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    data?: BytesFilter<"File"> | Uint8Array
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    uploaded_at?: DateTimeFilter<"File"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAssetInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAssetInput, CommentUncheckedUpdateWithoutAssetInput>
    create: XOR<CommentCreateWithoutAssetInput, CommentUncheckedCreateWithoutAssetInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAssetInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAssetInput, CommentUncheckedUpdateWithoutAssetInput>
  }

  export type CommentUpdateManyWithWhereWithoutAssetInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAssetInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    asset_id?: IntFilter<"Comment"> | number
    created_by_id?: IntFilter<"Comment"> | number
    comment?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
  }

  export type AssetHistoryUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    update: XOR<AssetHistoryUpdateWithoutAssetInput, AssetHistoryUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetHistoryUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    data: XOR<AssetHistoryUpdateWithoutAssetInput, AssetHistoryUncheckedUpdateWithoutAssetInput>
  }

  export type AssetHistoryUpdateManyWithWhereWithoutAssetInput = {
    where: AssetHistoryScalarWhereInput
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetHistoryScalarWhereInput = {
    AND?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
    OR?: AssetHistoryScalarWhereInput[]
    NOT?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
    id?: IntFilter<"AssetHistory"> | number
    asset_id?: IntFilter<"AssetHistory"> | number
    user_id?: IntFilter<"AssetHistory"> | number
    operation?: EnumGeneralOperationFilter<"AssetHistory"> | $Enums.GeneralOperation
    data_field?: EnumDataFieldFilter<"AssetHistory"> | $Enums.DataField
    changed_on?: DateTimeFilter<"AssetHistory"> | Date | string
    changes?: JsonFilter<"AssetHistory">
  }

  export type AssetCreateWithoutTechnical_specificationInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutTechnical_specificationInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutTechnical_specificationInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutTechnical_specificationInput, AssetUncheckedCreateWithoutTechnical_specificationInput>
  }

  export type AssetUpsertWithoutTechnical_specificationInput = {
    update: XOR<AssetUpdateWithoutTechnical_specificationInput, AssetUncheckedUpdateWithoutTechnical_specificationInput>
    create: XOR<AssetCreateWithoutTechnical_specificationInput, AssetUncheckedCreateWithoutTechnical_specificationInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutTechnical_specificationInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutTechnical_specificationInput, AssetUncheckedUpdateWithoutTechnical_specificationInput>
  }

  export type AssetUpdateWithoutTechnical_specificationInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutTechnical_specificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateWithoutCostInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutCostInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutCostInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCostInput, AssetUncheckedCreateWithoutCostInput>
  }

  export type AssetUpsertWithoutCostInput = {
    update: XOR<AssetUpdateWithoutCostInput, AssetUncheckedUpdateWithoutCostInput>
    create: XOR<AssetCreateWithoutCostInput, AssetUncheckedCreateWithoutCostInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutCostInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutCostInput, AssetUncheckedUpdateWithoutCostInput>
  }

  export type AssetUpdateWithoutCostInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutCostInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateWithoutAsset_accessoriesInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAsset_accessoriesInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAsset_accessoriesInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAsset_accessoriesInput, AssetUncheckedCreateWithoutAsset_accessoriesInput>
  }

  export type AssetUpsertWithoutAsset_accessoriesInput = {
    update: XOR<AssetUpdateWithoutAsset_accessoriesInput, AssetUncheckedUpdateWithoutAsset_accessoriesInput>
    create: XOR<AssetCreateWithoutAsset_accessoriesInput, AssetUncheckedCreateWithoutAsset_accessoriesInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAsset_accessoriesInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAsset_accessoriesInput, AssetUncheckedUpdateWithoutAsset_accessoriesInput>
  }

  export type AssetUpdateWithoutAsset_accessoriesInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAsset_accessoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type BrandCreateWithoutErrorCategoriesInput = {
    name: string
    models?: ModelCreateNestedManyWithoutBrandInput
    assets?: AssetCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutErrorCategoriesInput = {
    id?: number
    name: string
    models?: ModelUncheckedCreateNestedManyWithoutBrandInput
    assets?: AssetUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutErrorCategoriesInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutErrorCategoriesInput, BrandUncheckedCreateWithoutErrorCategoriesInput>
  }

  export type ErrorCreateWithoutCategoryInput = {
    code: string
    description?: string | null
    asset_errors?: AssetErrorCreateNestedManyWithoutErrorInput
  }

  export type ErrorUncheckedCreateWithoutCategoryInput = {
    id?: number
    code: string
    description?: string | null
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutErrorInput
  }

  export type ErrorCreateOrConnectWithoutCategoryInput = {
    where: ErrorWhereUniqueInput
    create: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput>
  }

  export type ErrorCreateManyCategoryInputEnvelope = {
    data: ErrorCreateManyCategoryInput | ErrorCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutErrorCategoriesInput = {
    update: XOR<BrandUpdateWithoutErrorCategoriesInput, BrandUncheckedUpdateWithoutErrorCategoriesInput>
    create: XOR<BrandCreateWithoutErrorCategoriesInput, BrandUncheckedCreateWithoutErrorCategoriesInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutErrorCategoriesInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutErrorCategoriesInput, BrandUncheckedUpdateWithoutErrorCategoriesInput>
  }

  export type BrandUpdateWithoutErrorCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUpdateManyWithoutBrandNestedInput
    assets?: AssetUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutErrorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUncheckedUpdateManyWithoutBrandNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ErrorUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ErrorWhereUniqueInput
    update: XOR<ErrorUpdateWithoutCategoryInput, ErrorUncheckedUpdateWithoutCategoryInput>
    create: XOR<ErrorCreateWithoutCategoryInput, ErrorUncheckedCreateWithoutCategoryInput>
  }

  export type ErrorUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ErrorWhereUniqueInput
    data: XOR<ErrorUpdateWithoutCategoryInput, ErrorUncheckedUpdateWithoutCategoryInput>
  }

  export type ErrorUpdateManyWithWhereWithoutCategoryInput = {
    where: ErrorScalarWhereInput
    data: XOR<ErrorUpdateManyMutationInput, ErrorUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ErrorScalarWhereInput = {
    AND?: ErrorScalarWhereInput | ErrorScalarWhereInput[]
    OR?: ErrorScalarWhereInput[]
    NOT?: ErrorScalarWhereInput | ErrorScalarWhereInput[]
    id?: IntFilter<"Error"> | number
    error_category_id?: IntFilter<"Error"> | number
    code?: StringFilter<"Error"> | string
    description?: StringNullableFilter<"Error"> | string | null
  }

  export type ErrorCategoryCreateWithoutErrorsInput = {
    category: string
    brand: BrandCreateNestedOneWithoutErrorCategoriesInput
  }

  export type ErrorCategoryUncheckedCreateWithoutErrorsInput = {
    id?: number
    brand_id: number
    category: string
  }

  export type ErrorCategoryCreateOrConnectWithoutErrorsInput = {
    where: ErrorCategoryWhereUniqueInput
    create: XOR<ErrorCategoryCreateWithoutErrorsInput, ErrorCategoryUncheckedCreateWithoutErrorsInput>
  }

  export type AssetErrorCreateWithoutErrorInput = {
    is_fixed: boolean
    added_at: Date | string
    fixed_at?: Date | string | null
    asset: AssetCreateNestedOneWithoutAsset_errorsInput
    addedBy: UserCreateNestedOneWithoutAsset_errors_addedInput
    fixedBy?: UserCreateNestedOneWithoutAsset_errors_fixedInput
  }

  export type AssetErrorUncheckedCreateWithoutErrorInput = {
    asset_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorCreateOrConnectWithoutErrorInput = {
    where: AssetErrorWhereUniqueInput
    create: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput>
  }

  export type AssetErrorCreateManyErrorInputEnvelope = {
    data: AssetErrorCreateManyErrorInput | AssetErrorCreateManyErrorInput[]
    skipDuplicates?: boolean
  }

  export type ErrorCategoryUpsertWithoutErrorsInput = {
    update: XOR<ErrorCategoryUpdateWithoutErrorsInput, ErrorCategoryUncheckedUpdateWithoutErrorsInput>
    create: XOR<ErrorCategoryCreateWithoutErrorsInput, ErrorCategoryUncheckedCreateWithoutErrorsInput>
    where?: ErrorCategoryWhereInput
  }

  export type ErrorCategoryUpdateToOneWithWhereWithoutErrorsInput = {
    where?: ErrorCategoryWhereInput
    data: XOR<ErrorCategoryUpdateWithoutErrorsInput, ErrorCategoryUncheckedUpdateWithoutErrorsInput>
  }

  export type ErrorCategoryUpdateWithoutErrorsInput = {
    category?: StringFieldUpdateOperationsInput | string
    brand?: BrandUpdateOneRequiredWithoutErrorCategoriesNestedInput
  }

  export type ErrorCategoryUncheckedUpdateWithoutErrorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type AssetErrorUpsertWithWhereUniqueWithoutErrorInput = {
    where: AssetErrorWhereUniqueInput
    update: XOR<AssetErrorUpdateWithoutErrorInput, AssetErrorUncheckedUpdateWithoutErrorInput>
    create: XOR<AssetErrorCreateWithoutErrorInput, AssetErrorUncheckedCreateWithoutErrorInput>
  }

  export type AssetErrorUpdateWithWhereUniqueWithoutErrorInput = {
    where: AssetErrorWhereUniqueInput
    data: XOR<AssetErrorUpdateWithoutErrorInput, AssetErrorUncheckedUpdateWithoutErrorInput>
  }

  export type AssetErrorUpdateManyWithWhereWithoutErrorInput = {
    where: AssetErrorScalarWhereInput
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyWithoutErrorInput>
  }

  export type AssetCreateWithoutAsset_errorsInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAsset_errorsInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAsset_errorsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAsset_errorsInput, AssetUncheckedCreateWithoutAsset_errorsInput>
  }

  export type ErrorCreateWithoutAsset_errorsInput = {
    code: string
    description?: string | null
    category: ErrorCategoryCreateNestedOneWithoutErrorsInput
  }

  export type ErrorUncheckedCreateWithoutAsset_errorsInput = {
    id?: number
    error_category_id: number
    code: string
    description?: string | null
  }

  export type ErrorCreateOrConnectWithoutAsset_errorsInput = {
    where: ErrorWhereUniqueInput
    create: XOR<ErrorCreateWithoutAsset_errorsInput, ErrorUncheckedCreateWithoutAsset_errorsInput>
  }

  export type UserCreateWithoutAsset_errors_addedInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAsset_errors_addedInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAsset_errors_addedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAsset_errors_addedInput, UserUncheckedCreateWithoutAsset_errors_addedInput>
  }

  export type UserCreateWithoutAsset_errors_fixedInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAsset_errors_fixedInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAsset_errors_fixedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAsset_errors_fixedInput, UserUncheckedCreateWithoutAsset_errors_fixedInput>
  }

  export type AssetUpsertWithoutAsset_errorsInput = {
    update: XOR<AssetUpdateWithoutAsset_errorsInput, AssetUncheckedUpdateWithoutAsset_errorsInput>
    create: XOR<AssetCreateWithoutAsset_errorsInput, AssetUncheckedCreateWithoutAsset_errorsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAsset_errorsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAsset_errorsInput, AssetUncheckedUpdateWithoutAsset_errorsInput>
  }

  export type AssetUpdateWithoutAsset_errorsInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAsset_errorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type ErrorUpsertWithoutAsset_errorsInput = {
    update: XOR<ErrorUpdateWithoutAsset_errorsInput, ErrorUncheckedUpdateWithoutAsset_errorsInput>
    create: XOR<ErrorCreateWithoutAsset_errorsInput, ErrorUncheckedCreateWithoutAsset_errorsInput>
    where?: ErrorWhereInput
  }

  export type ErrorUpdateToOneWithWhereWithoutAsset_errorsInput = {
    where?: ErrorWhereInput
    data: XOR<ErrorUpdateWithoutAsset_errorsInput, ErrorUncheckedUpdateWithoutAsset_errorsInput>
  }

  export type ErrorUpdateWithoutAsset_errorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: ErrorCategoryUpdateOneRequiredWithoutErrorsNestedInput
  }

  export type ErrorUncheckedUpdateWithoutAsset_errorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    error_category_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutAsset_errors_addedInput = {
    update: XOR<UserUpdateWithoutAsset_errors_addedInput, UserUncheckedUpdateWithoutAsset_errors_addedInput>
    create: XOR<UserCreateWithoutAsset_errors_addedInput, UserUncheckedCreateWithoutAsset_errors_addedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAsset_errors_addedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAsset_errors_addedInput, UserUncheckedUpdateWithoutAsset_errors_addedInput>
  }

  export type UserUpdateWithoutAsset_errors_addedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAsset_errors_addedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutAsset_errors_fixedInput = {
    update: XOR<UserUpdateWithoutAsset_errors_fixedInput, UserUncheckedUpdateWithoutAsset_errors_fixedInput>
    create: XOR<UserCreateWithoutAsset_errors_fixedInput, UserUncheckedCreateWithoutAsset_errors_fixedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAsset_errors_fixedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAsset_errors_fixedInput, UserUncheckedUpdateWithoutAsset_errors_fixedInput>
  }

  export type UserUpdateWithoutAsset_errors_fixedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAsset_errors_fixedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetPartCreateWithoutPartInput = {
    updated_at: Date | string
    part_operation: $Enums.PartOperation
    asset: AssetCreateNestedOneWithoutAsset_partsInput
    updatedBy: UserCreateNestedOneWithoutAsset_partsInput
  }

  export type AssetPartUncheckedCreateWithoutPartInput = {
    asset_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetPartCreateOrConnectWithoutPartInput = {
    where: AssetPartWhereUniqueInput
    create: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput>
  }

  export type AssetPartCreateManyPartInputEnvelope = {
    data: AssetPartCreateManyPartInput | AssetPartCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type AssetPartUpsertWithWhereUniqueWithoutPartInput = {
    where: AssetPartWhereUniqueInput
    update: XOR<AssetPartUpdateWithoutPartInput, AssetPartUncheckedUpdateWithoutPartInput>
    create: XOR<AssetPartCreateWithoutPartInput, AssetPartUncheckedCreateWithoutPartInput>
  }

  export type AssetPartUpdateWithWhereUniqueWithoutPartInput = {
    where: AssetPartWhereUniqueInput
    data: XOR<AssetPartUpdateWithoutPartInput, AssetPartUncheckedUpdateWithoutPartInput>
  }

  export type AssetPartUpdateManyWithWhereWithoutPartInput = {
    where: AssetPartScalarWhereInput
    data: XOR<AssetPartUpdateManyMutationInput, AssetPartUncheckedUpdateManyWithoutPartInput>
  }

  export type AssetCreateWithoutAsset_partsInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAsset_partsInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAsset_partsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAsset_partsInput, AssetUncheckedCreateWithoutAsset_partsInput>
  }

  export type PartCreateWithoutAsset_partsInput = {
    description: string
    part_number: string
    dealer_price: Decimal | DecimalJsLike | number | string
    sale_price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
  }

  export type PartUncheckedCreateWithoutAsset_partsInput = {
    id?: number
    description: string
    part_number: string
    dealer_price: Decimal | DecimalJsLike | number | string
    sale_price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
  }

  export type PartCreateOrConnectWithoutAsset_partsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutAsset_partsInput, PartUncheckedCreateWithoutAsset_partsInput>
  }

  export type UserCreateWithoutAsset_partsInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAsset_partsInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAsset_partsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAsset_partsInput, UserUncheckedCreateWithoutAsset_partsInput>
  }

  export type AssetUpsertWithoutAsset_partsInput = {
    update: XOR<AssetUpdateWithoutAsset_partsInput, AssetUncheckedUpdateWithoutAsset_partsInput>
    create: XOR<AssetCreateWithoutAsset_partsInput, AssetUncheckedCreateWithoutAsset_partsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAsset_partsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAsset_partsInput, AssetUncheckedUpdateWithoutAsset_partsInput>
  }

  export type AssetUpdateWithoutAsset_partsInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAsset_partsInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type PartUpsertWithoutAsset_partsInput = {
    update: XOR<PartUpdateWithoutAsset_partsInput, PartUncheckedUpdateWithoutAsset_partsInput>
    create: XOR<PartCreateWithoutAsset_partsInput, PartUncheckedCreateWithoutAsset_partsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutAsset_partsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutAsset_partsInput, PartUncheckedUpdateWithoutAsset_partsInput>
  }

  export type PartUpdateWithoutAsset_partsInput = {
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PartUncheckedUpdateWithoutAsset_partsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    part_number?: StringFieldUpdateOperationsInput | string
    dealer_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserUpsertWithoutAsset_partsInput = {
    update: XOR<UserUpdateWithoutAsset_partsInput, UserUncheckedUpdateWithoutAsset_partsInput>
    create: XOR<UserCreateWithoutAsset_partsInput, UserUncheckedCreateWithoutAsset_partsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAsset_partsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAsset_partsInput, UserUncheckedUpdateWithoutAsset_partsInput>
  }

  export type UserUpdateWithoutAsset_partsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAsset_partsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WarehouseCreateWithoutOrigin_transfersInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutOrigin_transfersInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutOrigin_transfersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutOrigin_transfersInput, WarehouseUncheckedCreateWithoutOrigin_transfersInput>
  }

  export type WarehouseCreateWithoutDestination_transfersInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutDestination_transfersInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutDestination_transfersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutDestination_transfersInput, WarehouseUncheckedCreateWithoutDestination_transfersInput>
  }

  export type OrganizationCreateWithoutTransfersInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
  }

  export type OrganizationUncheckedCreateWithoutTransfersInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type OrganizationCreateOrConnectWithoutTransfersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTransfersInput, OrganizationUncheckedCreateWithoutTransfersInput>
  }

  export type UserCreateWithoutTransfersInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutTransfersInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfersInput, UserUncheckedCreateWithoutTransfersInput>
  }

  export type AssetTransferCreateWithoutTransferInput = {
    asset: AssetCreateNestedOneWithoutAsset_transfersInput
  }

  export type AssetTransferUncheckedCreateWithoutTransferInput = {
    asset_id: number
  }

  export type AssetTransferCreateOrConnectWithoutTransferInput = {
    where: AssetTransferWhereUniqueInput
    create: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput>
  }

  export type AssetTransferCreateManyTransferInputEnvelope = {
    data: AssetTransferCreateManyTransferInput | AssetTransferCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutOrigin_transfersInput = {
    update: XOR<WarehouseUpdateWithoutOrigin_transfersInput, WarehouseUncheckedUpdateWithoutOrigin_transfersInput>
    create: XOR<WarehouseCreateWithoutOrigin_transfersInput, WarehouseUncheckedCreateWithoutOrigin_transfersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutOrigin_transfersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutOrigin_transfersInput, WarehouseUncheckedUpdateWithoutOrigin_transfersInput>
  }

  export type WarehouseUpdateWithoutOrigin_transfersInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutOrigin_transfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUpsertWithoutDestination_transfersInput = {
    update: XOR<WarehouseUpdateWithoutDestination_transfersInput, WarehouseUncheckedUpdateWithoutDestination_transfersInput>
    create: XOR<WarehouseCreateWithoutDestination_transfersInput, WarehouseUncheckedCreateWithoutDestination_transfersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutDestination_transfersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutDestination_transfersInput, WarehouseUncheckedUpdateWithoutDestination_transfersInput>
  }

  export type WarehouseUpdateWithoutDestination_transfersInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutDestination_transfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type OrganizationUpsertWithoutTransfersInput = {
    update: XOR<OrganizationUpdateWithoutTransfersInput, OrganizationUncheckedUpdateWithoutTransfersInput>
    create: XOR<OrganizationCreateWithoutTransfersInput, OrganizationUncheckedCreateWithoutTransfersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTransfersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTransfersInput, OrganizationUncheckedUpdateWithoutTransfersInput>
  }

  export type OrganizationUpdateWithoutTransfersInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutTransfersInput = {
    update: XOR<UserUpdateWithoutTransfersInput, UserUncheckedUpdateWithoutTransfersInput>
    create: XOR<UserCreateWithoutTransfersInput, UserUncheckedCreateWithoutTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfersInput, UserUncheckedUpdateWithoutTransfersInput>
  }

  export type UserUpdateWithoutTransfersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetTransferUpsertWithWhereUniqueWithoutTransferInput = {
    where: AssetTransferWhereUniqueInput
    update: XOR<AssetTransferUpdateWithoutTransferInput, AssetTransferUncheckedUpdateWithoutTransferInput>
    create: XOR<AssetTransferCreateWithoutTransferInput, AssetTransferUncheckedCreateWithoutTransferInput>
  }

  export type AssetTransferUpdateWithWhereUniqueWithoutTransferInput = {
    where: AssetTransferWhereUniqueInput
    data: XOR<AssetTransferUpdateWithoutTransferInput, AssetTransferUncheckedUpdateWithoutTransferInput>
  }

  export type AssetTransferUpdateManyWithWhereWithoutTransferInput = {
    where: AssetTransferScalarWhereInput
    data: XOR<AssetTransferUpdateManyMutationInput, AssetTransferUncheckedUpdateManyWithoutTransferInput>
  }

  export type AssetCreateWithoutAsset_transfersInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAsset_transfersInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAsset_transfersInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAsset_transfersInput, AssetUncheckedCreateWithoutAsset_transfersInput>
  }

  export type TransferCreateWithoutAsset_transfersInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutOrigin_transfersInput
    destination: WarehouseCreateNestedOneWithoutDestination_transfersInput
    transporter: OrganizationCreateNestedOneWithoutTransfersInput
    created_by: UserCreateNestedOneWithoutTransfersInput
  }

  export type TransferUncheckedCreateWithoutAsset_transfersInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type TransferCreateOrConnectWithoutAsset_transfersInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutAsset_transfersInput, TransferUncheckedCreateWithoutAsset_transfersInput>
  }

  export type AssetUpsertWithoutAsset_transfersInput = {
    update: XOR<AssetUpdateWithoutAsset_transfersInput, AssetUncheckedUpdateWithoutAsset_transfersInput>
    create: XOR<AssetCreateWithoutAsset_transfersInput, AssetUncheckedCreateWithoutAsset_transfersInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAsset_transfersInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAsset_transfersInput, AssetUncheckedUpdateWithoutAsset_transfersInput>
  }

  export type AssetUpdateWithoutAsset_transfersInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAsset_transfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type TransferUpsertWithoutAsset_transfersInput = {
    update: XOR<TransferUpdateWithoutAsset_transfersInput, TransferUncheckedUpdateWithoutAsset_transfersInput>
    create: XOR<TransferCreateWithoutAsset_transfersInput, TransferUncheckedCreateWithoutAsset_transfersInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutAsset_transfersInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutAsset_transfersInput, TransferUncheckedUpdateWithoutAsset_transfersInput>
  }

  export type TransferUpdateWithoutAsset_transfersInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutTransfersNestedInput
    created_by?: UserUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutAsset_transfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutArrivals_originInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutArrivals_originInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutArrivals_originInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutArrivals_originInput, OrganizationUncheckedCreateWithoutArrivals_originInput>
  }

  export type WarehouseCreateWithoutArrivalsInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutArrivalsInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutArrivalsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutArrivalsInput, WarehouseUncheckedCreateWithoutArrivalsInput>
  }

  export type OrganizationCreateWithoutArrivals_transporterInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutArrivals_transporterInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutArrivals_transporterInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutArrivals_transporterInput, OrganizationUncheckedCreateWithoutArrivals_transporterInput>
  }

  export type UserCreateWithoutArrivalsInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutArrivalsInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutArrivalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArrivalsInput, UserUncheckedCreateWithoutArrivalsInput>
  }

  export type AssetCreateWithoutArrivalInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutArrivalInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutArrivalInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput>
  }

  export type AssetCreateManyArrivalInputEnvelope = {
    data: AssetCreateManyArrivalInput | AssetCreateManyArrivalInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutArrivals_originInput = {
    update: XOR<OrganizationUpdateWithoutArrivals_originInput, OrganizationUncheckedUpdateWithoutArrivals_originInput>
    create: XOR<OrganizationCreateWithoutArrivals_originInput, OrganizationUncheckedCreateWithoutArrivals_originInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutArrivals_originInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutArrivals_originInput, OrganizationUncheckedUpdateWithoutArrivals_originInput>
  }

  export type OrganizationUpdateWithoutArrivals_originInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutArrivals_originInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type WarehouseUpsertWithoutArrivalsInput = {
    update: XOR<WarehouseUpdateWithoutArrivalsInput, WarehouseUncheckedUpdateWithoutArrivalsInput>
    create: XOR<WarehouseCreateWithoutArrivalsInput, WarehouseUncheckedCreateWithoutArrivalsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutArrivalsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutArrivalsInput, WarehouseUncheckedUpdateWithoutArrivalsInput>
  }

  export type WarehouseUpdateWithoutArrivalsInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutArrivalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type OrganizationUpsertWithoutArrivals_transporterInput = {
    update: XOR<OrganizationUpdateWithoutArrivals_transporterInput, OrganizationUncheckedUpdateWithoutArrivals_transporterInput>
    create: XOR<OrganizationCreateWithoutArrivals_transporterInput, OrganizationUncheckedCreateWithoutArrivals_transporterInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutArrivals_transporterInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutArrivals_transporterInput, OrganizationUncheckedUpdateWithoutArrivals_transporterInput>
  }

  export type OrganizationUpdateWithoutArrivals_transporterInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutArrivals_transporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type UserUpsertWithoutArrivalsInput = {
    update: XOR<UserUpdateWithoutArrivalsInput, UserUncheckedUpdateWithoutArrivalsInput>
    create: XOR<UserCreateWithoutArrivalsInput, UserUncheckedCreateWithoutArrivalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArrivalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArrivalsInput, UserUncheckedUpdateWithoutArrivalsInput>
  }

  export type UserUpdateWithoutArrivalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutArrivalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutArrivalInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutArrivalInput, AssetUncheckedUpdateWithoutArrivalInput>
    create: XOR<AssetCreateWithoutArrivalInput, AssetUncheckedCreateWithoutArrivalInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutArrivalInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutArrivalInput, AssetUncheckedUpdateWithoutArrivalInput>
  }

  export type AssetUpdateManyWithWhereWithoutArrivalInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutArrivalInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: IntFilter<"Asset"> | number
    barcode?: StringFilter<"Asset"> | string
    serial_number?: StringFilter<"Asset"> | string
    brand_id?: IntFilter<"Asset"> | number
    model_id?: IntFilter<"Asset"> | number
    warehouse_id?: IntFilter<"Asset"> | number
    asset_location?: StringNullableFilter<"Asset"> | string | null
    asset_type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFilter<"Asset"> | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFilter<"Asset"> | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFilter<"Asset"> | $Enums.TechnicalStatus
    purchase_invoice_id?: IntNullableFilter<"Asset"> | number | null
    sales_invoice_id?: IntNullableFilter<"Asset"> | number | null
    arrival_id?: IntNullableFilter<"Asset"> | number | null
    departure_id?: IntNullableFilter<"Asset"> | number | null
    hold_id?: IntNullableFilter<"Asset"> | number | null
    is_held?: BoolFilter<"Asset"> | boolean
    created_at?: DateTimeFilter<"Asset"> | Date | string
  }

  export type WarehouseCreateWithoutDeparturesInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
    locations?: LocationCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutDeparturesInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutDeparturesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutDeparturesInput, WarehouseUncheckedCreateWithoutDeparturesInput>
  }

  export type OrganizationCreateWithoutDepartures_destinationInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutDepartures_destinationInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutDepartures_destinationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDepartures_destinationInput, OrganizationUncheckedCreateWithoutDepartures_destinationInput>
  }

  export type OrganizationCreateWithoutDepartures_transporterInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutDepartures_transporterInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutDepartures_transporterInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDepartures_transporterInput, OrganizationUncheckedCreateWithoutDepartures_transporterInput>
  }

  export type UserCreateWithoutDeparturesInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutDeparturesInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDeparturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeparturesInput, UserUncheckedCreateWithoutDeparturesInput>
  }

  export type UserCreateWithoutDeparture_sales_repsInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutDeparture_sales_repsInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDeparture_sales_repsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeparture_sales_repsInput, UserUncheckedCreateWithoutDeparture_sales_repsInput>
  }

  export type AssetCreateWithoutDepartureInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutDepartureInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutDepartureInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput>
  }

  export type AssetCreateManyDepartureInputEnvelope = {
    data: AssetCreateManyDepartureInput | AssetCreateManyDepartureInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutDeparturesInput = {
    update: XOR<WarehouseUpdateWithoutDeparturesInput, WarehouseUncheckedUpdateWithoutDeparturesInput>
    create: XOR<WarehouseCreateWithoutDeparturesInput, WarehouseUncheckedCreateWithoutDeparturesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutDeparturesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutDeparturesInput, WarehouseUncheckedUpdateWithoutDeparturesInput>
  }

  export type WarehouseUpdateWithoutDeparturesInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutDeparturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type OrganizationUpsertWithoutDepartures_destinationInput = {
    update: XOR<OrganizationUpdateWithoutDepartures_destinationInput, OrganizationUncheckedUpdateWithoutDepartures_destinationInput>
    create: XOR<OrganizationCreateWithoutDepartures_destinationInput, OrganizationUncheckedCreateWithoutDepartures_destinationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDepartures_destinationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDepartures_destinationInput, OrganizationUncheckedUpdateWithoutDepartures_destinationInput>
  }

  export type OrganizationUpdateWithoutDepartures_destinationInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDepartures_destinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUpsertWithoutDepartures_transporterInput = {
    update: XOR<OrganizationUpdateWithoutDepartures_transporterInput, OrganizationUncheckedUpdateWithoutDepartures_transporterInput>
    create: XOR<OrganizationCreateWithoutDepartures_transporterInput, OrganizationUncheckedCreateWithoutDepartures_transporterInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDepartures_transporterInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDepartures_transporterInput, OrganizationUncheckedUpdateWithoutDepartures_transporterInput>
  }

  export type OrganizationUpdateWithoutDepartures_transporterInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDepartures_transporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type UserUpsertWithoutDeparturesInput = {
    update: XOR<UserUpdateWithoutDeparturesInput, UserUncheckedUpdateWithoutDeparturesInput>
    create: XOR<UserCreateWithoutDeparturesInput, UserUncheckedCreateWithoutDeparturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeparturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeparturesInput, UserUncheckedUpdateWithoutDeparturesInput>
  }

  export type UserUpdateWithoutDeparturesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDeparturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutDeparture_sales_repsInput = {
    update: XOR<UserUpdateWithoutDeparture_sales_repsInput, UserUncheckedUpdateWithoutDeparture_sales_repsInput>
    create: XOR<UserCreateWithoutDeparture_sales_repsInput, UserUncheckedCreateWithoutDeparture_sales_repsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeparture_sales_repsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeparture_sales_repsInput, UserUncheckedUpdateWithoutDeparture_sales_repsInput>
  }

  export type UserUpdateWithoutDeparture_sales_repsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDeparture_sales_repsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutDepartureInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutDepartureInput, AssetUncheckedUpdateWithoutDepartureInput>
    create: XOR<AssetCreateWithoutDepartureInput, AssetUncheckedCreateWithoutDepartureInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutDepartureInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutDepartureInput, AssetUncheckedUpdateWithoutDepartureInput>
  }

  export type AssetUpdateManyWithWhereWithoutDepartureInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutDepartureInput>
  }

  export type UserCreateWithoutHolds_createdInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutHolds_createdInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutHolds_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHolds_createdInput, UserUncheckedCreateWithoutHolds_createdInput>
  }

  export type UserCreateWithoutHolds_forInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutHolds_forInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutHolds_forInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHolds_forInput, UserUncheckedCreateWithoutHolds_forInput>
  }

  export type OrganizationCreateWithoutHoldsInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutHoldsInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutHoldsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutHoldsInput, OrganizationUncheckedCreateWithoutHoldsInput>
  }

  export type AssetCreateWithoutHoldInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutHoldInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutHoldInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput>
  }

  export type AssetCreateManyHoldInputEnvelope = {
    data: AssetCreateManyHoldInput | AssetCreateManyHoldInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHolds_createdInput = {
    update: XOR<UserUpdateWithoutHolds_createdInput, UserUncheckedUpdateWithoutHolds_createdInput>
    create: XOR<UserCreateWithoutHolds_createdInput, UserUncheckedCreateWithoutHolds_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHolds_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHolds_createdInput, UserUncheckedUpdateWithoutHolds_createdInput>
  }

  export type UserUpdateWithoutHolds_createdInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutHolds_createdInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutHolds_forInput = {
    update: XOR<UserUpdateWithoutHolds_forInput, UserUncheckedUpdateWithoutHolds_forInput>
    create: XOR<UserCreateWithoutHolds_forInput, UserUncheckedCreateWithoutHolds_forInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHolds_forInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHolds_forInput, UserUncheckedUpdateWithoutHolds_forInput>
  }

  export type UserUpdateWithoutHolds_forInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutHolds_forInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type OrganizationUpsertWithoutHoldsInput = {
    update: XOR<OrganizationUpdateWithoutHoldsInput, OrganizationUncheckedUpdateWithoutHoldsInput>
    create: XOR<OrganizationCreateWithoutHoldsInput, OrganizationUncheckedCreateWithoutHoldsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutHoldsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutHoldsInput, OrganizationUncheckedUpdateWithoutHoldsInput>
  }

  export type OrganizationUpdateWithoutHoldsInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutHoldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutHoldInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutHoldInput, AssetUncheckedUpdateWithoutHoldInput>
    create: XOR<AssetCreateWithoutHoldInput, AssetUncheckedCreateWithoutHoldInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutHoldInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutHoldInput, AssetUncheckedUpdateWithoutHoldInput>
  }

  export type AssetUpdateManyWithWhereWithoutHoldInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutHoldInput>
  }

  export type OrganizationCreateWithoutInvoicesInput = {
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    arrivals_origin?: ArrivalCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureCreateNestedManyWithoutTransporterInput
    holds?: HoldCreateNestedManyWithoutCustomerInput
    transfers?: TransferCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationUncheckedCreateWithoutInvoicesInput = {
    id?: number
    account_number: string
    name: string
    contact_name?: string | null
    phone?: string | null
    phone_ext?: string | null
    primary_email?: string | null
    secondary_email?: string | null
    address?: string | null
    city?: string | null
    province?: string | null
    country?: string | null
    website?: string | null
    arrivals_origin?: ArrivalUncheckedCreateNestedManyWithoutOriginInput
    arrivals_transporter?: ArrivalUncheckedCreateNestedManyWithoutTransporterInput
    departures_destination?: DepartureUncheckedCreateNestedManyWithoutDestinationInput
    departures_transporter?: DepartureUncheckedCreateNestedManyWithoutTransporterInput
    holds?: HoldUncheckedCreateNestedManyWithoutCustomerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutTransporterInput
  }

  export type OrganizationCreateOrConnectWithoutInvoicesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvoicesInput, OrganizationUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoices_updatedInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutInvoices_updatedInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutInvoices_updatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoices_updatedInput, UserUncheckedCreateWithoutInvoices_updatedInput>
  }

  export type AssetCreateWithoutPurchase_invoiceInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutPurchase_invoiceInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutPurchase_invoiceInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput>
  }

  export type AssetCreateManyPurchase_invoiceInputEnvelope = {
    data: AssetCreateManyPurchase_invoiceInput | AssetCreateManyPurchase_invoiceInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutSales_invoiceInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutSales_invoiceInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutSales_invoiceInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput>
  }

  export type AssetCreateManySales_invoiceInputEnvelope = {
    data: AssetCreateManySales_invoiceInput | AssetCreateManySales_invoiceInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutInvoicesInput = {
    update: XOR<OrganizationUpdateWithoutInvoicesInput, OrganizationUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrganizationCreateWithoutInvoicesInput, OrganizationUncheckedCreateWithoutInvoicesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvoicesInput, OrganizationUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrganizationUpdateWithoutInvoicesInput = {
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    arrivals_origin?: ArrivalUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUpdateManyWithoutTransporterNestedInput
    holds?: HoldUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUpdateManyWithoutTransporterNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_ext?: NullableStringFieldUpdateOperationsInput | string | null
    primary_email?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    arrivals_origin?: ArrivalUncheckedUpdateManyWithoutOriginNestedInput
    arrivals_transporter?: ArrivalUncheckedUpdateManyWithoutTransporterNestedInput
    departures_destination?: DepartureUncheckedUpdateManyWithoutDestinationNestedInput
    departures_transporter?: DepartureUncheckedUpdateManyWithoutTransporterNestedInput
    holds?: HoldUncheckedUpdateManyWithoutCustomerNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutTransporterNestedInput
  }

  export type UserUpsertWithoutInvoices_updatedInput = {
    update: XOR<UserUpdateWithoutInvoices_updatedInput, UserUncheckedUpdateWithoutInvoices_updatedInput>
    create: XOR<UserCreateWithoutInvoices_updatedInput, UserUncheckedCreateWithoutInvoices_updatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoices_updatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoices_updatedInput, UserUncheckedUpdateWithoutInvoices_updatedInput>
  }

  export type UserUpdateWithoutInvoices_updatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoices_updatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutPurchase_invoiceInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutPurchase_invoiceInput, AssetUncheckedUpdateWithoutPurchase_invoiceInput>
    create: XOR<AssetCreateWithoutPurchase_invoiceInput, AssetUncheckedCreateWithoutPurchase_invoiceInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutPurchase_invoiceInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutPurchase_invoiceInput, AssetUncheckedUpdateWithoutPurchase_invoiceInput>
  }

  export type AssetUpdateManyWithWhereWithoutPurchase_invoiceInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutPurchase_invoiceInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutSales_invoiceInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutSales_invoiceInput, AssetUncheckedUpdateWithoutSales_invoiceInput>
    create: XOR<AssetCreateWithoutSales_invoiceInput, AssetUncheckedCreateWithoutSales_invoiceInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutSales_invoiceInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutSales_invoiceInput, AssetUncheckedUpdateWithoutSales_invoiceInput>
  }

  export type AssetUpdateManyWithWhereWithoutSales_invoiceInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutSales_invoiceInput>
  }

  export type AssetCreateWithoutWarehouseInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutWarehouseInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutWarehouseInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput>
  }

  export type AssetCreateManyWarehouseInputEnvelope = {
    data: AssetCreateManyWarehouseInput | AssetCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutOriginInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    destination: WarehouseCreateNestedOneWithoutDestination_transfersInput
    transporter: OrganizationCreateNestedOneWithoutTransfersInput
    created_by: UserCreateNestedOneWithoutTransfersInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutOriginInput = {
    id?: number
    transfer_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutOriginInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput>
  }

  export type TransferCreateManyOriginInputEnvelope = {
    data: TransferCreateManyOriginInput | TransferCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutDestinationInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutOrigin_transfersInput
    transporter: OrganizationCreateNestedOneWithoutTransfersInput
    created_by: UserCreateNestedOneWithoutTransfersInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutDestinationInput = {
    id?: number
    transfer_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutDestinationInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput>
  }

  export type TransferCreateManyDestinationInputEnvelope = {
    data: TransferCreateManyDestinationInput | TransferCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type DepartureCreateWithoutOriginInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateWithoutOriginInput = {
    id?: number
    departure_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureCreateOrConnectWithoutOriginInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput>
  }

  export type DepartureCreateManyOriginInputEnvelope = {
    data: DepartureCreateManyOriginInput | DepartureCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalCreateWithoutDestinationInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    origin: OrganizationCreateNestedOneWithoutArrivals_originInput
    transporter: OrganizationCreateNestedOneWithoutArrivals_transporterInput
    created_by: UserCreateNestedOneWithoutArrivalsInput
    assets?: AssetCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUncheckedCreateWithoutDestinationInput = {
    id?: number
    arrival_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalCreateOrConnectWithoutDestinationInput = {
    where: ArrivalWhereUniqueInput
    create: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput>
  }

  export type ArrivalCreateManyDestinationInputEnvelope = {
    data: ArrivalCreateManyDestinationInput | ArrivalCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutWarehouseInput = {
    location: string
    assets?: AssetCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutWarehouseInput = {
    location: string
    assets?: AssetUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput>
  }

  export type LocationCreateManyWarehouseInputEnvelope = {
    data: LocationCreateManyWarehouseInput | LocationCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type AssetUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutWarehouseInput, AssetUncheckedUpdateWithoutWarehouseInput>
    create: XOR<AssetCreateWithoutWarehouseInput, AssetUncheckedCreateWithoutWarehouseInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutWarehouseInput, AssetUncheckedUpdateWithoutWarehouseInput>
  }

  export type AssetUpdateManyWithWhereWithoutWarehouseInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutOriginInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutOriginInput, TransferUncheckedUpdateWithoutOriginInput>
    create: XOR<TransferCreateWithoutOriginInput, TransferUncheckedCreateWithoutOriginInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutOriginInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutOriginInput, TransferUncheckedUpdateWithoutOriginInput>
  }

  export type TransferUpdateManyWithWhereWithoutOriginInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutOriginInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: IntFilter<"Transfer"> | number
    transfer_number?: StringFilter<"Transfer"> | string
    origin_id?: IntFilter<"Transfer"> | number
    destination_id?: IntFilter<"Transfer"> | number
    transporter_id?: IntFilter<"Transfer"> | number
    created_by_id?: IntFilter<"Transfer"> | number
    notes?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutDestinationInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutDestinationInput, TransferUncheckedUpdateWithoutDestinationInput>
    create: XOR<TransferCreateWithoutDestinationInput, TransferUncheckedCreateWithoutDestinationInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutDestinationInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutDestinationInput, TransferUncheckedUpdateWithoutDestinationInput>
  }

  export type TransferUpdateManyWithWhereWithoutDestinationInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutDestinationInput>
  }

  export type DepartureUpsertWithWhereUniqueWithoutOriginInput = {
    where: DepartureWhereUniqueInput
    update: XOR<DepartureUpdateWithoutOriginInput, DepartureUncheckedUpdateWithoutOriginInput>
    create: XOR<DepartureCreateWithoutOriginInput, DepartureUncheckedCreateWithoutOriginInput>
  }

  export type DepartureUpdateWithWhereUniqueWithoutOriginInput = {
    where: DepartureWhereUniqueInput
    data: XOR<DepartureUpdateWithoutOriginInput, DepartureUncheckedUpdateWithoutOriginInput>
  }

  export type DepartureUpdateManyWithWhereWithoutOriginInput = {
    where: DepartureScalarWhereInput
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyWithoutOriginInput>
  }

  export type DepartureScalarWhereInput = {
    AND?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
    OR?: DepartureScalarWhereInput[]
    NOT?: DepartureScalarWhereInput | DepartureScalarWhereInput[]
    id?: IntFilter<"Departure"> | number
    departure_number?: StringFilter<"Departure"> | string
    origin_id?: IntFilter<"Departure"> | number
    destination_id?: IntFilter<"Departure"> | number
    transporter_id?: IntFilter<"Departure"> | number
    created_by_id?: IntFilter<"Departure"> | number
    sales_representative_id?: IntFilter<"Departure"> | number
    notes?: StringNullableFilter<"Departure"> | string | null
    created_at?: DateTimeFilter<"Departure"> | Date | string
  }

  export type ArrivalUpsertWithWhereUniqueWithoutDestinationInput = {
    where: ArrivalWhereUniqueInput
    update: XOR<ArrivalUpdateWithoutDestinationInput, ArrivalUncheckedUpdateWithoutDestinationInput>
    create: XOR<ArrivalCreateWithoutDestinationInput, ArrivalUncheckedCreateWithoutDestinationInput>
  }

  export type ArrivalUpdateWithWhereUniqueWithoutDestinationInput = {
    where: ArrivalWhereUniqueInput
    data: XOR<ArrivalUpdateWithoutDestinationInput, ArrivalUncheckedUpdateWithoutDestinationInput>
  }

  export type ArrivalUpdateManyWithWhereWithoutDestinationInput = {
    where: ArrivalScalarWhereInput
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyWithoutDestinationInput>
  }

  export type ArrivalScalarWhereInput = {
    AND?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
    OR?: ArrivalScalarWhereInput[]
    NOT?: ArrivalScalarWhereInput | ArrivalScalarWhereInput[]
    id?: IntFilter<"Arrival"> | number
    arrival_number?: StringFilter<"Arrival"> | string
    origin_id?: IntFilter<"Arrival"> | number
    destination_id?: IntFilter<"Arrival"> | number
    transporter_id?: IntFilter<"Arrival"> | number
    created_by_id?: IntFilter<"Arrival"> | number
    notes?: StringNullableFilter<"Arrival"> | string | null
    created_at?: DateTimeFilter<"Arrival"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutWarehouseInput, LocationUncheckedUpdateWithoutWarehouseInput>
    create: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutWarehouseInput, LocationUncheckedUpdateWithoutWarehouseInput>
  }

  export type LocationUpdateManyWithWhereWithoutWarehouseInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    warehouse_id?: IntFilter<"Location"> | number
    location?: StringFilter<"Location"> | string
  }

  export type WarehouseCreateWithoutLocationsInput = {
    city_code: string
    street: string
    assets?: AssetCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferCreateNestedManyWithoutDestinationInput
    departures?: DepartureCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalCreateNestedManyWithoutDestinationInput
  }

  export type WarehouseUncheckedCreateWithoutLocationsInput = {
    id?: number
    city_code: string
    street: string
    assets?: AssetUncheckedCreateNestedManyWithoutWarehouseInput
    origin_transfers?: TransferUncheckedCreateNestedManyWithoutOriginInput
    destination_transfers?: TransferUncheckedCreateNestedManyWithoutDestinationInput
    departures?: DepartureUncheckedCreateNestedManyWithoutOriginInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type WarehouseCreateOrConnectWithoutLocationsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
  }

  export type AssetCreateWithoutLocationInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutLocationInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutLocationInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput>
  }

  export type AssetCreateManyLocationInputEnvelope = {
    data: AssetCreateManyLocationInput | AssetCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutLocationsInput = {
    update: XOR<WarehouseUpdateWithoutLocationsInput, WarehouseUncheckedUpdateWithoutLocationsInput>
    create: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutLocationsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutLocationsInput, WarehouseUncheckedUpdateWithoutLocationsInput>
  }

  export type WarehouseUpdateWithoutLocationsInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUpdateManyWithoutDestinationNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_code?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutWarehouseNestedInput
    origin_transfers?: TransferUncheckedUpdateManyWithoutOriginNestedInput
    destination_transfers?: TransferUncheckedUpdateManyWithoutDestinationNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutOriginNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutLocationInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutLocationInput, AssetUncheckedUpdateWithoutLocationInput>
    create: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutLocationInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutLocationInput, AssetUncheckedUpdateWithoutLocationInput>
  }

  export type AssetUpdateManyWithWhereWithoutLocationInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutLocationInput>
  }

  export type ModelCreateWithoutBrandInput = {
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    assets?: AssetCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
    assets?: AssetUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutBrandInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput>
  }

  export type ModelCreateManyBrandInputEnvelope = {
    data: ModelCreateManyBrandInput | ModelCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ErrorCategoryCreateWithoutBrandInput = {
    category: string
    errors?: ErrorCreateNestedManyWithoutCategoryInput
  }

  export type ErrorCategoryUncheckedCreateWithoutBrandInput = {
    id?: number
    category: string
    errors?: ErrorUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ErrorCategoryCreateOrConnectWithoutBrandInput = {
    where: ErrorCategoryWhereUniqueInput
    create: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput>
  }

  export type ErrorCategoryCreateManyBrandInputEnvelope = {
    data: ErrorCategoryCreateManyBrandInput | ErrorCategoryCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutBrandInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutBrandInput = {
    id?: number
    barcode: string
    serial_number: string
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutBrandInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput>
  }

  export type AssetCreateManyBrandInputEnvelope = {
    data: AssetCreateManyBrandInput | AssetCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ModelUpsertWithWhereUniqueWithoutBrandInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutBrandInput, ModelUncheckedUpdateWithoutBrandInput>
    create: XOR<ModelCreateWithoutBrandInput, ModelUncheckedCreateWithoutBrandInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutBrandInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutBrandInput, ModelUncheckedUpdateWithoutBrandInput>
  }

  export type ModelUpdateManyWithWhereWithoutBrandInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutBrandInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: IntFilter<"Model"> | number
    name?: StringFilter<"Model"> | string
    asset_type?: EnumAssetTypeFilter<"Model"> | $Enums.AssetType
    weight?: FloatFilter<"Model"> | number
    size?: FloatFilter<"Model"> | number
    brand_id?: IntFilter<"Model"> | number
  }

  export type ErrorCategoryUpsertWithWhereUniqueWithoutBrandInput = {
    where: ErrorCategoryWhereUniqueInput
    update: XOR<ErrorCategoryUpdateWithoutBrandInput, ErrorCategoryUncheckedUpdateWithoutBrandInput>
    create: XOR<ErrorCategoryCreateWithoutBrandInput, ErrorCategoryUncheckedCreateWithoutBrandInput>
  }

  export type ErrorCategoryUpdateWithWhereUniqueWithoutBrandInput = {
    where: ErrorCategoryWhereUniqueInput
    data: XOR<ErrorCategoryUpdateWithoutBrandInput, ErrorCategoryUncheckedUpdateWithoutBrandInput>
  }

  export type ErrorCategoryUpdateManyWithWhereWithoutBrandInput = {
    where: ErrorCategoryScalarWhereInput
    data: XOR<ErrorCategoryUpdateManyMutationInput, ErrorCategoryUncheckedUpdateManyWithoutBrandInput>
  }

  export type ErrorCategoryScalarWhereInput = {
    AND?: ErrorCategoryScalarWhereInput | ErrorCategoryScalarWhereInput[]
    OR?: ErrorCategoryScalarWhereInput[]
    NOT?: ErrorCategoryScalarWhereInput | ErrorCategoryScalarWhereInput[]
    id?: IntFilter<"ErrorCategory"> | number
    brand_id?: IntFilter<"ErrorCategory"> | number
    category?: StringFilter<"ErrorCategory"> | string
  }

  export type AssetUpsertWithWhereUniqueWithoutBrandInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutBrandInput, AssetUncheckedUpdateWithoutBrandInput>
    create: XOR<AssetCreateWithoutBrandInput, AssetUncheckedCreateWithoutBrandInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutBrandInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutBrandInput, AssetUncheckedUpdateWithoutBrandInput>
  }

  export type AssetUpdateManyWithWhereWithoutBrandInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutBrandInput>
  }

  export type BrandCreateWithoutModelsInput = {
    name: string
    errorCategories?: ErrorCategoryCreateNestedManyWithoutBrandInput
    assets?: AssetCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutModelsInput = {
    id?: number
    name: string
    errorCategories?: ErrorCategoryUncheckedCreateNestedManyWithoutBrandInput
    assets?: AssetUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutModelsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutModelsInput, BrandUncheckedCreateWithoutModelsInput>
  }

  export type AssetCreateWithoutModelInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutModelInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutModelInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput>
  }

  export type AssetCreateManyModelInputEnvelope = {
    data: AssetCreateManyModelInput | AssetCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutModelsInput = {
    update: XOR<BrandUpdateWithoutModelsInput, BrandUncheckedUpdateWithoutModelsInput>
    create: XOR<BrandCreateWithoutModelsInput, BrandUncheckedCreateWithoutModelsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutModelsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutModelsInput, BrandUncheckedUpdateWithoutModelsInput>
  }

  export type BrandUpdateWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    errorCategories?: ErrorCategoryUpdateManyWithoutBrandNestedInput
    assets?: AssetUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    errorCategories?: ErrorCategoryUncheckedUpdateManyWithoutBrandNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutModelInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutModelInput, AssetUncheckedUpdateWithoutModelInput>
    create: XOR<AssetCreateWithoutModelInput, AssetUncheckedCreateWithoutModelInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutModelInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutModelInput, AssetUncheckedUpdateWithoutModelInput>
  }

  export type AssetUpdateManyWithWhereWithoutModelInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutModelInput>
  }

  export type AssetCreateWithoutFilesInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutFilesInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutFilesInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutFilesInput, AssetUncheckedCreateWithoutFilesInput>
  }

  export type UserCreateWithoutFilesInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutFilesInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
  }

  export type AssetUpsertWithoutFilesInput = {
    update: XOR<AssetUpdateWithoutFilesInput, AssetUncheckedUpdateWithoutFilesInput>
    create: XOR<AssetCreateWithoutFilesInput, AssetUncheckedCreateWithoutFilesInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutFilesInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutFilesInput, AssetUncheckedUpdateWithoutFilesInput>
  }

  export type AssetUpdateWithoutFilesInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type UserUpsertWithoutFilesInput = {
    update: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateWithoutFilesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetCreateWithoutCommentsInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutCommentsInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutCommentsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    asset_history?: AssetHistoryCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    asset_history?: AssetHistoryUncheckedCreateNestedManyWithoutUserInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type AssetUpsertWithoutCommentsInput = {
    update: XOR<AssetUpdateWithoutCommentsInput, AssetUncheckedUpdateWithoutCommentsInput>
    create: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutCommentsInput, AssetUncheckedUpdateWithoutCommentsInput>
  }

  export type AssetUpdateWithoutCommentsInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutUserNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetErrorCreateWithoutAddedByInput = {
    is_fixed: boolean
    added_at: Date | string
    fixed_at?: Date | string | null
    asset: AssetCreateNestedOneWithoutAsset_errorsInput
    error: ErrorCreateNestedOneWithoutAsset_errorsInput
    fixedBy?: UserCreateNestedOneWithoutAsset_errors_fixedInput
  }

  export type AssetErrorUncheckedCreateWithoutAddedByInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorCreateOrConnectWithoutAddedByInput = {
    where: AssetErrorWhereUniqueInput
    create: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput>
  }

  export type AssetErrorCreateManyAddedByInputEnvelope = {
    data: AssetErrorCreateManyAddedByInput | AssetErrorCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type AssetErrorCreateWithoutFixedByInput = {
    is_fixed: boolean
    added_at: Date | string
    fixed_at?: Date | string | null
    asset: AssetCreateNestedOneWithoutAsset_errorsInput
    error: ErrorCreateNestedOneWithoutAsset_errorsInput
    addedBy: UserCreateNestedOneWithoutAsset_errors_addedInput
  }

  export type AssetErrorUncheckedCreateWithoutFixedByInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_at?: Date | string | null
  }

  export type AssetErrorCreateOrConnectWithoutFixedByInput = {
    where: AssetErrorWhereUniqueInput
    create: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput>
  }

  export type AssetErrorCreateManyFixedByInputEnvelope = {
    data: AssetErrorCreateManyFixedByInput | AssetErrorCreateManyFixedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutCreated_byInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutOrigin_transfersInput
    destination: WarehouseCreateNestedOneWithoutDestination_transfersInput
    transporter: OrganizationCreateNestedOneWithoutTransfersInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutCreated_byInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    notes?: string | null
    created_at: Date | string
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutCreated_byInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput>
  }

  export type TransferCreateManyCreated_byInputEnvelope = {
    data: TransferCreateManyCreated_byInput | TransferCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type DepartureCreateWithoutCreated_byInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateWithoutCreated_byInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureCreateOrConnectWithoutCreated_byInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput>
  }

  export type DepartureCreateManyCreated_byInputEnvelope = {
    data: DepartureCreateManyCreated_byInput | DepartureCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type DepartureCreateWithoutSales_representativeInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateWithoutSales_representativeInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureCreateOrConnectWithoutSales_representativeInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput>
  }

  export type DepartureCreateManySales_representativeInputEnvelope = {
    data: DepartureCreateManySales_representativeInput | DepartureCreateManySales_representativeInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalCreateWithoutCreated_byInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    origin: OrganizationCreateNestedOneWithoutArrivals_originInput
    destination: WarehouseCreateNestedOneWithoutArrivalsInput
    transporter: OrganizationCreateNestedOneWithoutArrivals_transporterInput
    assets?: AssetCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUncheckedCreateWithoutCreated_byInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalCreateOrConnectWithoutCreated_byInput = {
    where: ArrivalWhereUniqueInput
    create: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput>
  }

  export type ArrivalCreateManyCreated_byInputEnvelope = {
    data: ArrivalCreateManyCreated_byInput | ArrivalCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type HoldCreateWithoutCreated_byInput = {
    hold_number: string
    notes?: string | null
    created_at: Date | string
    created_for: UserCreateNestedOneWithoutHolds_forInput
    customer: OrganizationCreateNestedOneWithoutHoldsInput
    assets?: AssetCreateNestedManyWithoutHoldInput
  }

  export type HoldUncheckedCreateWithoutCreated_byInput = {
    id?: number
    hold_number: string
    created_for_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutHoldInput
  }

  export type HoldCreateOrConnectWithoutCreated_byInput = {
    where: HoldWhereUniqueInput
    create: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput>
  }

  export type HoldCreateManyCreated_byInputEnvelope = {
    data: HoldCreateManyCreated_byInput | HoldCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type HoldCreateWithoutCreated_forInput = {
    hold_number: string
    notes?: string | null
    created_at: Date | string
    created_by: UserCreateNestedOneWithoutHolds_createdInput
    customer: OrganizationCreateNestedOneWithoutHoldsInput
    assets?: AssetCreateNestedManyWithoutHoldInput
  }

  export type HoldUncheckedCreateWithoutCreated_forInput = {
    id?: number
    hold_number: string
    created_by_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutHoldInput
  }

  export type HoldCreateOrConnectWithoutCreated_forInput = {
    where: HoldWhereUniqueInput
    create: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput>
  }

  export type HoldCreateManyCreated_forInputEnvelope = {
    data: HoldCreateManyCreated_forInput | HoldCreateManyCreated_forInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUpdated_byInput = {
    invoice_number: string
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    organization: OrganizationCreateNestedOneWithoutInvoicesInput
    purchase_assets?: AssetCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUpdated_byInput = {
    id?: number
    invoice_number: string
    organization_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    purchase_assets?: AssetUncheckedCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetUncheckedCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUpdated_byInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput>
  }

  export type InvoiceCreateManyUpdated_byInputEnvelope = {
    data: InvoiceCreateManyUpdated_byInput | InvoiceCreateManyUpdated_byInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUploaded_byInput = {
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
    asset: AssetCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutUploaded_byInput = {
    id?: number
    asset_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type FileCreateOrConnectWithoutUploaded_byInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput>
  }

  export type FileCreateManyUploaded_byInputEnvelope = {
    data: FileCreateManyUploaded_byInput | FileCreateManyUploaded_byInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCreated_byInput = {
    comment: string
    created_at: Date | string
    updated_at: Date | string
    asset: AssetCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutCreated_byInput = {
    id?: number
    asset_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type CommentCreateOrConnectWithoutCreated_byInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput>
  }

  export type CommentCreateManyCreated_byInputEnvelope = {
    data: CommentCreateManyCreated_byInput | CommentCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type AssetHistoryCreateWithoutUserInput = {
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
    asset: AssetCreateNestedOneWithoutAsset_historyInput
  }

  export type AssetHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    asset_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryCreateOrConnectWithoutUserInput = {
    where: AssetHistoryWhereUniqueInput
    create: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput>
  }

  export type AssetHistoryCreateManyUserInputEnvelope = {
    data: AssetHistoryCreateManyUserInput | AssetHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssetPartCreateWithoutUpdatedByInput = {
    updated_at: Date | string
    part_operation: $Enums.PartOperation
    asset: AssetCreateNestedOneWithoutAsset_partsInput
    part: PartCreateNestedOneWithoutAsset_partsInput
  }

  export type AssetPartUncheckedCreateWithoutUpdatedByInput = {
    asset_id: number
    part_id: number
    updated_at: Date | string
    part_operation: $Enums.PartOperation
  }

  export type AssetPartCreateOrConnectWithoutUpdatedByInput = {
    where: AssetPartWhereUniqueInput
    create: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput>
  }

  export type AssetPartCreateManyUpdatedByInputEnvelope = {
    data: AssetPartCreateManyUpdatedByInput | AssetPartCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type AssetErrorUpsertWithWhereUniqueWithoutAddedByInput = {
    where: AssetErrorWhereUniqueInput
    update: XOR<AssetErrorUpdateWithoutAddedByInput, AssetErrorUncheckedUpdateWithoutAddedByInput>
    create: XOR<AssetErrorCreateWithoutAddedByInput, AssetErrorUncheckedCreateWithoutAddedByInput>
  }

  export type AssetErrorUpdateWithWhereUniqueWithoutAddedByInput = {
    where: AssetErrorWhereUniqueInput
    data: XOR<AssetErrorUpdateWithoutAddedByInput, AssetErrorUncheckedUpdateWithoutAddedByInput>
  }

  export type AssetErrorUpdateManyWithWhereWithoutAddedByInput = {
    where: AssetErrorScalarWhereInput
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyWithoutAddedByInput>
  }

  export type AssetErrorUpsertWithWhereUniqueWithoutFixedByInput = {
    where: AssetErrorWhereUniqueInput
    update: XOR<AssetErrorUpdateWithoutFixedByInput, AssetErrorUncheckedUpdateWithoutFixedByInput>
    create: XOR<AssetErrorCreateWithoutFixedByInput, AssetErrorUncheckedCreateWithoutFixedByInput>
  }

  export type AssetErrorUpdateWithWhereUniqueWithoutFixedByInput = {
    where: AssetErrorWhereUniqueInput
    data: XOR<AssetErrorUpdateWithoutFixedByInput, AssetErrorUncheckedUpdateWithoutFixedByInput>
  }

  export type AssetErrorUpdateManyWithWhereWithoutFixedByInput = {
    where: AssetErrorScalarWhereInput
    data: XOR<AssetErrorUpdateManyMutationInput, AssetErrorUncheckedUpdateManyWithoutFixedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutCreated_byInput, TransferUncheckedUpdateWithoutCreated_byInput>
    create: XOR<TransferCreateWithoutCreated_byInput, TransferUncheckedCreateWithoutCreated_byInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutCreated_byInput, TransferUncheckedUpdateWithoutCreated_byInput>
  }

  export type TransferUpdateManyWithWhereWithoutCreated_byInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type DepartureUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: DepartureWhereUniqueInput
    update: XOR<DepartureUpdateWithoutCreated_byInput, DepartureUncheckedUpdateWithoutCreated_byInput>
    create: XOR<DepartureCreateWithoutCreated_byInput, DepartureUncheckedCreateWithoutCreated_byInput>
  }

  export type DepartureUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: DepartureWhereUniqueInput
    data: XOR<DepartureUpdateWithoutCreated_byInput, DepartureUncheckedUpdateWithoutCreated_byInput>
  }

  export type DepartureUpdateManyWithWhereWithoutCreated_byInput = {
    where: DepartureScalarWhereInput
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type DepartureUpsertWithWhereUniqueWithoutSales_representativeInput = {
    where: DepartureWhereUniqueInput
    update: XOR<DepartureUpdateWithoutSales_representativeInput, DepartureUncheckedUpdateWithoutSales_representativeInput>
    create: XOR<DepartureCreateWithoutSales_representativeInput, DepartureUncheckedCreateWithoutSales_representativeInput>
  }

  export type DepartureUpdateWithWhereUniqueWithoutSales_representativeInput = {
    where: DepartureWhereUniqueInput
    data: XOR<DepartureUpdateWithoutSales_representativeInput, DepartureUncheckedUpdateWithoutSales_representativeInput>
  }

  export type DepartureUpdateManyWithWhereWithoutSales_representativeInput = {
    where: DepartureScalarWhereInput
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyWithoutSales_representativeInput>
  }

  export type ArrivalUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: ArrivalWhereUniqueInput
    update: XOR<ArrivalUpdateWithoutCreated_byInput, ArrivalUncheckedUpdateWithoutCreated_byInput>
    create: XOR<ArrivalCreateWithoutCreated_byInput, ArrivalUncheckedCreateWithoutCreated_byInput>
  }

  export type ArrivalUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: ArrivalWhereUniqueInput
    data: XOR<ArrivalUpdateWithoutCreated_byInput, ArrivalUncheckedUpdateWithoutCreated_byInput>
  }

  export type ArrivalUpdateManyWithWhereWithoutCreated_byInput = {
    where: ArrivalScalarWhereInput
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type HoldUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: HoldWhereUniqueInput
    update: XOR<HoldUpdateWithoutCreated_byInput, HoldUncheckedUpdateWithoutCreated_byInput>
    create: XOR<HoldCreateWithoutCreated_byInput, HoldUncheckedCreateWithoutCreated_byInput>
  }

  export type HoldUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: HoldWhereUniqueInput
    data: XOR<HoldUpdateWithoutCreated_byInput, HoldUncheckedUpdateWithoutCreated_byInput>
  }

  export type HoldUpdateManyWithWhereWithoutCreated_byInput = {
    where: HoldScalarWhereInput
    data: XOR<HoldUpdateManyMutationInput, HoldUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type HoldScalarWhereInput = {
    AND?: HoldScalarWhereInput | HoldScalarWhereInput[]
    OR?: HoldScalarWhereInput[]
    NOT?: HoldScalarWhereInput | HoldScalarWhereInput[]
    id?: IntFilter<"Hold"> | number
    hold_number?: StringFilter<"Hold"> | string
    created_by_id?: IntFilter<"Hold"> | number
    created_for_id?: IntFilter<"Hold"> | number
    customer_id?: IntFilter<"Hold"> | number
    notes?: StringNullableFilter<"Hold"> | string | null
    created_at?: DateTimeFilter<"Hold"> | Date | string
  }

  export type HoldUpsertWithWhereUniqueWithoutCreated_forInput = {
    where: HoldWhereUniqueInput
    update: XOR<HoldUpdateWithoutCreated_forInput, HoldUncheckedUpdateWithoutCreated_forInput>
    create: XOR<HoldCreateWithoutCreated_forInput, HoldUncheckedCreateWithoutCreated_forInput>
  }

  export type HoldUpdateWithWhereUniqueWithoutCreated_forInput = {
    where: HoldWhereUniqueInput
    data: XOR<HoldUpdateWithoutCreated_forInput, HoldUncheckedUpdateWithoutCreated_forInput>
  }

  export type HoldUpdateManyWithWhereWithoutCreated_forInput = {
    where: HoldScalarWhereInput
    data: XOR<HoldUpdateManyMutationInput, HoldUncheckedUpdateManyWithoutCreated_forInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUpdated_byInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUpdated_byInput, InvoiceUncheckedUpdateWithoutUpdated_byInput>
    create: XOR<InvoiceCreateWithoutUpdated_byInput, InvoiceUncheckedCreateWithoutUpdated_byInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUpdated_byInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUpdated_byInput, InvoiceUncheckedUpdateWithoutUpdated_byInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUpdated_byInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUpdated_byInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    invoice_number?: StringFilter<"Invoice"> | string
    organization_id?: IntFilter<"Invoice"> | number
    updated_by_id?: IntFilter<"Invoice"> | number
    is_cleared?: BoolFilter<"Invoice"> | boolean
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    invoice_type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
  }

  export type FileUpsertWithWhereUniqueWithoutUploaded_byInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUploaded_byInput, FileUncheckedUpdateWithoutUploaded_byInput>
    create: XOR<FileCreateWithoutUploaded_byInput, FileUncheckedCreateWithoutUploaded_byInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUploaded_byInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUploaded_byInput, FileUncheckedUpdateWithoutUploaded_byInput>
  }

  export type FileUpdateManyWithWhereWithoutUploaded_byInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploaded_byInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCreated_byInput, CommentUncheckedUpdateWithoutCreated_byInput>
    create: XOR<CommentCreateWithoutCreated_byInput, CommentUncheckedCreateWithoutCreated_byInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCreated_byInput, CommentUncheckedUpdateWithoutCreated_byInput>
  }

  export type CommentUpdateManyWithWhereWithoutCreated_byInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type AssetHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: AssetHistoryWhereUniqueInput
    update: XOR<AssetHistoryUpdateWithoutUserInput, AssetHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<AssetHistoryCreateWithoutUserInput, AssetHistoryUncheckedCreateWithoutUserInput>
  }

  export type AssetHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: AssetHistoryWhereUniqueInput
    data: XOR<AssetHistoryUpdateWithoutUserInput, AssetHistoryUncheckedUpdateWithoutUserInput>
  }

  export type AssetHistoryUpdateManyWithWhereWithoutUserInput = {
    where: AssetHistoryScalarWhereInput
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type AssetPartUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: AssetPartWhereUniqueInput
    update: XOR<AssetPartUpdateWithoutUpdatedByInput, AssetPartUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<AssetPartCreateWithoutUpdatedByInput, AssetPartUncheckedCreateWithoutUpdatedByInput>
  }

  export type AssetPartUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: AssetPartWhereUniqueInput
    data: XOR<AssetPartUpdateWithoutUpdatedByInput, AssetPartUncheckedUpdateWithoutUpdatedByInput>
  }

  export type AssetPartUpdateManyWithWhereWithoutUpdatedByInput = {
    where: AssetPartScalarWhereInput
    data: XOR<AssetPartUpdateManyMutationInput, AssetPartUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type InvoiceCreateWithoutOrganizationInput = {
    invoice_number: string
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    updated_by: UserCreateNestedOneWithoutInvoices_updatedInput
    purchase_assets?: AssetCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrganizationInput = {
    id?: number
    invoice_number: string
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
    purchase_assets?: AssetUncheckedCreateNestedManyWithoutPurchase_invoiceInput
    sales_assets?: AssetUncheckedCreateNestedManyWithoutSales_invoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput>
  }

  export type InvoiceCreateManyOrganizationInputEnvelope = {
    data: InvoiceCreateManyOrganizationInput | InvoiceCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalCreateWithoutOriginInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    destination: WarehouseCreateNestedOneWithoutArrivalsInput
    transporter: OrganizationCreateNestedOneWithoutArrivals_transporterInput
    created_by: UserCreateNestedOneWithoutArrivalsInput
    assets?: AssetCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUncheckedCreateWithoutOriginInput = {
    id?: number
    arrival_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalCreateOrConnectWithoutOriginInput = {
    where: ArrivalWhereUniqueInput
    create: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput>
  }

  export type ArrivalCreateManyOriginInputEnvelope = {
    data: ArrivalCreateManyOriginInput | ArrivalCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalCreateWithoutTransporterInput = {
    arrival_number: string
    notes?: string | null
    created_at: Date | string
    origin: OrganizationCreateNestedOneWithoutArrivals_originInput
    destination: WarehouseCreateNestedOneWithoutArrivalsInput
    created_by: UserCreateNestedOneWithoutArrivalsInput
    assets?: AssetCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalUncheckedCreateWithoutTransporterInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalCreateOrConnectWithoutTransporterInput = {
    where: ArrivalWhereUniqueInput
    create: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput>
  }

  export type ArrivalCreateManyTransporterInputEnvelope = {
    data: ArrivalCreateManyTransporterInput | ArrivalCreateManyTransporterInput[]
    skipDuplicates?: boolean
  }

  export type DepartureCreateWithoutDestinationInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    transporter: OrganizationCreateNestedOneWithoutDepartures_transporterInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateWithoutDestinationInput = {
    id?: number
    departure_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureCreateOrConnectWithoutDestinationInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput>
  }

  export type DepartureCreateManyDestinationInputEnvelope = {
    data: DepartureCreateManyDestinationInput | DepartureCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type DepartureCreateWithoutTransporterInput = {
    departure_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutDeparturesInput
    destination: OrganizationCreateNestedOneWithoutDepartures_destinationInput
    created_by: UserCreateNestedOneWithoutDeparturesInput
    sales_representative: UserCreateNestedOneWithoutDeparture_sales_repsInput
    assets?: AssetCreateNestedManyWithoutDepartureInput
  }

  export type DepartureUncheckedCreateWithoutTransporterInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutDepartureInput
  }

  export type DepartureCreateOrConnectWithoutTransporterInput = {
    where: DepartureWhereUniqueInput
    create: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput>
  }

  export type DepartureCreateManyTransporterInputEnvelope = {
    data: DepartureCreateManyTransporterInput | DepartureCreateManyTransporterInput[]
    skipDuplicates?: boolean
  }

  export type HoldCreateWithoutCustomerInput = {
    hold_number: string
    notes?: string | null
    created_at: Date | string
    created_by: UserCreateNestedOneWithoutHolds_createdInput
    created_for: UserCreateNestedOneWithoutHolds_forInput
    assets?: AssetCreateNestedManyWithoutHoldInput
  }

  export type HoldUncheckedCreateWithoutCustomerInput = {
    id?: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    notes?: string | null
    created_at: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutHoldInput
  }

  export type HoldCreateOrConnectWithoutCustomerInput = {
    where: HoldWhereUniqueInput
    create: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput>
  }

  export type HoldCreateManyCustomerInputEnvelope = {
    data: HoldCreateManyCustomerInput | HoldCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutTransporterInput = {
    transfer_number: string
    notes?: string | null
    created_at: Date | string
    origin: WarehouseCreateNestedOneWithoutOrigin_transfersInput
    destination: WarehouseCreateNestedOneWithoutDestination_transfersInput
    created_by: UserCreateNestedOneWithoutTransfersInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutTransporterInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutTransporterInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput>
  }

  export type TransferCreateManyTransporterInputEnvelope = {
    data: TransferCreateManyTransporterInput | TransferCreateManyTransporterInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrganizationInput, InvoiceUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrganizationInput, InvoiceUncheckedUpdateWithoutOrganizationInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ArrivalUpsertWithWhereUniqueWithoutOriginInput = {
    where: ArrivalWhereUniqueInput
    update: XOR<ArrivalUpdateWithoutOriginInput, ArrivalUncheckedUpdateWithoutOriginInput>
    create: XOR<ArrivalCreateWithoutOriginInput, ArrivalUncheckedCreateWithoutOriginInput>
  }

  export type ArrivalUpdateWithWhereUniqueWithoutOriginInput = {
    where: ArrivalWhereUniqueInput
    data: XOR<ArrivalUpdateWithoutOriginInput, ArrivalUncheckedUpdateWithoutOriginInput>
  }

  export type ArrivalUpdateManyWithWhereWithoutOriginInput = {
    where: ArrivalScalarWhereInput
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyWithoutOriginInput>
  }

  export type ArrivalUpsertWithWhereUniqueWithoutTransporterInput = {
    where: ArrivalWhereUniqueInput
    update: XOR<ArrivalUpdateWithoutTransporterInput, ArrivalUncheckedUpdateWithoutTransporterInput>
    create: XOR<ArrivalCreateWithoutTransporterInput, ArrivalUncheckedCreateWithoutTransporterInput>
  }

  export type ArrivalUpdateWithWhereUniqueWithoutTransporterInput = {
    where: ArrivalWhereUniqueInput
    data: XOR<ArrivalUpdateWithoutTransporterInput, ArrivalUncheckedUpdateWithoutTransporterInput>
  }

  export type ArrivalUpdateManyWithWhereWithoutTransporterInput = {
    where: ArrivalScalarWhereInput
    data: XOR<ArrivalUpdateManyMutationInput, ArrivalUncheckedUpdateManyWithoutTransporterInput>
  }

  export type DepartureUpsertWithWhereUniqueWithoutDestinationInput = {
    where: DepartureWhereUniqueInput
    update: XOR<DepartureUpdateWithoutDestinationInput, DepartureUncheckedUpdateWithoutDestinationInput>
    create: XOR<DepartureCreateWithoutDestinationInput, DepartureUncheckedCreateWithoutDestinationInput>
  }

  export type DepartureUpdateWithWhereUniqueWithoutDestinationInput = {
    where: DepartureWhereUniqueInput
    data: XOR<DepartureUpdateWithoutDestinationInput, DepartureUncheckedUpdateWithoutDestinationInput>
  }

  export type DepartureUpdateManyWithWhereWithoutDestinationInput = {
    where: DepartureScalarWhereInput
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyWithoutDestinationInput>
  }

  export type DepartureUpsertWithWhereUniqueWithoutTransporterInput = {
    where: DepartureWhereUniqueInput
    update: XOR<DepartureUpdateWithoutTransporterInput, DepartureUncheckedUpdateWithoutTransporterInput>
    create: XOR<DepartureCreateWithoutTransporterInput, DepartureUncheckedCreateWithoutTransporterInput>
  }

  export type DepartureUpdateWithWhereUniqueWithoutTransporterInput = {
    where: DepartureWhereUniqueInput
    data: XOR<DepartureUpdateWithoutTransporterInput, DepartureUncheckedUpdateWithoutTransporterInput>
  }

  export type DepartureUpdateManyWithWhereWithoutTransporterInput = {
    where: DepartureScalarWhereInput
    data: XOR<DepartureUpdateManyMutationInput, DepartureUncheckedUpdateManyWithoutTransporterInput>
  }

  export type HoldUpsertWithWhereUniqueWithoutCustomerInput = {
    where: HoldWhereUniqueInput
    update: XOR<HoldUpdateWithoutCustomerInput, HoldUncheckedUpdateWithoutCustomerInput>
    create: XOR<HoldCreateWithoutCustomerInput, HoldUncheckedCreateWithoutCustomerInput>
  }

  export type HoldUpdateWithWhereUniqueWithoutCustomerInput = {
    where: HoldWhereUniqueInput
    data: XOR<HoldUpdateWithoutCustomerInput, HoldUncheckedUpdateWithoutCustomerInput>
  }

  export type HoldUpdateManyWithWhereWithoutCustomerInput = {
    where: HoldScalarWhereInput
    data: XOR<HoldUpdateManyMutationInput, HoldUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutTransporterInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutTransporterInput, TransferUncheckedUpdateWithoutTransporterInput>
    create: XOR<TransferCreateWithoutTransporterInput, TransferUncheckedCreateWithoutTransporterInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutTransporterInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutTransporterInput, TransferUncheckedUpdateWithoutTransporterInput>
  }

  export type TransferUpdateManyWithWhereWithoutTransporterInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutTransporterInput>
  }

  export type AssetCreateWithoutAsset_historyInput = {
    barcode: string
    serial_number: string
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    is_held: boolean
    created_at: Date | string
    cost?: CostCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationCreateNestedOneWithoutAssetInput
    brand: BrandCreateNestedOneWithoutAssetsInput
    model: ModelCreateNestedOneWithoutAssetsInput
    warehouse: WarehouseCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchase_invoice?: InvoiceCreateNestedOneWithoutPurchase_assetsInput
    sales_invoice?: InvoiceCreateNestedOneWithoutSales_assetsInput
    arrival?: ArrivalCreateNestedOneWithoutAssetsInput
    departure?: DepartureCreateNestedOneWithoutAssetsInput
    hold?: HoldCreateNestedOneWithoutAssetsInput
    asset_accessories?: AssetAccessoryCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferCreateNestedManyWithoutAssetInput
    files?: FileCreateNestedManyWithoutAssetInput
    comments?: CommentCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAsset_historyInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
    cost?: CostUncheckedCreateNestedOneWithoutAssetInput
    technical_specification?: TechnicalSpecificationUncheckedCreateNestedOneWithoutAssetInput
    asset_accessories?: AssetAccessoryUncheckedCreateNestedManyWithoutAssetInput
    asset_errors?: AssetErrorUncheckedCreateNestedManyWithoutAssetInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutAssetInput
    asset_transfers?: AssetTransferUncheckedCreateNestedManyWithoutAssetInput
    files?: FileUncheckedCreateNestedManyWithoutAssetInput
    comments?: CommentUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAsset_historyInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAsset_historyInput, AssetUncheckedCreateWithoutAsset_historyInput>
  }

  export type UserCreateWithoutAsset_historyInput = {
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorCreateNestedManyWithoutFixedByInput
    transfers?: TransferCreateNestedManyWithoutCreated_byInput
    departures?: DepartureCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceCreateNestedManyWithoutUpdated_byInput
    files?: FileCreateNestedManyWithoutUploaded_byInput
    comments?: CommentCreateNestedManyWithoutCreated_byInput
    asset_parts?: AssetPartCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAsset_historyInput = {
    id?: number
    email: string
    name: string
    googleId?: string | null
    role: $Enums.Role
    asset_errors_added?: AssetErrorUncheckedCreateNestedManyWithoutAddedByInput
    asset_errors_fixed?: AssetErrorUncheckedCreateNestedManyWithoutFixedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutCreated_byInput
    departures?: DepartureUncheckedCreateNestedManyWithoutCreated_byInput
    departure_sales_reps?: DepartureUncheckedCreateNestedManyWithoutSales_representativeInput
    arrivals?: ArrivalUncheckedCreateNestedManyWithoutCreated_byInput
    holds_created?: HoldUncheckedCreateNestedManyWithoutCreated_byInput
    holds_for?: HoldUncheckedCreateNestedManyWithoutCreated_forInput
    invoices_updated?: InvoiceUncheckedCreateNestedManyWithoutUpdated_byInput
    files?: FileUncheckedCreateNestedManyWithoutUploaded_byInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreated_byInput
    asset_parts?: AssetPartUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAsset_historyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAsset_historyInput, UserUncheckedCreateWithoutAsset_historyInput>
  }

  export type AssetUpsertWithoutAsset_historyInput = {
    update: XOR<AssetUpdateWithoutAsset_historyInput, AssetUncheckedUpdateWithoutAsset_historyInput>
    create: XOR<AssetCreateWithoutAsset_historyInput, AssetUncheckedCreateWithoutAsset_historyInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAsset_historyInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAsset_historyInput, AssetUncheckedUpdateWithoutAsset_historyInput>
  }

  export type AssetUpdateWithoutAsset_historyInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAsset_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type UserUpsertWithoutAsset_historyInput = {
    update: XOR<UserUpdateWithoutAsset_historyInput, UserUncheckedUpdateWithoutAsset_historyInput>
    create: XOR<UserCreateWithoutAsset_historyInput, UserUncheckedCreateWithoutAsset_historyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAsset_historyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAsset_historyInput, UserUncheckedUpdateWithoutAsset_historyInput>
  }

  export type UserUpdateWithoutAsset_historyInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUpdateManyWithoutUpdated_byNestedInput
    files?: FileUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUpdateManyWithoutCreated_byNestedInput
    asset_parts?: AssetPartUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAsset_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    asset_errors_added?: AssetErrorUncheckedUpdateManyWithoutAddedByNestedInput
    asset_errors_fixed?: AssetErrorUncheckedUpdateManyWithoutFixedByNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutCreated_byNestedInput
    departures?: DepartureUncheckedUpdateManyWithoutCreated_byNestedInput
    departure_sales_reps?: DepartureUncheckedUpdateManyWithoutSales_representativeNestedInput
    arrivals?: ArrivalUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_created?: HoldUncheckedUpdateManyWithoutCreated_byNestedInput
    holds_for?: HoldUncheckedUpdateManyWithoutCreated_forNestedInput
    invoices_updated?: InvoiceUncheckedUpdateManyWithoutUpdated_byNestedInput
    files?: FileUncheckedUpdateManyWithoutUploaded_byNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreated_byNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AssetAccessoryCreateManyAssetInput = {
    accessory: $Enums.Accessory
  }

  export type AssetErrorCreateManyAssetInput = {
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetPartCreateManyAssetInput = {
    part_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetTransferCreateManyAssetInput = {
    transfer_id: number
  }

  export type FileCreateManyAssetInput = {
    id?: number
    uploaded_by_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type CommentCreateManyAssetInput = {
    id?: number
    created_by_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type AssetHistoryCreateManyAssetInput = {
    id?: number
    user_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetAccessoryUpdateWithoutAssetInput = {
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type AssetAccessoryUncheckedUpdateWithoutAssetInput = {
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type AssetAccessoryUncheckedUpdateManyWithoutAssetInput = {
    accessory?: EnumAccessoryFieldUpdateOperationsInput | $Enums.Accessory
  }

  export type AssetErrorUpdateWithoutAssetInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: ErrorUpdateOneRequiredWithoutAsset_errorsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutAsset_errors_addedNestedInput
    fixedBy?: UserUpdateOneWithoutAsset_errors_fixedNestedInput
  }

  export type AssetErrorUncheckedUpdateWithoutAssetInput = {
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUncheckedUpdateManyWithoutAssetInput = {
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetPartUpdateWithoutAssetInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
    part?: PartUpdateOneRequiredWithoutAsset_partsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutAsset_partsNestedInput
  }

  export type AssetPartUncheckedUpdateWithoutAssetInput = {
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetPartUncheckedUpdateManyWithoutAssetInput = {
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetTransferUpdateWithoutAssetInput = {
    transfer?: TransferUpdateOneRequiredWithoutAsset_transfersNestedInput
  }

  export type AssetTransferUncheckedUpdateWithoutAssetInput = {
    transfer_id?: IntFieldUpdateOperationsInput | number
  }

  export type AssetTransferUncheckedUpdateManyWithoutAssetInput = {
    transfer_id?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutAssetInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: UserUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    uploaded_by_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    uploaded_by_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAssetInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetHistoryUpdateWithoutAssetInput = {
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAsset_historyNestedInput
  }

  export type AssetHistoryUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type ErrorCreateManyCategoryInput = {
    id?: number
    code: string
    description?: string | null
  }

  export type ErrorUpdateWithoutCategoryInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    asset_errors?: AssetErrorUpdateManyWithoutErrorNestedInput
  }

  export type ErrorUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutErrorNestedInput
  }

  export type ErrorUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetErrorCreateManyErrorInput = {
    asset_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorUpdateWithoutErrorInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asset?: AssetUpdateOneRequiredWithoutAsset_errorsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutAsset_errors_addedNestedInput
    fixedBy?: UserUpdateOneWithoutAsset_errors_fixedNestedInput
  }

  export type AssetErrorUncheckedUpdateWithoutErrorInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUncheckedUpdateManyWithoutErrorInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetPartCreateManyPartInput = {
    asset_id: number
    updated_at: Date | string
    updated_by: number
    part_operation: $Enums.PartOperation
  }

  export type AssetPartUpdateWithoutPartInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
    asset?: AssetUpdateOneRequiredWithoutAsset_partsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutAsset_partsNestedInput
  }

  export type AssetPartUncheckedUpdateWithoutPartInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetPartUncheckedUpdateManyWithoutPartInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: IntFieldUpdateOperationsInput | number
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetTransferCreateManyTransferInput = {
    asset_id: number
  }

  export type AssetTransferUpdateWithoutTransferInput = {
    asset?: AssetUpdateOneRequiredWithoutAsset_transfersNestedInput
  }

  export type AssetTransferUncheckedUpdateWithoutTransferInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
  }

  export type AssetTransferUncheckedUpdateManyWithoutTransferInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
  }

  export type AssetCreateManyArrivalInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutArrivalInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyDepartureInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutDepartureInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutDepartureInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutDepartureInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyHoldInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutHoldInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutHoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutHoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyPurchase_invoiceInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetCreateManySales_invoiceInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutPurchase_invoiceInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutPurchase_invoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutPurchase_invoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutSales_invoiceInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutSales_invoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutSales_invoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyWarehouseInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type TransferCreateManyOriginInput = {
    id?: number
    transfer_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type TransferCreateManyDestinationInput = {
    id?: number
    transfer_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateManyOriginInput = {
    id?: number
    departure_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type ArrivalCreateManyDestinationInput = {
    id?: number
    arrival_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type LocationCreateManyWarehouseInput = {
    location: string
  }

  export type AssetUpdateWithoutWarehouseInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutOriginInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutTransfersNestedInput
    created_by?: UserUpdateOneRequiredWithoutTransfersNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutDestinationInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutTransfersNestedInput
    created_by?: UserUpdateOneRequiredWithoutTransfersNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpdateWithoutOriginInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateManyWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalUpdateWithoutDestinationInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutArrivalsNestedInput
    assets?: AssetUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutWarehouseInput = {
    location?: StringFieldUpdateOperationsInput | string
    assets?: AssetUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutWarehouseInput = {
    location?: StringFieldUpdateOperationsInput | string
    assets?: AssetUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutWarehouseInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCreateManyLocationInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    model_id: number
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutLocationInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    model_id?: IntFieldUpdateOperationsInput | number
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateManyBrandInput = {
    id?: number
    name: string
    asset_type: $Enums.AssetType
    weight: number
    size: number
  }

  export type ErrorCategoryCreateManyBrandInput = {
    id?: number
    category: string
  }

  export type AssetCreateManyBrandInput = {
    id?: number
    barcode: string
    serial_number: string
    model_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type ModelUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    assets?: AssetUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    assets?: AssetUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    weight?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
  }

  export type ErrorCategoryUpdateWithoutBrandInput = {
    category?: StringFieldUpdateOperationsInput | string
    errors?: ErrorUpdateManyWithoutCategoryNestedInput
  }

  export type ErrorCategoryUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    errors?: ErrorUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ErrorCategoryUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type AssetUpdateWithoutBrandInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    model?: ModelUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyModelInput = {
    id?: number
    barcode: string
    serial_number: string
    brand_id: number
    warehouse_id: number
    asset_location?: string | null
    asset_type: $Enums.AssetType
    tracking_status: $Enums.TrackingStatus
    exit_status: $Enums.ExitStatus
    technical_status: $Enums.TechnicalStatus
    purchase_invoice_id?: number | null
    sales_invoice_id?: number | null
    arrival_id?: number | null
    departure_id?: number | null
    hold_id?: number | null
    is_held: boolean
    created_at: Date | string
  }

  export type AssetUpdateWithoutModelInput = {
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUpdateOneWithoutAssetNestedInput
    brand?: BrandUpdateOneRequiredWithoutAssetsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchase_invoice?: InvoiceUpdateOneWithoutPurchase_assetsNestedInput
    sales_invoice?: InvoiceUpdateOneWithoutSales_assetsNestedInput
    arrival?: ArrivalUpdateOneWithoutAssetsNestedInput
    departure?: DepartureUpdateOneWithoutAssetsNestedInput
    hold?: HoldUpdateOneWithoutAssetsNestedInput
    asset_accessories?: AssetAccessoryUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutAssetNestedInput
    files?: FileUpdateManyWithoutAssetNestedInput
    comments?: CommentUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: CostUncheckedUpdateOneWithoutAssetNestedInput
    technical_specification?: TechnicalSpecificationUncheckedUpdateOneWithoutAssetNestedInput
    asset_accessories?: AssetAccessoryUncheckedUpdateManyWithoutAssetNestedInput
    asset_errors?: AssetErrorUncheckedUpdateManyWithoutAssetNestedInput
    asset_parts?: AssetPartUncheckedUpdateManyWithoutAssetNestedInput
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutAssetNestedInput
    files?: FileUncheckedUpdateManyWithoutAssetNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAssetNestedInput
    asset_history?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    brand_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    asset_location?: NullableStringFieldUpdateOperationsInput | string | null
    asset_type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    tracking_status?: EnumTrackingStatusFieldUpdateOperationsInput | $Enums.TrackingStatus
    exit_status?: EnumExitStatusFieldUpdateOperationsInput | $Enums.ExitStatus
    technical_status?: EnumTechnicalStatusFieldUpdateOperationsInput | $Enums.TechnicalStatus
    purchase_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    sales_invoice_id?: NullableIntFieldUpdateOperationsInput | number | null
    arrival_id?: NullableIntFieldUpdateOperationsInput | number | null
    departure_id?: NullableIntFieldUpdateOperationsInput | number | null
    hold_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_held?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetErrorCreateManyAddedByInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_at: Date | string
    fixed_by?: number | null
    fixed_at?: Date | string | null
  }

  export type AssetErrorCreateManyFixedByInput = {
    asset_id: number
    error_id: number
    is_fixed: boolean
    added_by: number
    added_at: Date | string
    fixed_at?: Date | string | null
  }

  export type TransferCreateManyCreated_byInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateManyCreated_byInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateManySales_representativeInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type ArrivalCreateManyCreated_byInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    transporter_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type HoldCreateManyCreated_byInput = {
    id?: number
    hold_number: string
    created_for_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type HoldCreateManyCreated_forInput = {
    id?: number
    hold_number: string
    created_by_id: number
    customer_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type InvoiceCreateManyUpdated_byInput = {
    id?: number
    invoice_number: string
    organization_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
  }

  export type FileCreateManyUploaded_byInput = {
    id?: number
    asset_id: number
    name: string
    type: $Enums.FileType
    data: Uint8Array
    url: string
    size: number
    uploaded_at: Date | string
  }

  export type CommentCreateManyCreated_byInput = {
    id?: number
    asset_id: number
    comment: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type AssetHistoryCreateManyUserInput = {
    id?: number
    asset_id: number
    operation: $Enums.GeneralOperation
    data_field: $Enums.DataField
    changed_on: Date | string
    changes: JsonNullValueInput | InputJsonValue
  }

  export type AssetPartCreateManyUpdatedByInput = {
    asset_id: number
    part_id: number
    updated_at: Date | string
    part_operation: $Enums.PartOperation
  }

  export type AssetErrorUpdateWithoutAddedByInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asset?: AssetUpdateOneRequiredWithoutAsset_errorsNestedInput
    error?: ErrorUpdateOneRequiredWithoutAsset_errorsNestedInput
    fixedBy?: UserUpdateOneWithoutAsset_errors_fixedNestedInput
  }

  export type AssetErrorUncheckedUpdateWithoutAddedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUncheckedUpdateManyWithoutAddedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_by?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUpdateWithoutFixedByInput = {
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asset?: AssetUpdateOneRequiredWithoutAsset_errorsNestedInput
    error?: ErrorUpdateOneRequiredWithoutAsset_errorsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutAsset_errors_addedNestedInput
  }

  export type AssetErrorUncheckedUpdateWithoutFixedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetErrorUncheckedUpdateManyWithoutFixedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    error_id?: IntFieldUpdateOperationsInput | number
    is_fixed?: BoolFieldUpdateOperationsInput | boolean
    added_by?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fixed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutCreated_byInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutTransfersNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpdateWithoutCreated_byInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpdateWithoutSales_representativeInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateWithoutSales_representativeInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateManyWithoutSales_representativeInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalUpdateWithoutCreated_byInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutArrivalsNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput
    assets?: AssetUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldUpdateWithoutCreated_byInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_for?: UserUpdateOneRequiredWithoutHolds_forNestedInput
    customer?: OrganizationUpdateOneRequiredWithoutHoldsNestedInput
    assets?: AssetUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_for_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_for_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldUpdateWithoutCreated_forInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutHolds_createdNestedInput
    customer?: OrganizationUpdateOneRequiredWithoutHoldsNestedInput
    assets?: AssetUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateWithoutCreated_forInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateManyWithoutCreated_forInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUpdated_byInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    organization?: OrganizationUpdateOneRequiredWithoutInvoicesNestedInput
    purchase_assets?: AssetUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUpdated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    purchase_assets?: AssetUncheckedUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUncheckedUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUpdated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
  }

  export type FileUpdateWithoutUploaded_byInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutUploaded_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutUploaded_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCreated_byInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetHistoryUpdateWithoutUserInput = {
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
    asset?: AssetUpdateOneRequiredWithoutAsset_historyNestedInput
  }

  export type AssetHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset_id?: IntFieldUpdateOperationsInput | number
    operation?: EnumGeneralOperationFieldUpdateOperationsInput | $Enums.GeneralOperation
    data_field?: EnumDataFieldFieldUpdateOperationsInput | $Enums.DataField
    changed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: JsonNullValueInput | InputJsonValue
  }

  export type AssetPartUpdateWithoutUpdatedByInput = {
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
    asset?: AssetUpdateOneRequiredWithoutAsset_partsNestedInput
    part?: PartUpdateOneRequiredWithoutAsset_partsNestedInput
  }

  export type AssetPartUncheckedUpdateWithoutUpdatedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type AssetPartUncheckedUpdateManyWithoutUpdatedByInput = {
    asset_id?: IntFieldUpdateOperationsInput | number
    part_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    part_operation?: EnumPartOperationFieldUpdateOperationsInput | $Enums.PartOperation
  }

  export type InvoiceCreateManyOrganizationInput = {
    id?: number
    invoice_number: string
    updated_by_id: number
    is_cleared: boolean
    created_at: Date | string
    invoice_type: $Enums.InvoiceType
  }

  export type ArrivalCreateManyOriginInput = {
    id?: number
    arrival_number: string
    destination_id: number
    transporter_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type ArrivalCreateManyTransporterInput = {
    id?: number
    arrival_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateManyDestinationInput = {
    id?: number
    departure_number: string
    origin_id: number
    transporter_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type DepartureCreateManyTransporterInput = {
    id?: number
    departure_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    sales_representative_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type HoldCreateManyCustomerInput = {
    id?: number
    hold_number: string
    created_by_id: number
    created_for_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type TransferCreateManyTransporterInput = {
    id?: number
    transfer_number: string
    origin_id: number
    destination_id: number
    created_by_id: number
    notes?: string | null
    created_at: Date | string
  }

  export type InvoiceUpdateWithoutOrganizationInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    updated_by?: UserUpdateOneRequiredWithoutInvoices_updatedNestedInput
    purchase_assets?: AssetUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    purchase_assets?: AssetUncheckedUpdateManyWithoutPurchase_invoiceNestedInput
    sales_assets?: AssetUncheckedUpdateManyWithoutSales_invoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    updated_by_id?: IntFieldUpdateOperationsInput | number
    is_cleared?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice_type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
  }

  export type ArrivalUpdateWithoutOriginInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: WarehouseUpdateOneRequiredWithoutArrivalsNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutArrivals_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutArrivalsNestedInput
    assets?: AssetUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateManyWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    destination_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalUpdateWithoutTransporterInput = {
    arrival_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: OrganizationUpdateOneRequiredWithoutArrivals_originNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutArrivalsNestedInput
    created_by?: UserUpdateOneRequiredWithoutArrivalsNestedInput
    assets?: AssetUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalUncheckedUpdateManyWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrival_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpdateWithoutDestinationInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    transporter?: OrganizationUpdateOneRequiredWithoutDepartures_transporterNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    transporter_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartureUpdateWithoutTransporterInput = {
    departure_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutDeparturesNestedInput
    destination?: OrganizationUpdateOneRequiredWithoutDepartures_destinationNestedInput
    created_by?: UserUpdateOneRequiredWithoutDeparturesNestedInput
    sales_representative?: UserUpdateOneRequiredWithoutDeparture_sales_repsNestedInput
    assets?: AssetUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutDepartureNestedInput
  }

  export type DepartureUncheckedUpdateManyWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    departure_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    sales_representative_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldUpdateWithoutCustomerInput = {
    hold_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutHolds_createdNestedInput
    created_for?: UserUpdateOneRequiredWithoutHolds_forNestedInput
    assets?: AssetUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    created_for_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutHoldNestedInput
  }

  export type HoldUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hold_number?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    created_for_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutTransporterInput = {
    transfer_number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: WarehouseUpdateOneRequiredWithoutOrigin_transfersNestedInput
    destination?: WarehouseUpdateOneRequiredWithoutDestination_transfersNestedInput
    created_by?: UserUpdateOneRequiredWithoutTransfersNestedInput
    asset_transfers?: AssetTransferUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_transfers?: AssetTransferUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutTransporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    transfer_number?: StringFieldUpdateOperationsInput | string
    origin_id?: IntFieldUpdateOperationsInput | number
    destination_id?: IntFieldUpdateOperationsInput | number
    created_by_id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}